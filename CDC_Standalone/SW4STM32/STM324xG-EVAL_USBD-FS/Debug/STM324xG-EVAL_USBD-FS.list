
STM324xG-EVAL_USBD-FS.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   00000188  08000000  08000000  00010000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         00004904  08000188  08000188  00010188  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       00000090  08004a8c  08004a8c  00014a8c  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .ARM          00000008  08004b1c  08004b1c  00014b1c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .init_array   00000004  08004b24  08004b24  00014b24  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  5 .fini_array   00000004  08004b28  08004b28  00014b28  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  6 .data         00000150  20000000  08004b2c  00020000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .ccmram       00000000  10000000  10000000  00020150  2**0
                  CONTENTS
  8 .bss          00001b50  20000150  20000150  00020150  2**2
                  ALLOC
  9 ._user_heap_stack 00001a00  20001ca0  20001ca0  00020150  2**0
                  ALLOC
 10 .ARM.attributes 00000030  00000000  00000000  00020150  2**0
                  CONTENTS, READONLY
 11 .comment      00000043  00000000  00000000  00020180  2**0
                  CONTENTS, READONLY
 12 .debug_line   00020f13  00000000  00000000  000201c3  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 13 .debug_line_str 000000a4  00000000  00000000  000410d6  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .debug_info   0001b966  00000000  00000000  0004117a  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_abbrev 00004076  00000000  00000000  0005cae0  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_aranges 00000f88  00000000  00000000  00060b58  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_str    000fd610  00000000  00000000  00061ae0  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .debug_rnglists 00000e58  00000000  00000000  0015f0f0  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 19 .debug_macro  0002ab4e  00000000  00000000  0015ff48  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 20 .debug_frame  00003100  00000000  00000000  0018aa98  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 21 .debug_loclists 0000af6d  00000000  00000000  0018db98  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

08000188 <__do_global_dtors_aux>:
 8000188:	b510      	push	{r4, lr}
 800018a:	4c05      	ldr	r4, [pc, #20]	; (80001a0 <__do_global_dtors_aux+0x18>)
 800018c:	7823      	ldrb	r3, [r4, #0]
 800018e:	b933      	cbnz	r3, 800019e <__do_global_dtors_aux+0x16>
 8000190:	4b04      	ldr	r3, [pc, #16]	; (80001a4 <__do_global_dtors_aux+0x1c>)
 8000192:	b113      	cbz	r3, 800019a <__do_global_dtors_aux+0x12>
 8000194:	4804      	ldr	r0, [pc, #16]	; (80001a8 <__do_global_dtors_aux+0x20>)
 8000196:	f3af 8000 	nop.w
 800019a:	2301      	movs	r3, #1
 800019c:	7023      	strb	r3, [r4, #0]
 800019e:	bd10      	pop	{r4, pc}
 80001a0:	20000150 	.word	0x20000150
 80001a4:	00000000 	.word	0x00000000
 80001a8:	08004a74 	.word	0x08004a74

080001ac <frame_dummy>:
 80001ac:	b508      	push	{r3, lr}
 80001ae:	4b03      	ldr	r3, [pc, #12]	; (80001bc <frame_dummy+0x10>)
 80001b0:	b11b      	cbz	r3, 80001ba <frame_dummy+0xe>
 80001b2:	4903      	ldr	r1, [pc, #12]	; (80001c0 <frame_dummy+0x14>)
 80001b4:	4803      	ldr	r0, [pc, #12]	; (80001c4 <frame_dummy+0x18>)
 80001b6:	f3af 8000 	nop.w
 80001ba:	bd08      	pop	{r3, pc}
 80001bc:	00000000 	.word	0x00000000
 80001c0:	20000154 	.word	0x20000154
 80001c4:	08004a74 	.word	0x08004a74

080001c8 <__aeabi_uldivmod>:
 80001c8:	b953      	cbnz	r3, 80001e0 <__aeabi_uldivmod+0x18>
 80001ca:	b94a      	cbnz	r2, 80001e0 <__aeabi_uldivmod+0x18>
 80001cc:	2900      	cmp	r1, #0
 80001ce:	bf08      	it	eq
 80001d0:	2800      	cmpeq	r0, #0
 80001d2:	bf1c      	itt	ne
 80001d4:	f04f 31ff 	movne.w	r1, #4294967295
 80001d8:	f04f 30ff 	movne.w	r0, #4294967295
 80001dc:	f000 b970 	b.w	80004c0 <__aeabi_idiv0>
 80001e0:	f1ad 0c08 	sub.w	ip, sp, #8
 80001e4:	e96d ce04 	strd	ip, lr, [sp, #-16]!
 80001e8:	f000 f806 	bl	80001f8 <__udivmoddi4>
 80001ec:	f8dd e004 	ldr.w	lr, [sp, #4]
 80001f0:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 80001f4:	b004      	add	sp, #16
 80001f6:	4770      	bx	lr

080001f8 <__udivmoddi4>:
 80001f8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80001fc:	9e08      	ldr	r6, [sp, #32]
 80001fe:	460d      	mov	r5, r1
 8000200:	4604      	mov	r4, r0
 8000202:	460f      	mov	r7, r1
 8000204:	2b00      	cmp	r3, #0
 8000206:	d14a      	bne.n	800029e <__udivmoddi4+0xa6>
 8000208:	428a      	cmp	r2, r1
 800020a:	4694      	mov	ip, r2
 800020c:	d965      	bls.n	80002da <__udivmoddi4+0xe2>
 800020e:	fab2 f382 	clz	r3, r2
 8000212:	b143      	cbz	r3, 8000226 <__udivmoddi4+0x2e>
 8000214:	fa02 fc03 	lsl.w	ip, r2, r3
 8000218:	f1c3 0220 	rsb	r2, r3, #32
 800021c:	409f      	lsls	r7, r3
 800021e:	fa20 f202 	lsr.w	r2, r0, r2
 8000222:	4317      	orrs	r7, r2
 8000224:	409c      	lsls	r4, r3
 8000226:	ea4f 4e1c 	mov.w	lr, ip, lsr #16
 800022a:	fa1f f58c 	uxth.w	r5, ip
 800022e:	fbb7 f1fe 	udiv	r1, r7, lr
 8000232:	0c22      	lsrs	r2, r4, #16
 8000234:	fb0e 7711 	mls	r7, lr, r1, r7
 8000238:	ea42 4207 	orr.w	r2, r2, r7, lsl #16
 800023c:	fb01 f005 	mul.w	r0, r1, r5
 8000240:	4290      	cmp	r0, r2
 8000242:	d90a      	bls.n	800025a <__udivmoddi4+0x62>
 8000244:	eb1c 0202 	adds.w	r2, ip, r2
 8000248:	f101 37ff 	add.w	r7, r1, #4294967295
 800024c:	f080 811c 	bcs.w	8000488 <__udivmoddi4+0x290>
 8000250:	4290      	cmp	r0, r2
 8000252:	f240 8119 	bls.w	8000488 <__udivmoddi4+0x290>
 8000256:	3902      	subs	r1, #2
 8000258:	4462      	add	r2, ip
 800025a:	1a12      	subs	r2, r2, r0
 800025c:	b2a4      	uxth	r4, r4
 800025e:	fbb2 f0fe 	udiv	r0, r2, lr
 8000262:	fb0e 2210 	mls	r2, lr, r0, r2
 8000266:	ea44 4402 	orr.w	r4, r4, r2, lsl #16
 800026a:	fb00 f505 	mul.w	r5, r0, r5
 800026e:	42a5      	cmp	r5, r4
 8000270:	d90a      	bls.n	8000288 <__udivmoddi4+0x90>
 8000272:	eb1c 0404 	adds.w	r4, ip, r4
 8000276:	f100 32ff 	add.w	r2, r0, #4294967295
 800027a:	f080 8107 	bcs.w	800048c <__udivmoddi4+0x294>
 800027e:	42a5      	cmp	r5, r4
 8000280:	f240 8104 	bls.w	800048c <__udivmoddi4+0x294>
 8000284:	4464      	add	r4, ip
 8000286:	3802      	subs	r0, #2
 8000288:	ea40 4001 	orr.w	r0, r0, r1, lsl #16
 800028c:	1b64      	subs	r4, r4, r5
 800028e:	2100      	movs	r1, #0
 8000290:	b11e      	cbz	r6, 800029a <__udivmoddi4+0xa2>
 8000292:	40dc      	lsrs	r4, r3
 8000294:	2300      	movs	r3, #0
 8000296:	e9c6 4300 	strd	r4, r3, [r6]
 800029a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800029e:	428b      	cmp	r3, r1
 80002a0:	d908      	bls.n	80002b4 <__udivmoddi4+0xbc>
 80002a2:	2e00      	cmp	r6, #0
 80002a4:	f000 80ed 	beq.w	8000482 <__udivmoddi4+0x28a>
 80002a8:	2100      	movs	r1, #0
 80002aa:	e9c6 0500 	strd	r0, r5, [r6]
 80002ae:	4608      	mov	r0, r1
 80002b0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80002b4:	fab3 f183 	clz	r1, r3
 80002b8:	2900      	cmp	r1, #0
 80002ba:	d149      	bne.n	8000350 <__udivmoddi4+0x158>
 80002bc:	42ab      	cmp	r3, r5
 80002be:	d302      	bcc.n	80002c6 <__udivmoddi4+0xce>
 80002c0:	4282      	cmp	r2, r0
 80002c2:	f200 80f8 	bhi.w	80004b6 <__udivmoddi4+0x2be>
 80002c6:	1a84      	subs	r4, r0, r2
 80002c8:	eb65 0203 	sbc.w	r2, r5, r3
 80002cc:	2001      	movs	r0, #1
 80002ce:	4617      	mov	r7, r2
 80002d0:	2e00      	cmp	r6, #0
 80002d2:	d0e2      	beq.n	800029a <__udivmoddi4+0xa2>
 80002d4:	e9c6 4700 	strd	r4, r7, [r6]
 80002d8:	e7df      	b.n	800029a <__udivmoddi4+0xa2>
 80002da:	b902      	cbnz	r2, 80002de <__udivmoddi4+0xe6>
 80002dc:	deff      	udf	#255	; 0xff
 80002de:	fab2 f382 	clz	r3, r2
 80002e2:	2b00      	cmp	r3, #0
 80002e4:	f040 8090 	bne.w	8000408 <__udivmoddi4+0x210>
 80002e8:	1a8a      	subs	r2, r1, r2
 80002ea:	ea4f 471c 	mov.w	r7, ip, lsr #16
 80002ee:	fa1f fe8c 	uxth.w	lr, ip
 80002f2:	2101      	movs	r1, #1
 80002f4:	fbb2 f5f7 	udiv	r5, r2, r7
 80002f8:	fb07 2015 	mls	r0, r7, r5, r2
 80002fc:	0c22      	lsrs	r2, r4, #16
 80002fe:	ea42 4200 	orr.w	r2, r2, r0, lsl #16
 8000302:	fb0e f005 	mul.w	r0, lr, r5
 8000306:	4290      	cmp	r0, r2
 8000308:	d908      	bls.n	800031c <__udivmoddi4+0x124>
 800030a:	eb1c 0202 	adds.w	r2, ip, r2
 800030e:	f105 38ff 	add.w	r8, r5, #4294967295
 8000312:	d202      	bcs.n	800031a <__udivmoddi4+0x122>
 8000314:	4290      	cmp	r0, r2
 8000316:	f200 80cb 	bhi.w	80004b0 <__udivmoddi4+0x2b8>
 800031a:	4645      	mov	r5, r8
 800031c:	1a12      	subs	r2, r2, r0
 800031e:	b2a4      	uxth	r4, r4
 8000320:	fbb2 f0f7 	udiv	r0, r2, r7
 8000324:	fb07 2210 	mls	r2, r7, r0, r2
 8000328:	ea44 4402 	orr.w	r4, r4, r2, lsl #16
 800032c:	fb0e fe00 	mul.w	lr, lr, r0
 8000330:	45a6      	cmp	lr, r4
 8000332:	d908      	bls.n	8000346 <__udivmoddi4+0x14e>
 8000334:	eb1c 0404 	adds.w	r4, ip, r4
 8000338:	f100 32ff 	add.w	r2, r0, #4294967295
 800033c:	d202      	bcs.n	8000344 <__udivmoddi4+0x14c>
 800033e:	45a6      	cmp	lr, r4
 8000340:	f200 80bb 	bhi.w	80004ba <__udivmoddi4+0x2c2>
 8000344:	4610      	mov	r0, r2
 8000346:	eba4 040e 	sub.w	r4, r4, lr
 800034a:	ea40 4005 	orr.w	r0, r0, r5, lsl #16
 800034e:	e79f      	b.n	8000290 <__udivmoddi4+0x98>
 8000350:	f1c1 0720 	rsb	r7, r1, #32
 8000354:	408b      	lsls	r3, r1
 8000356:	fa22 fc07 	lsr.w	ip, r2, r7
 800035a:	ea4c 0c03 	orr.w	ip, ip, r3
 800035e:	fa05 f401 	lsl.w	r4, r5, r1
 8000362:	fa20 f307 	lsr.w	r3, r0, r7
 8000366:	40fd      	lsrs	r5, r7
 8000368:	ea4f 491c 	mov.w	r9, ip, lsr #16
 800036c:	4323      	orrs	r3, r4
 800036e:	fbb5 f8f9 	udiv	r8, r5, r9
 8000372:	fa1f fe8c 	uxth.w	lr, ip
 8000376:	fb09 5518 	mls	r5, r9, r8, r5
 800037a:	0c1c      	lsrs	r4, r3, #16
 800037c:	ea44 4405 	orr.w	r4, r4, r5, lsl #16
 8000380:	fb08 f50e 	mul.w	r5, r8, lr
 8000384:	42a5      	cmp	r5, r4
 8000386:	fa02 f201 	lsl.w	r2, r2, r1
 800038a:	fa00 f001 	lsl.w	r0, r0, r1
 800038e:	d90b      	bls.n	80003a8 <__udivmoddi4+0x1b0>
 8000390:	eb1c 0404 	adds.w	r4, ip, r4
 8000394:	f108 3aff 	add.w	sl, r8, #4294967295
 8000398:	f080 8088 	bcs.w	80004ac <__udivmoddi4+0x2b4>
 800039c:	42a5      	cmp	r5, r4
 800039e:	f240 8085 	bls.w	80004ac <__udivmoddi4+0x2b4>
 80003a2:	f1a8 0802 	sub.w	r8, r8, #2
 80003a6:	4464      	add	r4, ip
 80003a8:	1b64      	subs	r4, r4, r5
 80003aa:	b29d      	uxth	r5, r3
 80003ac:	fbb4 f3f9 	udiv	r3, r4, r9
 80003b0:	fb09 4413 	mls	r4, r9, r3, r4
 80003b4:	ea45 4404 	orr.w	r4, r5, r4, lsl #16
 80003b8:	fb03 fe0e 	mul.w	lr, r3, lr
 80003bc:	45a6      	cmp	lr, r4
 80003be:	d908      	bls.n	80003d2 <__udivmoddi4+0x1da>
 80003c0:	eb1c 0404 	adds.w	r4, ip, r4
 80003c4:	f103 35ff 	add.w	r5, r3, #4294967295
 80003c8:	d26c      	bcs.n	80004a4 <__udivmoddi4+0x2ac>
 80003ca:	45a6      	cmp	lr, r4
 80003cc:	d96a      	bls.n	80004a4 <__udivmoddi4+0x2ac>
 80003ce:	3b02      	subs	r3, #2
 80003d0:	4464      	add	r4, ip
 80003d2:	ea43 4308 	orr.w	r3, r3, r8, lsl #16
 80003d6:	fba3 9502 	umull	r9, r5, r3, r2
 80003da:	eba4 040e 	sub.w	r4, r4, lr
 80003de:	42ac      	cmp	r4, r5
 80003e0:	46c8      	mov	r8, r9
 80003e2:	46ae      	mov	lr, r5
 80003e4:	d356      	bcc.n	8000494 <__udivmoddi4+0x29c>
 80003e6:	d053      	beq.n	8000490 <__udivmoddi4+0x298>
 80003e8:	b156      	cbz	r6, 8000400 <__udivmoddi4+0x208>
 80003ea:	ebb0 0208 	subs.w	r2, r0, r8
 80003ee:	eb64 040e 	sbc.w	r4, r4, lr
 80003f2:	fa04 f707 	lsl.w	r7, r4, r7
 80003f6:	40ca      	lsrs	r2, r1
 80003f8:	40cc      	lsrs	r4, r1
 80003fa:	4317      	orrs	r7, r2
 80003fc:	e9c6 7400 	strd	r7, r4, [r6]
 8000400:	4618      	mov	r0, r3
 8000402:	2100      	movs	r1, #0
 8000404:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8000408:	f1c3 0120 	rsb	r1, r3, #32
 800040c:	fa02 fc03 	lsl.w	ip, r2, r3
 8000410:	fa20 f201 	lsr.w	r2, r0, r1
 8000414:	fa25 f101 	lsr.w	r1, r5, r1
 8000418:	409d      	lsls	r5, r3
 800041a:	432a      	orrs	r2, r5
 800041c:	ea4f 471c 	mov.w	r7, ip, lsr #16
 8000420:	fa1f fe8c 	uxth.w	lr, ip
 8000424:	fbb1 f0f7 	udiv	r0, r1, r7
 8000428:	fb07 1510 	mls	r5, r7, r0, r1
 800042c:	0c11      	lsrs	r1, r2, #16
 800042e:	ea41 4105 	orr.w	r1, r1, r5, lsl #16
 8000432:	fb00 f50e 	mul.w	r5, r0, lr
 8000436:	428d      	cmp	r5, r1
 8000438:	fa04 f403 	lsl.w	r4, r4, r3
 800043c:	d908      	bls.n	8000450 <__udivmoddi4+0x258>
 800043e:	eb1c 0101 	adds.w	r1, ip, r1
 8000442:	f100 38ff 	add.w	r8, r0, #4294967295
 8000446:	d22f      	bcs.n	80004a8 <__udivmoddi4+0x2b0>
 8000448:	428d      	cmp	r5, r1
 800044a:	d92d      	bls.n	80004a8 <__udivmoddi4+0x2b0>
 800044c:	3802      	subs	r0, #2
 800044e:	4461      	add	r1, ip
 8000450:	1b49      	subs	r1, r1, r5
 8000452:	b292      	uxth	r2, r2
 8000454:	fbb1 f5f7 	udiv	r5, r1, r7
 8000458:	fb07 1115 	mls	r1, r7, r5, r1
 800045c:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
 8000460:	fb05 f10e 	mul.w	r1, r5, lr
 8000464:	4291      	cmp	r1, r2
 8000466:	d908      	bls.n	800047a <__udivmoddi4+0x282>
 8000468:	eb1c 0202 	adds.w	r2, ip, r2
 800046c:	f105 38ff 	add.w	r8, r5, #4294967295
 8000470:	d216      	bcs.n	80004a0 <__udivmoddi4+0x2a8>
 8000472:	4291      	cmp	r1, r2
 8000474:	d914      	bls.n	80004a0 <__udivmoddi4+0x2a8>
 8000476:	3d02      	subs	r5, #2
 8000478:	4462      	add	r2, ip
 800047a:	1a52      	subs	r2, r2, r1
 800047c:	ea45 4100 	orr.w	r1, r5, r0, lsl #16
 8000480:	e738      	b.n	80002f4 <__udivmoddi4+0xfc>
 8000482:	4631      	mov	r1, r6
 8000484:	4630      	mov	r0, r6
 8000486:	e708      	b.n	800029a <__udivmoddi4+0xa2>
 8000488:	4639      	mov	r1, r7
 800048a:	e6e6      	b.n	800025a <__udivmoddi4+0x62>
 800048c:	4610      	mov	r0, r2
 800048e:	e6fb      	b.n	8000288 <__udivmoddi4+0x90>
 8000490:	4548      	cmp	r0, r9
 8000492:	d2a9      	bcs.n	80003e8 <__udivmoddi4+0x1f0>
 8000494:	ebb9 0802 	subs.w	r8, r9, r2
 8000498:	eb65 0e0c 	sbc.w	lr, r5, ip
 800049c:	3b01      	subs	r3, #1
 800049e:	e7a3      	b.n	80003e8 <__udivmoddi4+0x1f0>
 80004a0:	4645      	mov	r5, r8
 80004a2:	e7ea      	b.n	800047a <__udivmoddi4+0x282>
 80004a4:	462b      	mov	r3, r5
 80004a6:	e794      	b.n	80003d2 <__udivmoddi4+0x1da>
 80004a8:	4640      	mov	r0, r8
 80004aa:	e7d1      	b.n	8000450 <__udivmoddi4+0x258>
 80004ac:	46d0      	mov	r8, sl
 80004ae:	e77b      	b.n	80003a8 <__udivmoddi4+0x1b0>
 80004b0:	3d02      	subs	r5, #2
 80004b2:	4462      	add	r2, ip
 80004b4:	e732      	b.n	800031c <__udivmoddi4+0x124>
 80004b6:	4608      	mov	r0, r1
 80004b8:	e70a      	b.n	80002d0 <__udivmoddi4+0xd8>
 80004ba:	4464      	add	r4, ip
 80004bc:	3802      	subs	r0, #2
 80004be:	e742      	b.n	8000346 <__udivmoddi4+0x14e>

080004c0 <__aeabi_idiv0>:
 80004c0:	4770      	bx	lr
 80004c2:	bf00      	nop

080004c4 <Reset_Handler>:

    .section  .text.Reset_Handler
  .weak  Reset_Handler
  .type  Reset_Handler, %function
Reset_Handler:  
  ldr   sp, =_estack     /* set stack pointer */
 80004c4:	f8df d034 	ldr.w	sp, [pc, #52]	; 80004fc <LoopFillZerobss+0x14>

/* Copy the data segment initializers from flash to SRAM */  
  movs  r1, #0
 80004c8:	2100      	movs	r1, #0
  b  LoopCopyDataInit
 80004ca:	e003      	b.n	80004d4 <LoopCopyDataInit>

080004cc <CopyDataInit>:

CopyDataInit:
  ldr  r3, =_sidata
 80004cc:	4b0c      	ldr	r3, [pc, #48]	; (8000500 <LoopFillZerobss+0x18>)
  ldr  r3, [r3, r1]
 80004ce:	585b      	ldr	r3, [r3, r1]
  str  r3, [r0, r1]
 80004d0:	5043      	str	r3, [r0, r1]
  adds  r1, r1, #4
 80004d2:	3104      	adds	r1, #4

080004d4 <LoopCopyDataInit>:
    
LoopCopyDataInit:
  ldr  r0, =_sdata
 80004d4:	480b      	ldr	r0, [pc, #44]	; (8000504 <LoopFillZerobss+0x1c>)
  ldr  r3, =_edata
 80004d6:	4b0c      	ldr	r3, [pc, #48]	; (8000508 <LoopFillZerobss+0x20>)
  adds  r2, r0, r1
 80004d8:	1842      	adds	r2, r0, r1
  cmp  r2, r3
 80004da:	429a      	cmp	r2, r3
  bcc  CopyDataInit
 80004dc:	d3f6      	bcc.n	80004cc <CopyDataInit>
  ldr  r2, =_sbss
 80004de:	4a0b      	ldr	r2, [pc, #44]	; (800050c <LoopFillZerobss+0x24>)
  b  LoopFillZerobss
 80004e0:	e002      	b.n	80004e8 <LoopFillZerobss>

080004e2 <FillZerobss>:
/* Zero fill the bss segment. */  
FillZerobss:
  movs  r3, #0
 80004e2:	2300      	movs	r3, #0
  str  r3, [r2], #4
 80004e4:	f842 3b04 	str.w	r3, [r2], #4

080004e8 <LoopFillZerobss>:
    
LoopFillZerobss:
  ldr  r3, = _ebss
 80004e8:	4b09      	ldr	r3, [pc, #36]	; (8000510 <LoopFillZerobss+0x28>)
  cmp  r2, r3
 80004ea:	429a      	cmp	r2, r3
  bcc  FillZerobss
 80004ec:	d3f9      	bcc.n	80004e2 <FillZerobss>

/* Call the clock system initialization function.*/
  bl  SystemInit   
 80004ee:	f000 fc7d 	bl	8000dec <SystemInit>
/* Call static constructors */
    bl __libc_init_array
 80004f2:	f004 fa3f 	bl	8004974 <__libc_init_array>
/* Call the application's entry point.*/
  bl  main
 80004f6:	f000 f80f 	bl	8000518 <main>
  bx  lr    
 80004fa:	4770      	bx	lr
  ldr   sp, =_estack     /* set stack pointer */
 80004fc:	20020000 	.word	0x20020000
  ldr  r3, =_sidata
 8000500:	08004b2c 	.word	0x08004b2c
  ldr  r0, =_sdata
 8000504:	20000000 	.word	0x20000000
  ldr  r3, =_edata
 8000508:	20000150 	.word	0x20000150
  ldr  r2, =_sbss
 800050c:	20000150 	.word	0x20000150
  ldr  r3, = _ebss
 8000510:	20001ca0 	.word	0x20001ca0

08000514 <ADC_IRQHandler>:
 * @retval None       
*/
    .section  .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b  Infinite_Loop
 8000514:	e7fe      	b.n	8000514 <ADC_IRQHandler>
	...

08000518 <main>:
  * @brief  Main program
  * @param  None
  * @retval None
  */
int main(void)
{
 8000518:	b500      	push	{lr}
 800051a:	b095      	sub	sp, #84	; 0x54
       - Configure the Flash prefetch, instruction and Data caches
       - Configure the Systick to generate an interrupt each 1 msec
       - Set NVIC Group Priority to 4
       - Global MSP (MCU Support Package) initialization
     */
  HAL_Init();
 800051c:	f000 fcb0 	bl	8000e80 <HAL_Init>
{
  RCC_OscInitTypeDef RCC_OscInitStruct;
  RCC_ClkInitTypeDef RCC_ClkInitStruct;

  /* Enable Power Control clock */
  __HAL_RCC_PWR_CLK_ENABLE();
 8000520:	2400      	movs	r4, #0
 8000522:	4b2b      	ldr	r3, [pc, #172]	; (80005d0 <main+0xb8>)
 8000524:	9401      	str	r4, [sp, #4]
 8000526:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8000528:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 800052c:	641a      	str	r2, [r3, #64]	; 0x40
 800052e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8000530:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8000534:	9301      	str	r3, [sp, #4]
 8000536:	9b01      	ldr	r3, [sp, #4]

  /* The voltage scaling allows optimizing the power consumption when the device is 
     clocked below the maximum system frequency, to update the voltage scaling value 
     regarding system frequency refer to product datasheet.  */
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
 8000538:	4b26      	ldr	r3, [pc, #152]	; (80005d4 <main+0xbc>)
 800053a:	9402      	str	r4, [sp, #8]
 800053c:	681a      	ldr	r2, [r3, #0]
 800053e:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 8000542:	601a      	str	r2, [r3, #0]
 8000544:	681b      	ldr	r3, [r3, #0]
 8000546:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 800054a:	9302      	str	r3, [sp, #8]

  /* Configure RCC Oscillators: All parameters can be changed according to user’s needs */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
 800054c:	2201      	movs	r2, #1
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
 800054e:	9b02      	ldr	r3, [sp, #8]
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
 8000550:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 8000554:	e9cd 2308 	strd	r2, r3, [sp, #32]
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
 8000558:	2502      	movs	r5, #2
 800055a:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
  RCC_OscInitStruct.PLL.PLLM = 25;
  RCC_OscInitStruct.PLL.PLLN = 336;
 800055e:	2119      	movs	r1, #25
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
 8000560:	e9cd 530e 	strd	r5, r3, [sp, #56]	; 0x38
  RCC_OscInitStruct.PLL.PLLN = 336;
 8000564:	f44f 73a8 	mov.w	r3, #336	; 0x150
 8000568:	e9cd 1310 	strd	r1, r3, [sp, #64]	; 0x40
  RCC_OscInitStruct.PLL.PLLP = 2;
  RCC_OscInitStruct.PLL.PLLQ = 7;
  HAL_RCC_OscConfig (&RCC_OscInitStruct);
 800056c:	a808      	add	r0, sp, #32
  RCC_OscInitStruct.PLL.PLLQ = 7;
 800056e:	2307      	movs	r3, #7
 8000570:	9313      	str	r3, [sp, #76]	; 0x4c
  RCC_OscInitStruct.PLL.PLLP = 2;
 8000572:	9512      	str	r5, [sp, #72]	; 0x48
  HAL_RCC_OscConfig (&RCC_OscInitStruct);
 8000574:	f001 fde4 	bl	8002140 <HAL_RCC_OscConfig>
  
  /* RCC Clocks: All parameters can be changed according to user’s needs */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_SYSCLK |RCC_CLOCKTYPE_HCLK |RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2;
 8000578:	230f      	movs	r3, #15
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
 800057a:	e9cd 3503 	strd	r3, r5, [sp, #12]
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;  
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;  
 800057e:	f44f 50a0 	mov.w	r0, #5120	; 0x1400
 8000582:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 8000586:	e9cd 0306 	strd	r0, r3, [sp, #24]
  HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5);
 800058a:	2105      	movs	r1, #5
 800058c:	a803      	add	r0, sp, #12
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
 800058e:	9405      	str	r4, [sp, #20]
  HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5);
 8000590:	f001 ffb0 	bl	80024f4 <HAL_RCC_ClockConfig>
  
  /* STM32F405x/407x/415x/417x Revision Z devices: prefetch is supported  */
  if (HAL_GetREVID() == 0x1001)
 8000594:	f000 fcb0 	bl	8000ef8 <HAL_GetREVID>
 8000598:	f241 0301 	movw	r3, #4097	; 0x1001
 800059c:	4298      	cmp	r0, r3
  {
    /* Enable the Flash prefetch */
    __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
 800059e:	bf08      	it	eq
 80005a0:	4a0d      	ldreq	r2, [pc, #52]	; (80005d8 <main+0xc0>)
  USBD_Init(&USBD_Device, &VCP_Desc, 0);
 80005a2:	490e      	ldr	r1, [pc, #56]	; (80005dc <main+0xc4>)
    __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
 80005a4:	bf08      	it	eq
 80005a6:	6813      	ldreq	r3, [r2, #0]
  USBD_Init(&USBD_Device, &VCP_Desc, 0);
 80005a8:	480d      	ldr	r0, [pc, #52]	; (80005e0 <main+0xc8>)
    __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
 80005aa:	bf04      	itt	eq
 80005ac:	f443 7380 	orreq.w	r3, r3, #256	; 0x100
 80005b0:	6013      	streq	r3, [r2, #0]
  USBD_Init(&USBD_Device, &VCP_Desc, 0);
 80005b2:	2200      	movs	r2, #0
 80005b4:	f003 fccf 	bl	8003f56 <USBD_Init>
  USBD_RegisterClass(&USBD_Device, USBD_CDC_CLASS);
 80005b8:	490a      	ldr	r1, [pc, #40]	; (80005e4 <main+0xcc>)
 80005ba:	4809      	ldr	r0, [pc, #36]	; (80005e0 <main+0xc8>)
 80005bc:	f003 fcde 	bl	8003f7c <USBD_RegisterClass>
  USBD_CDC_RegisterInterface(&USBD_Device, &USBD_CDC_fops);
 80005c0:	4909      	ldr	r1, [pc, #36]	; (80005e8 <main+0xd0>)
 80005c2:	4807      	ldr	r0, [pc, #28]	; (80005e0 <main+0xc8>)
 80005c4:	f003 fc6d 	bl	8003ea2 <USBD_CDC_RegisterInterface>
  USBD_Start(&USBD_Device);
 80005c8:	4805      	ldr	r0, [pc, #20]	; (80005e0 <main+0xc8>)
 80005ca:	f003 fcf0 	bl	8003fae <USBD_Start>
  while (1)
 80005ce:	e7fe      	b.n	80005ce <main+0xb6>
 80005d0:	40023800 	.word	0x40023800
 80005d4:	40007000 	.word	0x40007000
 80005d8:	40023c00 	.word	0x40023c00
 80005dc:	20000050 	.word	0x20000050
 80005e0:	2000016c 	.word	0x2000016c
 80005e4:	200000c8 	.word	0x200000c8
 80005e8:	20000008 	.word	0x20000008

080005ec <HAL_UART_MspInit>:
  *           - NVIC configuration for UART interrupt request enable
  * @param huart: UART handle pointer
  * @retval None
  */
void HAL_UART_MspInit(UART_HandleTypeDef *huart)
{
 80005ec:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80005f0:	b08a      	sub	sp, #40	; 0x28
  static DMA_HandleTypeDef hdma_tx;
  GPIO_InitTypeDef  GPIO_InitStruct;
  
  /*##-1- Enable peripherals and GPIO Clocks #################################*/
  /* Enable GPIO clock */
  USARTx_TX_GPIO_CLK_ENABLE();
 80005f2:	4d41      	ldr	r5, [pc, #260]	; (80006f8 <HAL_UART_MspInit+0x10c>)
 80005f4:	2600      	movs	r6, #0
 80005f6:	9600      	str	r6, [sp, #0]
 80005f8:	6b2b      	ldr	r3, [r5, #48]	; 0x30
 80005fa:	f043 0304 	orr.w	r3, r3, #4
 80005fe:	632b      	str	r3, [r5, #48]	; 0x30
 8000600:	6b2b      	ldr	r3, [r5, #48]	; 0x30
 8000602:	f003 0304 	and.w	r3, r3, #4
 8000606:	9300      	str	r3, [sp, #0]
 8000608:	9b00      	ldr	r3, [sp, #0]
  USARTx_RX_GPIO_CLK_ENABLE();
 800060a:	9601      	str	r6, [sp, #4]
 800060c:	6b2b      	ldr	r3, [r5, #48]	; 0x30
 800060e:	f043 0304 	orr.w	r3, r3, #4
 8000612:	632b      	str	r3, [r5, #48]	; 0x30
 8000614:	6b2b      	ldr	r3, [r5, #48]	; 0x30
 8000616:	f003 0304 	and.w	r3, r3, #4
 800061a:	9301      	str	r3, [sp, #4]
 800061c:	9b01      	ldr	r3, [sp, #4]
  /* Enable USARTx clock */
  USARTx_CLK_ENABLE();
 800061e:	9602      	str	r6, [sp, #8]
 8000620:	6c2b      	ldr	r3, [r5, #64]	; 0x40
 8000622:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
 8000626:	642b      	str	r3, [r5, #64]	; 0x40
 8000628:	6c2b      	ldr	r3, [r5, #64]	; 0x40
 800062a:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
 800062e:	9302      	str	r3, [sp, #8]
 8000630:	9b02      	ldr	r3, [sp, #8]
  /* Enable DMAx clock */
  DMAx_CLK_ENABLE();
 8000632:	9603      	str	r6, [sp, #12]
 8000634:	6b2b      	ldr	r3, [r5, #48]	; 0x30
 8000636:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 800063a:	632b      	str	r3, [r5, #48]	; 0x30
 800063c:	6b2b      	ldr	r3, [r5, #48]	; 0x30
 800063e:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
 8000642:	9303      	str	r3, [sp, #12]
{
 8000644:	4607      	mov	r7, r0
  
  /*##-2- Configure peripheral GPIO ##########################################*/  
  /* UART TX GPIO pin configuration  */
  GPIO_InitStruct.Pin       = USARTx_TX_PIN;
  GPIO_InitStruct.Mode      = GPIO_MODE_AF_PP;
  GPIO_InitStruct.Pull      = GPIO_PULLUP;
 8000646:	2201      	movs	r2, #1
  DMAx_CLK_ENABLE();
 8000648:	9b03      	ldr	r3, [sp, #12]
  GPIO_InitStruct.Speed     = GPIO_SPEED_FAST;
  GPIO_InitStruct.Alternate = USARTx_TX_AF;
  
  HAL_GPIO_Init(USARTx_TX_GPIO_PORT, &GPIO_InitStruct);
 800064a:	482c      	ldr	r0, [pc, #176]	; (80006fc <HAL_UART_MspInit+0x110>)
  GPIO_InitStruct.Mode      = GPIO_MODE_AF_PP;
 800064c:	2302      	movs	r3, #2
 800064e:	f44f 6880 	mov.w	r8, #1024	; 0x400
  GPIO_InitStruct.Alternate = USARTx_TX_AF;
 8000652:	2407      	movs	r4, #7
  HAL_GPIO_Init(USARTx_TX_GPIO_PORT, &GPIO_InitStruct);
 8000654:	a905      	add	r1, sp, #20
  GPIO_InitStruct.Speed     = GPIO_SPEED_FAST;
 8000656:	e9cd 2307 	strd	r2, r3, [sp, #28]
  GPIO_InitStruct.Mode      = GPIO_MODE_AF_PP;
 800065a:	e9cd 8305 	strd	r8, r3, [sp, #20]
  GPIO_InitStruct.Alternate = USARTx_TX_AF;
 800065e:	9409      	str	r4, [sp, #36]	; 0x24
  HAL_GPIO_Init(USARTx_TX_GPIO_PORT, &GPIO_InitStruct);
 8000660:	f000 fea6 	bl	80013b0 <HAL_GPIO_Init>
  
  /* UART RX GPIO pin configuration  */
  GPIO_InitStruct.Pin = USARTx_RX_PIN;
 8000664:	f44f 6300 	mov.w	r3, #2048	; 0x800
  GPIO_InitStruct.Alternate = USARTx_RX_AF;
  
  HAL_GPIO_Init(USARTx_RX_GPIO_PORT, &GPIO_InitStruct);
 8000668:	a905      	add	r1, sp, #20
 800066a:	4824      	ldr	r0, [pc, #144]	; (80006fc <HAL_UART_MspInit+0x110>)
  GPIO_InitStruct.Pin = USARTx_RX_PIN;
 800066c:	9305      	str	r3, [sp, #20]
  GPIO_InitStruct.Alternate = USARTx_RX_AF;
 800066e:	9409      	str	r4, [sp, #36]	; 0x24
  HAL_GPIO_Init(USARTx_RX_GPIO_PORT, &GPIO_InitStruct);
 8000670:	f000 fe9e 	bl	80013b0 <HAL_GPIO_Init>
  
  /*##-3- Configure the NVIC for UART ########################################*/   
  HAL_NVIC_SetPriority(USARTx_IRQn, 5, 0);
 8000674:	4632      	mov	r2, r6
 8000676:	2105      	movs	r1, #5
 8000678:	2027      	movs	r0, #39	; 0x27
 800067a:	f000 fc55 	bl	8000f28 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(USARTx_IRQn);
 800067e:	2027      	movs	r0, #39	; 0x27
 8000680:	f000 fc84 	bl	8000f8c <HAL_NVIC_EnableIRQ>
  
  /*##-4- Configure the DMA streams ##########################################*/
  /* Configure the DMA handler for Transmission process */
  hdma_tx.Instance                 = USARTx_TX_DMA_STREAM;
 8000684:	4c1e      	ldr	r4, [pc, #120]	; (8000700 <HAL_UART_MspInit+0x114>)
  
  hdma_tx.Init.Channel             = USARTx_TX_DMA_CHANNEL;
 8000686:	4a1f      	ldr	r2, [pc, #124]	; (8000704 <HAL_UART_MspInit+0x118>)
 8000688:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
 800068c:	e9c4 2300 	strd	r2, r3, [r4]
  hdma_tx.Init.Direction           = DMA_MEMORY_TO_PERIPH;
 8000690:	2340      	movs	r3, #64	; 0x40
  hdma_tx.Init.PeriphInc           = DMA_PINC_DISABLE;
 8000692:	e9c4 3602 	strd	r3, r6, [r4, #8]
  hdma_tx.Init.MemDataAlignment    = DMA_MDATAALIGN_BYTE;
  hdma_tx.Init.Mode                = DMA_NORMAL;
  hdma_tx.Init.Priority            = DMA_PRIORITY_LOW;
  hdma_tx.Init.FIFOMode            = DMA_FIFOMODE_DISABLE;         
  hdma_tx.Init.FIFOThreshold       = DMA_FIFO_THRESHOLD_FULL;
  hdma_tx.Init.MemBurst            = DMA_MBURST_INC4;
 8000696:	2103      	movs	r1, #3
 8000698:	f44f 0300 	mov.w	r3, #8388608	; 0x800000
 800069c:	e9c4 130a 	strd	r1, r3, [r4, #40]	; 0x28
  hdma_tx.Init.PeriphBurst         = DMA_PBURST_INC4;
  
  HAL_DMA_Init(&hdma_tx);   
 80006a0:	4620      	mov	r0, r4
  hdma_tx.Init.PeriphBurst         = DMA_PBURST_INC4;
 80006a2:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 80006a6:	6323      	str	r3, [r4, #48]	; 0x30
  hdma_tx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
 80006a8:	e9c4 8604 	strd	r8, r6, [r4, #16]
  hdma_tx.Init.Mode                = DMA_NORMAL;
 80006ac:	e9c4 6606 	strd	r6, r6, [r4, #24]
  hdma_tx.Init.FIFOMode            = DMA_FIFOMODE_DISABLE;         
 80006b0:	e9c4 6608 	strd	r6, r6, [r4, #32]
  HAL_DMA_Init(&hdma_tx);   
 80006b4:	f000 fcb4 	bl	8001020 <HAL_DMA_Init>
  /* Associate the initialized DMA handle to the UART handle */
  __HAL_LINKDMA(huart, hdmatx, hdma_tx);
  
  /*##-5- Configure the NVIC for DMA #########################################*/   
  /* NVIC configuration for DMA transfer complete interrupt (USARTx_TX) */
  HAL_NVIC_SetPriority(USARTx_DMA_TX_IRQn, 6, 0);
 80006b8:	4632      	mov	r2, r6
  __HAL_LINKDMA(huart, hdmatx, hdma_tx);
 80006ba:	637c      	str	r4, [r7, #52]	; 0x34
  HAL_NVIC_SetPriority(USARTx_DMA_TX_IRQn, 6, 0);
 80006bc:	2106      	movs	r1, #6
 80006be:	200e      	movs	r0, #14
  __HAL_LINKDMA(huart, hdmatx, hdma_tx);
 80006c0:	63a7      	str	r7, [r4, #56]	; 0x38
  HAL_NVIC_SetPriority(USARTx_DMA_TX_IRQn, 6, 0);
 80006c2:	f000 fc31 	bl	8000f28 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(USARTx_DMA_TX_IRQn);
 80006c6:	200e      	movs	r0, #14
 80006c8:	f000 fc60 	bl	8000f8c <HAL_NVIC_EnableIRQ>
  
  /*##-6- Enable TIM peripherals Clock #######################################*/
  TIMx_CLK_ENABLE();
 80006cc:	9604      	str	r6, [sp, #16]
 80006ce:	6c2b      	ldr	r3, [r5, #64]	; 0x40
 80006d0:	f043 0302 	orr.w	r3, r3, #2
 80006d4:	642b      	str	r3, [r5, #64]	; 0x40
 80006d6:	6c2b      	ldr	r3, [r5, #64]	; 0x40
 80006d8:	f003 0302 	and.w	r3, r3, #2
 80006dc:	9304      	str	r3, [sp, #16]
  
  /*##-7- Configure the NVIC for TIMx ########################################*/
  /* Set Interrupt Group Priority */ 
  HAL_NVIC_SetPriority(TIMx_IRQn, 6, 0);
 80006de:	4632      	mov	r2, r6
 80006e0:	2106      	movs	r1, #6
 80006e2:	201d      	movs	r0, #29
  TIMx_CLK_ENABLE();
 80006e4:	9b04      	ldr	r3, [sp, #16]
  HAL_NVIC_SetPriority(TIMx_IRQn, 6, 0);
 80006e6:	f000 fc1f 	bl	8000f28 <HAL_NVIC_SetPriority>
  
  /* Enable the TIMx global Interrupt */
  HAL_NVIC_EnableIRQ(TIMx_IRQn);
 80006ea:	201d      	movs	r0, #29
 80006ec:	f000 fc4e 	bl	8000f8c <HAL_NVIC_EnableIRQ>
}
 80006f0:	b00a      	add	sp, #40	; 0x28
 80006f2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80006f6:	bf00      	nop
 80006f8:	40023800 	.word	0x40023800
 80006fc:	40020800 	.word	0x40020800
 8000700:	20000448 	.word	0x20000448
 8000704:	40026058 	.word	0x40026058

08000708 <HAL_UART_MspDeInit>:
  *          - Revert GPIO, and NVIC configuration to their default state
  * @param huart: UART handle pointer
  * @retval None
  */
void HAL_UART_MspDeInit(UART_HandleTypeDef *huart)
{
 8000708:	b510      	push	{r4, lr}
  /*##-1- Reset peripherals ##################################################*/
  USARTx_FORCE_RESET();
 800070a:	4c0f      	ldr	r4, [pc, #60]	; (8000748 <HAL_UART_MspDeInit+0x40>)
  USARTx_RELEASE_RESET();

  /*##-2- Disable peripherals and GPIO Clocks #################################*/
  /* Configure UART Tx as alternate function  */
  HAL_GPIO_DeInit(USARTx_TX_GPIO_PORT, USARTx_TX_PIN);
 800070c:	480f      	ldr	r0, [pc, #60]	; (800074c <HAL_UART_MspDeInit+0x44>)
  USARTx_FORCE_RESET();
 800070e:	6a23      	ldr	r3, [r4, #32]
 8000710:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
 8000714:	6223      	str	r3, [r4, #32]
  USARTx_RELEASE_RESET();
 8000716:	6a23      	ldr	r3, [r4, #32]
 8000718:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
 800071c:	6223      	str	r3, [r4, #32]
  HAL_GPIO_DeInit(USARTx_TX_GPIO_PORT, USARTx_TX_PIN);
 800071e:	f44f 6180 	mov.w	r1, #1024	; 0x400
 8000722:	f000 ff1f 	bl	8001564 <HAL_GPIO_DeInit>
  /* Configure UART Rx as alternate function  */
  HAL_GPIO_DeInit(USARTx_RX_GPIO_PORT, USARTx_RX_PIN);
 8000726:	4809      	ldr	r0, [pc, #36]	; (800074c <HAL_UART_MspDeInit+0x44>)
 8000728:	f44f 6100 	mov.w	r1, #2048	; 0x800
 800072c:	f000 ff1a 	bl	8001564 <HAL_GPIO_DeInit>
  
  /*##-3- Disable the NVIC for UART ##########################################*/
  HAL_NVIC_DisableIRQ(USARTx_IRQn);
 8000730:	2027      	movs	r0, #39	; 0x27
 8000732:	f000 fc39 	bl	8000fa8 <HAL_NVIC_DisableIRQ>
  
  /*##-4- Reset TIM peripheral ###############################################*/
  TIMx_FORCE_RESET();
 8000736:	6a23      	ldr	r3, [r4, #32]
 8000738:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
 800073c:	6223      	str	r3, [r4, #32]
  TIMx_RELEASE_RESET();
 800073e:	6a23      	ldr	r3, [r4, #32]
 8000740:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
 8000744:	6223      	str	r3, [r4, #32]
}
 8000746:	bd10      	pop	{r4, pc}
 8000748:	40023800 	.word	0x40023800
 800074c:	40020800 	.word	0x40020800

08000750 <NMI_Handler>:
  * @param  None
  * @retval None
  */
void NMI_Handler(void)
{
}
 8000750:	4770      	bx	lr

08000752 <HardFault_Handler>:
  * @retval None
  */
void HardFault_Handler(void)
{
  /* Go to infinite loop when Hard Fault exception occurs */
  while (1)
 8000752:	e7fe      	b.n	8000752 <HardFault_Handler>

08000754 <MemManage_Handler>:
  * @retval None
  */
void MemManage_Handler(void)
{
  /* Go to infinite loop when Memory Manage exception occurs */
  while (1)
 8000754:	e7fe      	b.n	8000754 <MemManage_Handler>

08000756 <BusFault_Handler>:
  * @retval None
  */
void BusFault_Handler(void)
{
  /* Go to infinite loop when Bus Fault exception occurs */
  while (1)
 8000756:	e7fe      	b.n	8000756 <BusFault_Handler>

08000758 <UsageFault_Handler>:
  * @retval None
  */
void UsageFault_Handler(void)
{
  /* Go to infinite loop when Usage Fault exception occurs */
  while (1)
 8000758:	e7fe      	b.n	8000758 <UsageFault_Handler>

0800075a <SVC_Handler>:
 800075a:	4770      	bx	lr

0800075c <DebugMon_Handler>:
 800075c:	4770      	bx	lr

0800075e <PendSV_Handler>:
 800075e:	4770      	bx	lr

08000760 <SysTick_Handler>:
  * @param  None
  * @retval None
  */
void SysTick_Handler(void)
{
  HAL_IncTick(); 
 8000760:	f000 bba4 	b.w	8000eac <HAL_IncTick>

08000764 <OTG_FS_IRQHandler>:
void OTG_FS_IRQHandler(void)
#else
void OTG_HS_IRQHandler(void)
#endif
{
  HAL_PCD_IRQHandler(&hpcd);
 8000764:	4801      	ldr	r0, [pc, #4]	; (800076c <OTG_FS_IRQHandler+0x8>)
 8000766:	f001 b97d 	b.w	8001a64 <HAL_PCD_IRQHandler>
 800076a:	bf00      	nop
 800076c:	20001540 	.word	0x20001540

08000770 <DMA1_Stream3_IRQHandler>:
  * @param  None
  * @retval None
  */
void USARTx_DMA_TX_IRQHandler(void)
{
  HAL_DMA_IRQHandler(UartHandle.hdmatx);
 8000770:	4b01      	ldr	r3, [pc, #4]	; (8000778 <DMA1_Stream3_IRQHandler+0x8>)
 8000772:	6b58      	ldr	r0, [r3, #52]	; 0x34
 8000774:	f000 bd5e 	b.w	8001234 <HAL_DMA_IRQHandler>
 8000778:	200004a8 	.word	0x200004a8

0800077c <USART3_IRQHandler>:
  * @param  None
  * @retval None
  */
void USARTx_IRQHandler(void)
{
  HAL_UART_IRQHandler(&UartHandle);
 800077c:	4801      	ldr	r0, [pc, #4]	; (8000784 <USART3_IRQHandler+0x8>)
 800077e:	f002 bac1 	b.w	8002d04 <HAL_UART_IRQHandler>
 8000782:	bf00      	nop
 8000784:	200004a8 	.word	0x200004a8

08000788 <TIM3_IRQHandler>:
  * @param  None
  * @retval None
  */
void TIMx_IRQHandler(void)
{
  HAL_TIM_IRQHandler(&TimHandle);
 8000788:	4801      	ldr	r0, [pc, #4]	; (8000790 <TIM3_IRQHandler+0x8>)
 800078a:	f001 bfb3 	b.w	80026f4 <HAL_TIM_IRQHandler>
 800078e:	bf00      	nop
 8000790:	20000cf0 	.word	0x20000cf0

08000794 <CDC_Itf_TransmitCplt>:
  * @retval Result of the operation: USBD_OK if all operations are OK else USBD_FAIL
  */
static int8_t CDC_Itf_TransmitCplt(uint8_t *Buf, uint32_t *Len, uint8_t epnum)
{
  return (0);
}
 8000794:	2000      	movs	r0, #0
 8000796:	4770      	bx	lr

08000798 <CDC_Itf_Receive>:
{
 8000798:	b508      	push	{r3, lr}
  HAL_UART_Transmit_DMA(&UartHandle, Buf, *Len);
 800079a:	880a      	ldrh	r2, [r1, #0]
 800079c:	4601      	mov	r1, r0
 800079e:	4802      	ldr	r0, [pc, #8]	; (80007a8 <CDC_Itf_Receive+0x10>)
 80007a0:	f002 f9b2 	bl	8002b08 <HAL_UART_Transmit_DMA>
}
 80007a4:	2000      	movs	r0, #0
 80007a6:	bd08      	pop	{r3, pc}
 80007a8:	200004a8 	.word	0x200004a8

080007ac <CDC_Itf_DeInit>:
{
 80007ac:	b508      	push	{r3, lr}
  if(HAL_UART_DeInit(&UartHandle) != HAL_OK)
 80007ae:	4802      	ldr	r0, [pc, #8]	; (80007b8 <CDC_Itf_DeInit+0xc>)
 80007b0:	f002 f990 	bl	8002ad4 <HAL_UART_DeInit>
}
 80007b4:	2000      	movs	r0, #0
 80007b6:	bd08      	pop	{r3, pc}
 80007b8:	200004a8 	.word	0x200004a8

080007bc <CDC_Itf_Control>:
  switch (cmd)
 80007bc:	2820      	cmp	r0, #32
{ 
 80007be:	b538      	push	{r3, r4, r5, lr}
  switch (cmd)
 80007c0:	d003      	beq.n	80007ca <CDC_Itf_Control+0xe>
 80007c2:	2821      	cmp	r0, #33	; 0x21
 80007c4:	d03c      	beq.n	8000840 <CDC_Itf_Control+0x84>
}
 80007c6:	2000      	movs	r0, #0
 80007c8:	bd38      	pop	{r3, r4, r5, pc}
    LineCoding.bitrate    = (uint32_t)(pbuf[0] | (pbuf[1] << 8) |\
 80007ca:	4d26      	ldr	r5, [pc, #152]	; (8000864 <CDC_Itf_Control+0xa8>)
 80007cc:	680b      	ldr	r3, [r1, #0]
  * @retval None
  * @note   When a configuration is not supported, a default value is used.
  */
static void ComPort_Config(void)
{
  if(HAL_UART_DeInit(&UartHandle) != HAL_OK)
 80007ce:	4c26      	ldr	r4, [pc, #152]	; (8000868 <CDC_Itf_Control+0xac>)
    LineCoding.bitrate    = (uint32_t)(pbuf[0] | (pbuf[1] << 8) |\
 80007d0:	602b      	str	r3, [r5, #0]
    LineCoding.format     = pbuf[4];
 80007d2:	790b      	ldrb	r3, [r1, #4]
 80007d4:	712b      	strb	r3, [r5, #4]
    LineCoding.paritytype = pbuf[5];
 80007d6:	794b      	ldrb	r3, [r1, #5]
 80007d8:	716b      	strb	r3, [r5, #5]
  if(HAL_UART_DeInit(&UartHandle) != HAL_OK)
 80007da:	4620      	mov	r0, r4
    LineCoding.datatype   = pbuf[6];
 80007dc:	798b      	ldrb	r3, [r1, #6]
 80007de:	71ab      	strb	r3, [r5, #6]
  if(HAL_UART_DeInit(&UartHandle) != HAL_OK)
 80007e0:	f002 f978 	bl	8002ad4 <HAL_UART_DeInit>
    /* Initialization Error */
    Error_Handler();
  }
  
  /* set the Stop bit */
  switch (LineCoding.format)
 80007e4:	792b      	ldrb	r3, [r5, #4]
 80007e6:	1e99      	subs	r1, r3, #2
 80007e8:	424b      	negs	r3, r1
 80007ea:	414b      	adcs	r3, r1
 80007ec:	035b      	lsls	r3, r3, #13
  {
  case 0:
    UartHandle.Init.StopBits = UART_STOPBITS_1;
 80007ee:	60e3      	str	r3, [r4, #12]
    UartHandle.Init.StopBits = UART_STOPBITS_1;
    break;
  }
  
  /* set the parity bit*/
  switch (LineCoding.paritytype)
 80007f0:	796b      	ldrb	r3, [r5, #5]
 80007f2:	2b01      	cmp	r3, #1
 80007f4:	d01f      	beq.n	8000836 <CDC_Itf_Control+0x7a>
 80007f6:	1e9a      	subs	r2, r3, #2
 80007f8:	4253      	negs	r3, r2
 80007fa:	4153      	adcs	r3, r2
 80007fc:	029b      	lsls	r3, r3, #10
    UartHandle.Init.Parity = UART_PARITY_NONE;
    break;
  }
  
  /*set the data type : only 8bits and 9bits is supported */
  switch (LineCoding.datatype)
 80007fe:	79aa      	ldrb	r2, [r5, #6]
    UartHandle.Init.Parity = UART_PARITY_NONE;
 8000800:	6123      	str	r3, [r4, #16]
  switch (LineCoding.datatype)
 8000802:	2a08      	cmp	r2, #8
 8000804:	d11a      	bne.n	800083c <CDC_Itf_Control+0x80>
  case 0x07:
    /* With this configuration a parity (Even or Odd) must be set */
    UartHandle.Init.WordLength = UART_WORDLENGTH_8B;
    break;
  case 0x08:
    if(UartHandle.Init.Parity == UART_PARITY_NONE)
 8000806:	3b00      	subs	r3, #0
 8000808:	bf18      	it	ne
 800080a:	2301      	movne	r3, #1
 800080c:	031b      	lsls	r3, r3, #12
    UartHandle.Init.WordLength = UART_WORDLENGTH_8B;
 800080e:	60a3      	str	r3, [r4, #8]
  default :
    UartHandle.Init.WordLength = UART_WORDLENGTH_8B;
    break;
  }
  
  UartHandle.Init.BaudRate     = LineCoding.bitrate;
 8000810:	682b      	ldr	r3, [r5, #0]
 8000812:	6063      	str	r3, [r4, #4]
  UartHandle.Init.HwFlowCtl    = UART_HWCONTROL_NONE;
  UartHandle.Init.Mode         = UART_MODE_TX_RX;
 8000814:	220c      	movs	r2, #12
 8000816:	2300      	movs	r3, #0
  UartHandle.Init.OverSampling = UART_OVERSAMPLING_16;
  
  if(HAL_UART_Init(&UartHandle) != HAL_OK)
 8000818:	4813      	ldr	r0, [pc, #76]	; (8000868 <CDC_Itf_Control+0xac>)
  UartHandle.Init.OverSampling = UART_OVERSAMPLING_16;
 800081a:	61e3      	str	r3, [r4, #28]
  UartHandle.Init.Mode         = UART_MODE_TX_RX;
 800081c:	e9c4 2305 	strd	r2, r3, [r4, #20]
  if(HAL_UART_Init(&UartHandle) != HAL_OK)
 8000820:	f002 f92a 	bl	8002a78 <HAL_UART_Init>
    /* Initialization Error */
    Error_Handler();
  }

  /* Start reception: provide the buffer pointer with offset and the buffer size */
  HAL_UART_Receive_IT(&UartHandle, (uint8_t *)(UserTxBuffer + UserTxBufPtrIn), 1);
 8000824:	4811      	ldr	r0, [pc, #68]	; (800086c <CDC_Itf_Control+0xb0>)
 8000826:	f8d4 1844 	ldr.w	r1, [r4, #2116]	; 0x844
 800082a:	2201      	movs	r2, #1
 800082c:	4401      	add	r1, r0
 800082e:	3844      	subs	r0, #68	; 0x44
 8000830:	f002 fbc9 	bl	8002fc6 <HAL_UART_Receive_IT>
}
 8000834:	e7c7      	b.n	80007c6 <CDC_Itf_Control+0xa>
  switch (LineCoding.paritytype)
 8000836:	f44f 63c0 	mov.w	r3, #1536	; 0x600
 800083a:	e7e0      	b.n	80007fe <CDC_Itf_Control+0x42>
  switch (LineCoding.datatype)
 800083c:	2300      	movs	r3, #0
 800083e:	e7e6      	b.n	800080e <CDC_Itf_Control+0x52>
    pbuf[0] = (uint8_t)(LineCoding.bitrate);
 8000840:	4b08      	ldr	r3, [pc, #32]	; (8000864 <CDC_Itf_Control+0xa8>)
 8000842:	681a      	ldr	r2, [r3, #0]
 8000844:	700a      	strb	r2, [r1, #0]
    pbuf[1] = (uint8_t)(LineCoding.bitrate >> 8);
 8000846:	681a      	ldr	r2, [r3, #0]
 8000848:	0a12      	lsrs	r2, r2, #8
 800084a:	704a      	strb	r2, [r1, #1]
    pbuf[2] = (uint8_t)(LineCoding.bitrate >> 16);
 800084c:	885a      	ldrh	r2, [r3, #2]
 800084e:	708a      	strb	r2, [r1, #2]
    pbuf[3] = (uint8_t)(LineCoding.bitrate >> 24);
 8000850:	78da      	ldrb	r2, [r3, #3]
 8000852:	70ca      	strb	r2, [r1, #3]
    pbuf[4] = LineCoding.format;
 8000854:	791a      	ldrb	r2, [r3, #4]
 8000856:	710a      	strb	r2, [r1, #4]
    pbuf[5] = LineCoding.paritytype;
 8000858:	795a      	ldrb	r2, [r3, #5]
 800085a:	714a      	strb	r2, [r1, #5]
    pbuf[6] = LineCoding.datatype;     
 800085c:	799b      	ldrb	r3, [r3, #6]
 800085e:	718b      	strb	r3, [r1, #6]
    break;
 8000860:	e7b1      	b.n	80007c6 <CDC_Itf_Control+0xa>
 8000862:	bf00      	nop
 8000864:	20000000 	.word	0x20000000
 8000868:	200004a8 	.word	0x200004a8
 800086c:	200004ec 	.word	0x200004ec

08000870 <CDC_Itf_Init>:
{
 8000870:	b570      	push	{r4, r5, r6, lr}
  UartHandle.Init.BaudRate     = 115200;
 8000872:	4a1e      	ldr	r2, [pc, #120]	; (80008ec <CDC_Itf_Init+0x7c>)
  UartHandle.Instance          = USARTx;
 8000874:	4c1e      	ldr	r4, [pc, #120]	; (80008f0 <CDC_Itf_Init+0x80>)
  UartHandle.Init.BaudRate     = 115200;
 8000876:	f44f 33e1 	mov.w	r3, #115200	; 0x1c200
  UartHandle.Init.WordLength   = UART_WORDLENGTH_8B;
 800087a:	2500      	movs	r5, #0
  UartHandle.Init.BaudRate     = 115200;
 800087c:	e9c4 2300 	strd	r2, r3, [r4]
  if(HAL_UART_Init(&UartHandle) != HAL_OK)
 8000880:	4620      	mov	r0, r4
  UartHandle.Init.Mode         = UART_MODE_TX_RX;
 8000882:	230c      	movs	r3, #12
 8000884:	6163      	str	r3, [r4, #20]
  UartHandle.Init.StopBits     = UART_STOPBITS_1;
 8000886:	e9c4 5502 	strd	r5, r5, [r4, #8]
  UartHandle.Init.Parity       = UART_PARITY_NONE;
 800088a:	6125      	str	r5, [r4, #16]
  UartHandle.Init.HwFlowCtl    = UART_HWCONTROL_NONE;
 800088c:	61a5      	str	r5, [r4, #24]
  UartHandle.Init.OverSampling = UART_OVERSAMPLING_16;
 800088e:	61e5      	str	r5, [r4, #28]
  if(HAL_UART_Init(&UartHandle) != HAL_OK)
 8000890:	f002 f8f2 	bl	8002a78 <HAL_UART_Init>
  if(HAL_UART_Receive_IT(&UartHandle, (uint8_t *)UserTxBuffer, 1) != HAL_OK)
 8000894:	f104 0144 	add.w	r1, r4, #68	; 0x44
 8000898:	2201      	movs	r2, #1
 800089a:	4620      	mov	r0, r4
 800089c:	f002 fb93 	bl	8002fc6 <HAL_UART_Receive_IT>
  * @retval None
  */
static void TIM_Config(void)
{  
  /* Set TIMx instance */
  TimHandle.Instance = TIMx;
 80008a0:	4b14      	ldr	r3, [pc, #80]	; (80008f4 <CDC_Itf_Init+0x84>)
 80008a2:	f8c4 3848 	str.w	r3, [r4, #2120]	; 0x848
  TimHandle.Init.Period = (CDC_POLLING_INTERVAL*1000) - 1;
  TimHandle.Init.Prescaler = 84-1;
  TimHandle.Init.ClockDivision = 0;
  TimHandle.Init.CounterMode = TIM_COUNTERMODE_UP;
  TimHandle.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
  if(HAL_TIM_Base_Init(&TimHandle) != HAL_OK)
 80008a6:	f604 0648 	addw	r6, r4, #2120	; 0x848
  TimHandle.Init.Period = (CDC_POLLING_INTERVAL*1000) - 1;
 80008aa:	f241 3387 	movw	r3, #4999	; 0x1387
 80008ae:	f8c4 3854 	str.w	r3, [r4, #2132]	; 0x854
  if(HAL_TIM_Base_Init(&TimHandle) != HAL_OK)
 80008b2:	4630      	mov	r0, r6
  TimHandle.Init.Prescaler = 84-1;
 80008b4:	2353      	movs	r3, #83	; 0x53
 80008b6:	f8c4 384c 	str.w	r3, [r4, #2124]	; 0x84c
  TimHandle.Init.ClockDivision = 0;
 80008ba:	f8c4 5858 	str.w	r5, [r4, #2136]	; 0x858
  TimHandle.Init.CounterMode = TIM_COUNTERMODE_UP;
 80008be:	f8c4 5850 	str.w	r5, [r4, #2128]	; 0x850
  TimHandle.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
 80008c2:	f8c4 5860 	str.w	r5, [r4, #2144]	; 0x860
  if(HAL_TIM_Base_Init(&TimHandle) != HAL_OK)
 80008c6:	f002 f81d 	bl	8002904 <HAL_TIM_Base_Init>
  if(HAL_TIM_Base_Start_IT(&TimHandle) != HAL_OK)
 80008ca:	4630      	mov	r0, r6
  USBD_CDC_SetTxBuffer(&USBD_Device, UserTxBuffer, 0);
 80008cc:	4e0a      	ldr	r6, [pc, #40]	; (80008f8 <CDC_Itf_Init+0x88>)
  if(HAL_TIM_Base_Start_IT(&TimHandle) != HAL_OK)
 80008ce:	f001 fed3 	bl	8002678 <HAL_TIM_Base_Start_IT>
  USBD_CDC_SetTxBuffer(&USBD_Device, UserTxBuffer, 0);
 80008d2:	462a      	mov	r2, r5
 80008d4:	f104 0144 	add.w	r1, r4, #68	; 0x44
 80008d8:	4630      	mov	r0, r6
 80008da:	f003 faed 	bl	8003eb8 <USBD_CDC_SetTxBuffer>
  USBD_CDC_SetRxBuffer(&USBD_Device, UserRxBuffer);
 80008de:	f504 6109 	add.w	r1, r4, #2192	; 0x890
 80008e2:	4630      	mov	r0, r6
 80008e4:	f003 faf6 	bl	8003ed4 <USBD_CDC_SetRxBuffer>
}
 80008e8:	4628      	mov	r0, r5
 80008ea:	bd70      	pop	{r4, r5, r6, pc}
 80008ec:	40004800 	.word	0x40004800
 80008f0:	200004a8 	.word	0x200004a8
 80008f4:	40000400 	.word	0x40000400
 80008f8:	2000016c 	.word	0x2000016c

080008fc <HAL_TIM_PeriodElapsedCallback>:
{
 80008fc:	b538      	push	{r3, r4, r5, lr}
  if(UserTxBufPtrOut != UserTxBufPtrIn)
 80008fe:	4a10      	ldr	r2, [pc, #64]	; (8000940 <HAL_TIM_PeriodElapsedCallback+0x44>)
 8000900:	4d10      	ldr	r5, [pc, #64]	; (8000944 <HAL_TIM_PeriodElapsedCallback+0x48>)
 8000902:	f8d2 4844 	ldr.w	r4, [r2, #2116]	; 0x844
 8000906:	f855 3c68 	ldr.w	r3, [r5, #-104]
 800090a:	42a3      	cmp	r3, r4
 800090c:	d016      	beq.n	800093c <HAL_TIM_PeriodElapsedCallback+0x40>
    USBD_CDC_SetTxBuffer(&USBD_Device, (uint8_t*)&UserTxBuffer[buffptr], buffsize);
 800090e:	490e      	ldr	r1, [pc, #56]	; (8000948 <HAL_TIM_PeriodElapsedCallback+0x4c>)
 8000910:	480e      	ldr	r0, [pc, #56]	; (800094c <HAL_TIM_PeriodElapsedCallback+0x50>)
      buffsize = APP_TX_DATA_SIZE - UserTxBufPtrOut;
 8000912:	bf8c      	ite	hi
 8000914:	f5c3 6400 	rsbhi	r4, r3, #2048	; 0x800
      buffsize = UserTxBufPtrIn - UserTxBufPtrOut;
 8000918:	1ae4      	subls	r4, r4, r3
    USBD_CDC_SetTxBuffer(&USBD_Device, (uint8_t*)&UserTxBuffer[buffptr], buffsize);
 800091a:	4622      	mov	r2, r4
 800091c:	4419      	add	r1, r3
 800091e:	f003 facb 	bl	8003eb8 <USBD_CDC_SetTxBuffer>
    if(USBD_CDC_TransmitPacket(&USBD_Device) == USBD_OK)
 8000922:	480a      	ldr	r0, [pc, #40]	; (800094c <HAL_TIM_PeriodElapsedCallback+0x50>)
 8000924:	f003 fae2 	bl	8003eec <USBD_CDC_TransmitPacket>
 8000928:	b940      	cbnz	r0, 800093c <HAL_TIM_PeriodElapsedCallback+0x40>
      UserTxBufPtrOut += buffsize;
 800092a:	f855 3c68 	ldr.w	r3, [r5, #-104]
 800092e:	441c      	add	r4, r3
 8000930:	f5b4 6f00 	cmp.w	r4, #2048	; 0x800
 8000934:	bf18      	it	ne
 8000936:	4620      	movne	r0, r4
 8000938:	f845 0c68 	str.w	r0, [r5, #-104]
}
 800093c:	bd38      	pop	{r3, r4, r5, pc}
 800093e:	bf00      	nop
 8000940:	200004a8 	.word	0x200004a8
 8000944:	200015a0 	.word	0x200015a0
 8000948:	200004ec 	.word	0x200004ec
 800094c:	2000016c 	.word	0x2000016c

08000950 <HAL_UART_RxCpltCallback>:
  UserTxBufPtrIn++;
 8000950:	4b08      	ldr	r3, [pc, #32]	; (8000974 <HAL_UART_RxCpltCallback+0x24>)
  HAL_UART_Receive_IT(huart, (uint8_t *)(UserTxBuffer + UserTxBufPtrIn), 1);
 8000952:	4909      	ldr	r1, [pc, #36]	; (8000978 <HAL_UART_RxCpltCallback+0x28>)
  UserTxBufPtrIn++;
 8000954:	f8d3 2844 	ldr.w	r2, [r3, #2116]	; 0x844
 8000958:	3201      	adds	r2, #1
  if(UserTxBufPtrIn == APP_RX_DATA_SIZE)
 800095a:	f5b2 6f00 	cmp.w	r2, #2048	; 0x800
    UserTxBufPtrIn = 0;
 800095e:	bf08      	it	eq
 8000960:	2200      	moveq	r2, #0
 8000962:	f8c3 2844 	str.w	r2, [r3, #2116]	; 0x844
  HAL_UART_Receive_IT(huart, (uint8_t *)(UserTxBuffer + UserTxBufPtrIn), 1);
 8000966:	f8d3 3844 	ldr.w	r3, [r3, #2116]	; 0x844
 800096a:	2201      	movs	r2, #1
 800096c:	4419      	add	r1, r3
 800096e:	f002 bb2a 	b.w	8002fc6 <HAL_UART_Receive_IT>
 8000972:	bf00      	nop
 8000974:	200004a8 	.word	0x200004a8
 8000978:	200004ec 	.word	0x200004ec

0800097c <HAL_UART_TxCpltCallback>:
  USBD_CDC_ReceivePacket(&USBD_Device);
 800097c:	4801      	ldr	r0, [pc, #4]	; (8000984 <HAL_UART_TxCpltCallback+0x8>)
 800097e:	f003 bad0 	b.w	8003f22 <USBD_CDC_ReceivePacket>
 8000982:	bf00      	nop
 8000984:	2000016c 	.word	0x2000016c

08000988 <HAL_UART_ErrorCallback>:
  */
void HAL_UART_ErrorCallback(UART_HandleTypeDef *UartHandle)
{
  /* Transfer error occurred in reception and/or transmission process */
  Error_Handler();
}
 8000988:	4770      	bx	lr
	...

0800098c <HAL_PCD_MspInit>:
  * @brief  Initializes the PCD MSP.
  * @param  hpcd: PCD handle
  * @retval None
  */
void HAL_PCD_MspInit(PCD_HandleTypeDef *hpcd)
{
 800098c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  GPIO_InitTypeDef  GPIO_InitStruct;
  
  if(hpcd->Instance == USB_OTG_FS)
 8000990:	6803      	ldr	r3, [r0, #0]
 8000992:	f1b3 4fa0 	cmp.w	r3, #1342177280	; 0x50000000
{
 8000996:	b08e      	sub	sp, #56	; 0x38
  if(hpcd->Instance == USB_OTG_FS)
 8000998:	d147      	bne.n	8000a2a <HAL_PCD_MspInit+0x9e>
  {
    /* Configure USB FS GPIOs */
    __HAL_RCC_GPIOA_CLK_ENABLE();
 800099a:	4c6c      	ldr	r4, [pc, #432]	; (8000b4c <HAL_PCD_MspInit+0x1c0>)
    GPIO_InitStruct.Pin = (GPIO_PIN_11 | GPIO_PIN_12);
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF10_OTG_FS;
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct); 
 800099c:	486c      	ldr	r0, [pc, #432]	; (8000b50 <HAL_PCD_MspInit+0x1c4>)
    __HAL_RCC_GPIOA_CLK_ENABLE();
 800099e:	2500      	movs	r5, #0
 80009a0:	9500      	str	r5, [sp, #0]
 80009a2:	6b23      	ldr	r3, [r4, #48]	; 0x30
 80009a4:	f043 0301 	orr.w	r3, r3, #1
 80009a8:	6323      	str	r3, [r4, #48]	; 0x30
 80009aa:	6b23      	ldr	r3, [r4, #48]	; 0x30
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 80009ac:	950b      	str	r5, [sp, #44]	; 0x2c
    __HAL_RCC_GPIOA_CLK_ENABLE();
 80009ae:	f003 0301 	and.w	r3, r3, #1
 80009b2:	9300      	str	r3, [sp, #0]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 80009b4:	f44f 52c0 	mov.w	r2, #6144	; 0x1800
    __HAL_RCC_GPIOA_CLK_ENABLE();
 80009b8:	9b00      	ldr	r3, [sp, #0]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 80009ba:	2302      	movs	r3, #2
 80009bc:	e9cd 2309 	strd	r2, r3, [sp, #36]	; 0x24
    GPIO_InitStruct.Alternate = GPIO_AF10_OTG_FS;
 80009c0:	260a      	movs	r6, #10
 80009c2:	2303      	movs	r3, #3
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct); 
 80009c4:	a909      	add	r1, sp, #36	; 0x24
    GPIO_InitStruct.Alternate = GPIO_AF10_OTG_FS;
 80009c6:	e9cd 360c 	strd	r3, r6, [sp, #48]	; 0x30
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct); 
 80009ca:	f000 fcf1 	bl	80013b0 <HAL_GPIO_Init>
    
	/* Configure VBUS Pin */
    GPIO_InitStruct.Pin = GPIO_PIN_9;
 80009ce:	f44f 7300 	mov.w	r3, #512	; 0x200
    GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 80009d2:	485f      	ldr	r0, [pc, #380]	; (8000b50 <HAL_PCD_MspInit+0x1c4>)
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 80009d4:	950b      	str	r5, [sp, #44]	; 0x2c
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 80009d6:	a909      	add	r1, sp, #36	; 0x24
    GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
 80009d8:	e9cd 3509 	strd	r3, r5, [sp, #36]	; 0x24
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 80009dc:	f000 fce8 	bl	80013b0 <HAL_GPIO_Init>
	
    /* Configure ID pin */
    GPIO_InitStruct.Pin = GPIO_PIN_10;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_OD;
 80009e0:	f44f 6180 	mov.w	r1, #1024	; 0x400
 80009e4:	2312      	movs	r3, #18
 80009e6:	e9cd 1309 	strd	r1, r3, [sp, #36]	; 0x24
    GPIO_InitStruct.Pull = GPIO_PULLUP;
    GPIO_InitStruct.Alternate = GPIO_AF10_OTG_FS;
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct); 
 80009ea:	4859      	ldr	r0, [pc, #356]	; (8000b50 <HAL_PCD_MspInit+0x1c4>)
    GPIO_InitStruct.Alternate = GPIO_AF10_OTG_FS;
 80009ec:	960d      	str	r6, [sp, #52]	; 0x34
    GPIO_InitStruct.Pull = GPIO_PULLUP;
 80009ee:	2301      	movs	r3, #1
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct); 
 80009f0:	a909      	add	r1, sp, #36	; 0x24
    GPIO_InitStruct.Pull = GPIO_PULLUP;
 80009f2:	930b      	str	r3, [sp, #44]	; 0x2c
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct); 
 80009f4:	f000 fcdc 	bl	80013b0 <HAL_GPIO_Init>

    /* Enable USB FS Clocks */ 
    __HAL_RCC_USB_OTG_FS_CLK_ENABLE();
 80009f8:	6b63      	ldr	r3, [r4, #52]	; 0x34
 80009fa:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 80009fe:	6363      	str	r3, [r4, #52]	; 0x34
 8000a00:	9501      	str	r5, [sp, #4]
 8000a02:	6c63      	ldr	r3, [r4, #68]	; 0x44
 8000a04:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 8000a08:	6463      	str	r3, [r4, #68]	; 0x44
 8000a0a:	6c63      	ldr	r3, [r4, #68]	; 0x44
 8000a0c:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 8000a10:	9301      	str	r3, [sp, #4]
    
    /* Set USBFS Interrupt priority */
    HAL_NVIC_SetPriority(OTG_FS_IRQn, 6, 0);
 8000a12:	2043      	movs	r0, #67	; 0x43
 8000a14:	462a      	mov	r2, r5
 8000a16:	2106      	movs	r1, #6
    __HAL_RCC_USB_OTG_FS_CLK_ENABLE();
 8000a18:	9b01      	ldr	r3, [sp, #4]
    HAL_NVIC_SetPriority(OTG_FS_IRQn, 6, 0);
 8000a1a:	f000 fa85 	bl	8000f28 <HAL_NVIC_SetPriority>
    
    /* Enable USBFS Interrupt */
    HAL_NVIC_EnableIRQ(OTG_FS_IRQn);
 8000a1e:	2043      	movs	r0, #67	; 0x43
    
    /* Set USBHS Interrupt to the lowest priority */
    HAL_NVIC_SetPriority(OTG_HS_IRQn, 6, 0);
    
    /* Enable USBHS Interrupt */
    HAL_NVIC_EnableIRQ(OTG_HS_IRQn);
 8000a20:	f000 fab4 	bl	8000f8c <HAL_NVIC_EnableIRQ>
  }   
}
 8000a24:	b00e      	add	sp, #56	; 0x38
 8000a26:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  else if(hpcd->Instance == USB_OTG_HS)
 8000a2a:	4a4a      	ldr	r2, [pc, #296]	; (8000b54 <HAL_PCD_MspInit+0x1c8>)
 8000a2c:	4293      	cmp	r3, r2
 8000a2e:	d1f9      	bne.n	8000a24 <HAL_PCD_MspInit+0x98>
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8000a30:	4c46      	ldr	r4, [pc, #280]	; (8000b4c <HAL_PCD_MspInit+0x1c0>)
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct); 
 8000a32:	4847      	ldr	r0, [pc, #284]	; (8000b50 <HAL_PCD_MspInit+0x1c4>)
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8000a34:	2500      	movs	r5, #0
 8000a36:	9502      	str	r5, [sp, #8]
 8000a38:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8000a3a:	f043 0301 	orr.w	r3, r3, #1
 8000a3e:	6323      	str	r3, [r4, #48]	; 0x30
 8000a40:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8000a42:	f003 0301 	and.w	r3, r3, #1
 8000a46:	9302      	str	r3, [sp, #8]
 8000a48:	9b02      	ldr	r3, [sp, #8]
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8000a4a:	9503      	str	r5, [sp, #12]
 8000a4c:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8000a4e:	f043 0302 	orr.w	r3, r3, #2
 8000a52:	6323      	str	r3, [r4, #48]	; 0x30
 8000a54:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8000a56:	f003 0302 	and.w	r3, r3, #2
 8000a5a:	9303      	str	r3, [sp, #12]
 8000a5c:	9b03      	ldr	r3, [sp, #12]
    __HAL_RCC_GPIOC_CLK_ENABLE();
 8000a5e:	9504      	str	r5, [sp, #16]
 8000a60:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8000a62:	f043 0304 	orr.w	r3, r3, #4
 8000a66:	6323      	str	r3, [r4, #48]	; 0x30
 8000a68:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8000a6a:	f003 0304 	and.w	r3, r3, #4
 8000a6e:	9304      	str	r3, [sp, #16]
 8000a70:	9b04      	ldr	r3, [sp, #16]
    __HAL_RCC_GPIOH_CLK_ENABLE();
 8000a72:	9505      	str	r5, [sp, #20]
 8000a74:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8000a76:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8000a7a:	6323      	str	r3, [r4, #48]	; 0x30
 8000a7c:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8000a7e:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8000a82:	9305      	str	r3, [sp, #20]
 8000a84:	9b05      	ldr	r3, [sp, #20]
    __HAL_RCC_GPIOI_CLK_ENABLE();
 8000a86:	9506      	str	r5, [sp, #24]
 8000a88:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8000a8a:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8000a8e:	6323      	str	r3, [r4, #48]	; 0x30
 8000a90:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8000a92:	f403 7380 	and.w	r3, r3, #256	; 0x100
 8000a96:	9306      	str	r3, [sp, #24]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8000a98:	2702      	movs	r7, #2
    GPIO_InitStruct.Alternate = GPIO_AF10_OTG_HS;
 8000a9a:	260a      	movs	r6, #10
    __HAL_RCC_GPIOI_CLK_ENABLE();
 8000a9c:	9b06      	ldr	r3, [sp, #24]
    GPIO_InitStruct.Alternate = GPIO_AF10_OTG_HS;
 8000a9e:	f04f 0803 	mov.w	r8, #3
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8000aa2:	2320      	movs	r3, #32
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct); 
 8000aa4:	a909      	add	r1, sp, #36	; 0x24
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8000aa6:	e9cd 3709 	strd	r3, r7, [sp, #36]	; 0x24
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8000aaa:	950b      	str	r5, [sp, #44]	; 0x2c
    GPIO_InitStruct.Alternate = GPIO_AF10_OTG_HS;
 8000aac:	e9cd 860c 	strd	r8, r6, [sp, #48]	; 0x30
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct); 
 8000ab0:	f000 fc7e 	bl	80013b0 <HAL_GPIO_Init>
    GPIO_InitStruct.Pin = GPIO_PIN_3;
 8000ab4:	2308      	movs	r3, #8
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct); 
 8000ab6:	4826      	ldr	r0, [pc, #152]	; (8000b50 <HAL_PCD_MspInit+0x1c4>)
    GPIO_InitStruct.Alternate = GPIO_AF10_OTG_HS;
 8000ab8:	960d      	str	r6, [sp, #52]	; 0x34
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct); 
 8000aba:	a909      	add	r1, sp, #36	; 0x24
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8000abc:	e9cd 3709 	strd	r3, r7, [sp, #36]	; 0x24
    GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
 8000ac0:	e9cd 580b 	strd	r5, r8, [sp, #44]	; 0x2c
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct); 
 8000ac4:	f000 fc74 	bl	80013b0 <HAL_GPIO_Init>
    GPIO_InitStruct.Pin = GPIO_PIN_0  | GPIO_PIN_1  | GPIO_PIN_5 |\
 8000ac8:	f643 4323 	movw	r3, #15395	; 0x3c23
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct); 
 8000acc:	4822      	ldr	r0, [pc, #136]	; (8000b58 <HAL_PCD_MspInit+0x1cc>)
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8000ace:	950b      	str	r5, [sp, #44]	; 0x2c
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct); 
 8000ad0:	a909      	add	r1, sp, #36	; 0x24
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8000ad2:	e9cd 3709 	strd	r3, r7, [sp, #36]	; 0x24
    GPIO_InitStruct.Alternate = GPIO_AF10_OTG_HS;
 8000ad6:	960d      	str	r6, [sp, #52]	; 0x34
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct); 
 8000ad8:	f000 fc6a 	bl	80013b0 <HAL_GPIO_Init>
    GPIO_InitStruct.Pin = GPIO_PIN_0;
 8000adc:	2301      	movs	r3, #1
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct); 
 8000ade:	481f      	ldr	r0, [pc, #124]	; (8000b5c <HAL_PCD_MspInit+0x1d0>)
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8000ae0:	950b      	str	r5, [sp, #44]	; 0x2c
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct); 
 8000ae2:	a909      	add	r1, sp, #36	; 0x24
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8000ae4:	e9cd 3709 	strd	r3, r7, [sp, #36]	; 0x24
    GPIO_InitStruct.Alternate = GPIO_AF10_OTG_HS;
 8000ae8:	960d      	str	r6, [sp, #52]	; 0x34
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct); 
 8000aea:	f000 fc61 	bl	80013b0 <HAL_GPIO_Init>
    GPIO_InitStruct.Pin = GPIO_PIN_4;
 8000aee:	2310      	movs	r3, #16
    HAL_GPIO_Init(GPIOH, &GPIO_InitStruct);   
 8000af0:	481b      	ldr	r0, [pc, #108]	; (8000b60 <HAL_PCD_MspInit+0x1d4>)
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8000af2:	950b      	str	r5, [sp, #44]	; 0x2c
    HAL_GPIO_Init(GPIOH, &GPIO_InitStruct);   
 8000af4:	a909      	add	r1, sp, #36	; 0x24
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8000af6:	e9cd 3709 	strd	r3, r7, [sp, #36]	; 0x24
    GPIO_InitStruct.Alternate = GPIO_AF10_OTG_HS;
 8000afa:	960d      	str	r6, [sp, #52]	; 0x34
    HAL_GPIO_Init(GPIOH, &GPIO_InitStruct);   
 8000afc:	f000 fc58 	bl	80013b0 <HAL_GPIO_Init>
    GPIO_InitStruct.Pin = GPIO_PIN_11;
 8000b00:	f44f 6300 	mov.w	r3, #2048	; 0x800
    HAL_GPIO_Init(GPIOI, &GPIO_InitStruct);
 8000b04:	4817      	ldr	r0, [pc, #92]	; (8000b64 <HAL_PCD_MspInit+0x1d8>)
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8000b06:	950b      	str	r5, [sp, #44]	; 0x2c
    HAL_GPIO_Init(GPIOI, &GPIO_InitStruct);
 8000b08:	a909      	add	r1, sp, #36	; 0x24
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8000b0a:	e9cd 3709 	strd	r3, r7, [sp, #36]	; 0x24
    GPIO_InitStruct.Alternate = GPIO_AF10_OTG_HS;
 8000b0e:	960d      	str	r6, [sp, #52]	; 0x34
    HAL_GPIO_Init(GPIOI, &GPIO_InitStruct);
 8000b10:	f000 fc4e 	bl	80013b0 <HAL_GPIO_Init>
    __HAL_RCC_USB_OTG_HS_CLK_ENABLE();
 8000b14:	9507      	str	r5, [sp, #28]
 8000b16:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8000b18:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
 8000b1c:	6323      	str	r3, [r4, #48]	; 0x30
 8000b1e:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8000b20:	f003 5300 	and.w	r3, r3, #536870912	; 0x20000000
 8000b24:	9307      	str	r3, [sp, #28]
 8000b26:	9b07      	ldr	r3, [sp, #28]
    __HAL_RCC_USB_OTG_HS_ULPI_CLK_ENABLE();
 8000b28:	9508      	str	r5, [sp, #32]
 8000b2a:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8000b2c:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
 8000b30:	6323      	str	r3, [r4, #48]	; 0x30
 8000b32:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8000b34:	f003 4380 	and.w	r3, r3, #1073741824	; 0x40000000
 8000b38:	9308      	str	r3, [sp, #32]
    HAL_NVIC_SetPriority(OTG_HS_IRQn, 6, 0);
 8000b3a:	204d      	movs	r0, #77	; 0x4d
 8000b3c:	462a      	mov	r2, r5
 8000b3e:	2106      	movs	r1, #6
    __HAL_RCC_USB_OTG_HS_ULPI_CLK_ENABLE();
 8000b40:	9b08      	ldr	r3, [sp, #32]
    HAL_NVIC_SetPriority(OTG_HS_IRQn, 6, 0);
 8000b42:	f000 f9f1 	bl	8000f28 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(OTG_HS_IRQn);
 8000b46:	204d      	movs	r0, #77	; 0x4d
 8000b48:	e76a      	b.n	8000a20 <HAL_PCD_MspInit+0x94>
 8000b4a:	bf00      	nop
 8000b4c:	40023800 	.word	0x40023800
 8000b50:	40020000 	.word	0x40020000
 8000b54:	40040000 	.word	0x40040000
 8000b58:	40020400 	.word	0x40020400
 8000b5c:	40020800 	.word	0x40020800
 8000b60:	40021c00 	.word	0x40021c00
 8000b64:	40022000 	.word	0x40022000

08000b68 <HAL_PCD_SetupStageCallback>:
  * @param  hpcd: PCD handle
  * @retval None
  */
void HAL_PCD_SetupStageCallback(PCD_HandleTypeDef *hpcd)
{
  USBD_LL_SetupStage(hpcd->pData, (uint8_t *)hpcd->Setup);
 8000b68:	f200 41c4 	addw	r1, r0, #1220	; 0x4c4
 8000b6c:	f8d0 0508 	ldr.w	r0, [r0, #1288]	; 0x508
 8000b70:	f003 ba2f 	b.w	8003fd2 <USBD_LL_SetupStage>

08000b74 <HAL_PCD_DataOutStageCallback>:
  * @param  epnum: Endpoint Number
  * @retval None
  */
void HAL_PCD_DataOutStageCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
{
  USBD_LL_DataOutStage(hpcd->pData, epnum, hpcd->OUT_ep[epnum].xfer_buff);
 8000b74:	2324      	movs	r3, #36	; 0x24
 8000b76:	fb03 0301 	mla	r3, r3, r1, r0
 8000b7a:	f8d0 0508 	ldr.w	r0, [r0, #1288]	; 0x508
 8000b7e:	f8d3 228c 	ldr.w	r2, [r3, #652]	; 0x28c
 8000b82:	f003 ba56 	b.w	8004032 <USBD_LL_DataOutStage>

08000b86 <HAL_PCD_DataInStageCallback>:
  * @param  epnum: Endpoint Number
  * @retval None
  */
void HAL_PCD_DataInStageCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
{
  USBD_LL_DataInStage(hpcd->pData, epnum, hpcd->IN_ep[epnum].xfer_buff);
 8000b86:	2324      	movs	r3, #36	; 0x24
 8000b88:	fb03 0301 	mla	r3, r3, r1, r0
 8000b8c:	f8d0 0508 	ldr.w	r0, [r0, #1288]	; 0x508
 8000b90:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8000b92:	f003 ba83 	b.w	800409c <USBD_LL_DataInStage>

08000b96 <HAL_PCD_SOFCallback>:
  * @param  hpcd: PCD handle
  * @retval None
  */
void HAL_PCD_SOFCallback(PCD_HandleTypeDef *hpcd)
{
  USBD_LL_SOF(hpcd->pData);
 8000b96:	f8d0 0508 	ldr.w	r0, [r0, #1288]	; 0x508
 8000b9a:	f003 bb1d 	b.w	80041d8 <USBD_LL_SOF>

08000b9e <HAL_PCD_ResetCallback>:
  * @brief  Reset callback.
  * @param  hpcd: PCD handle
  * @retval None
  */
void HAL_PCD_ResetCallback(PCD_HandleTypeDef *hpcd)
{ 
 8000b9e:	b510      	push	{r4, lr}
  USBD_SpeedTypeDef speed = USBD_SPEED_FULL;

  /* Set USB Current Speed */
  switch(hpcd->Init.speed)
 8000ba0:	68c1      	ldr	r1, [r0, #12]
{ 
 8000ba2:	4604      	mov	r4, r0
	
	default:
    speed = USBD_SPEED_FULL;    
    break;
  }
  USBD_LL_SetSpeed(hpcd->pData, speed);  
 8000ba4:	3900      	subs	r1, #0
 8000ba6:	f8d0 0508 	ldr.w	r0, [r0, #1288]	; 0x508
 8000baa:	bf18      	it	ne
 8000bac:	2101      	movne	r1, #1
 8000bae:	f003 fafb 	bl	80041a8 <USBD_LL_SetSpeed>
  
  /* Reset Device */
  USBD_LL_Reset(hpcd->pData);
 8000bb2:	f8d4 0508 	ldr.w	r0, [r4, #1288]	; 0x508
}
 8000bb6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  USBD_LL_Reset(hpcd->pData);
 8000bba:	f003 bac6 	b.w	800414a <USBD_LL_Reset>

08000bbe <HAL_PCD_SuspendCallback>:
  * @param  hpcd: PCD handle
  * @retval None
  */
void HAL_PCD_SuspendCallback(PCD_HandleTypeDef *hpcd)
{
  USBD_LL_Suspend(hpcd->pData);
 8000bbe:	f8d0 0508 	ldr.w	r0, [r0, #1288]	; 0x508
 8000bc2:	f003 baf4 	b.w	80041ae <USBD_LL_Suspend>

08000bc6 <HAL_PCD_ResumeCallback>:
  * @param  hpcd: PCD handle
  * @retval None
  */
void HAL_PCD_ResumeCallback(PCD_HandleTypeDef *hpcd)
{
  USBD_LL_Resume(hpcd->pData);
 8000bc6:	f8d0 0508 	ldr.w	r0, [r0, #1288]	; 0x508
 8000bca:	f003 bafa 	b.w	80041c2 <USBD_LL_Resume>

08000bce <HAL_PCD_ISOOUTIncompleteCallback>:
  * @param  epnum: Endpoint Number  
  * @retval None
  */
void HAL_PCD_ISOOUTIncompleteCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
{
  USBD_LL_IsoOUTIncomplete(hpcd->pData, epnum);
 8000bce:	f8d0 0508 	ldr.w	r0, [r0, #1288]	; 0x508
 8000bd2:	f003 bb22 	b.w	800421a <USBD_LL_IsoOUTIncomplete>

08000bd6 <HAL_PCD_ISOINIncompleteCallback>:
  * @param  epnum: Endpoint Number  
  * @retval None
  */
void HAL_PCD_ISOINIncompleteCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
{
  USBD_LL_IsoINIncomplete(hpcd->pData, epnum);
 8000bd6:	f8d0 0508 	ldr.w	r0, [r0, #1288]	; 0x508
 8000bda:	f003 bb0a 	b.w	80041f2 <USBD_LL_IsoINIncomplete>

08000bde <HAL_PCD_ConnectCallback>:
  * @param  hpcd: PCD handle
  * @retval None
  */
void HAL_PCD_ConnectCallback(PCD_HandleTypeDef *hpcd)
{
  USBD_LL_DevConnected(hpcd->pData);
 8000bde:	f8d0 0508 	ldr.w	r0, [r0, #1288]	; 0x508
 8000be2:	f003 bb2e 	b.w	8004242 <USBD_LL_DevConnected>

08000be6 <HAL_PCD_DisconnectCallback>:
  * @param  hpcd: PCD handle
  * @retval None
  */
void HAL_PCD_DisconnectCallback(PCD_HandleTypeDef *hpcd)
{
  USBD_LL_DevDisconnected(hpcd->pData);
 8000be6:	f8d0 0508 	ldr.w	r0, [r0, #1288]	; 0x508
 8000bea:	f003 bb2c 	b.w	8004246 <USBD_LL_DevDisconnected>
	...

08000bf0 <USBD_LL_Init>:
  {
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  }
  else
  {
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8000bf0:	4b15      	ldr	r3, [pc, #84]	; (8000c48 <USBD_LL_Init+0x58>)
  * @brief  Initializes the Low Level portion of the Device driver.  
  * @param  pdev: Device handle
  * @retval USBD Status
  */
USBD_StatusTypeDef  USBD_LL_Init (USBD_HandleTypeDef *pdev)
{ 
 8000bf2:	b570      	push	{r4, r5, r6, lr}
  /* Change Systick prioity */
  NVIC_SetPriority (SysTick_IRQn, 0);  
  
#ifdef USE_USB_FS  
  /*Set LL Driver parameters */
  hpcd.Instance = USB_OTG_FS;
 8000bf4:	4c15      	ldr	r4, [pc, #84]	; (8000c4c <USBD_LL_Init+0x5c>)
 8000bf6:	2500      	movs	r5, #0
 8000bf8:	f883 5023 	strb.w	r5, [r3, #35]	; 0x23
  hpcd.Init.dev_endpoints = 4; 
 8000bfc:	f04f 42a0 	mov.w	r2, #1342177280	; 0x50000000
 8000c00:	2304      	movs	r3, #4
 8000c02:	e9c4 2300 	strd	r2, r3, [r4]
  hpcd.Init.phy_itface = PCD_PHY_EMBEDDED; 
  hpcd.Init.Sof_enable = 0;
  hpcd.Init.speed = PCD_SPEED_FULL;
  hpcd.Init.vbus_sensing_enable = 1;
  /* Link The driver to the stack */
  hpcd.pData = pdev;
 8000c06:	f8c4 0508 	str.w	r0, [r4, #1288]	; 0x508
  hpcd.Init.phy_itface = PCD_PHY_EMBEDDED; 
 8000c0a:	2302      	movs	r3, #2
  hpcd.Init.vbus_sensing_enable = 1;
 8000c0c:	2601      	movs	r6, #1
  pdev->pData = &hpcd;
 8000c0e:	f8c0 42c8 	str.w	r4, [r0, #712]	; 0x2c8
  /*Initialize LL Driver */
  HAL_PCD_Init(&hpcd);
 8000c12:	4620      	mov	r0, r4
  hpcd.Init.Sof_enable = 0;
 8000c14:	e9c4 3506 	strd	r3, r5, [r4, #24]
  hpcd.Init.speed = PCD_SPEED_FULL;
 8000c18:	60e3      	str	r3, [r4, #12]
  hpcd.Init.use_dedicated_ep1 = 0;  
 8000c1a:	6325      	str	r5, [r4, #48]	; 0x30
  hpcd.Init.dma_enable = 0;
 8000c1c:	6125      	str	r5, [r4, #16]
  hpcd.Init.low_power_enable = 0;
 8000c1e:	6225      	str	r5, [r4, #32]
  hpcd.Init.vbus_sensing_enable = 1;
 8000c20:	62e6      	str	r6, [r4, #44]	; 0x2c
  HAL_PCD_Init(&hpcd);
 8000c22:	f000 fd33 	bl	800168c <HAL_PCD_Init>
  
  HAL_PCDEx_SetRxFiFo(&hpcd, 0x80);
 8000c26:	2180      	movs	r1, #128	; 0x80
 8000c28:	4620      	mov	r0, r4
 8000c2a:	f001 fa83 	bl	8002134 <HAL_PCDEx_SetRxFiFo>
  HAL_PCDEx_SetTxFiFo(&hpcd, 0, 0x40);
 8000c2e:	4629      	mov	r1, r5
 8000c30:	2240      	movs	r2, #64	; 0x40
 8000c32:	4620      	mov	r0, r4
 8000c34:	f001 fa5e 	bl	80020f4 <HAL_PCDEx_SetTxFiFo>
  HAL_PCDEx_SetTxFiFo(&hpcd, 1, 0x80); 
 8000c38:	2280      	movs	r2, #128	; 0x80
 8000c3a:	4631      	mov	r1, r6
 8000c3c:	4620      	mov	r0, r4
 8000c3e:	f001 fa59 	bl	80020f4 <HAL_PCDEx_SetTxFiFo>
  HAL_PCDEx_SetTxFiFo(&hpcd, 1, 0x100); 

  
#endif 
  return USBD_OK;
}
 8000c42:	4628      	mov	r0, r5
 8000c44:	bd70      	pop	{r4, r5, r6, pc}
 8000c46:	bf00      	nop
 8000c48:	e000ed00 	.word	0xe000ed00
 8000c4c:	20001540 	.word	0x20001540

08000c50 <USBD_LL_Start>:
  * @brief  Starts the Low Level portion of the Device driver.    
  * @param  pdev: Device handle
  * @retval USBD Status
  */
USBD_StatusTypeDef USBD_LL_Start(USBD_HandleTypeDef *pdev)
{
 8000c50:	b508      	push	{r3, lr}
  HAL_PCD_Start(pdev->pData);
 8000c52:	f8d0 02c8 	ldr.w	r0, [r0, #712]	; 0x2c8
 8000c56:	f000 fd9e 	bl	8001796 <HAL_PCD_Start>
  return USBD_OK; 
}
 8000c5a:	2000      	movs	r0, #0
 8000c5c:	bd08      	pop	{r3, pc}

08000c5e <USBD_LL_OpenEP>:
  */
USBD_StatusTypeDef USBD_LL_OpenEP(USBD_HandleTypeDef *pdev, 
                                  uint8_t  ep_addr,                                      
                                  uint8_t  ep_type,
                                  uint16_t ep_mps)
{
 8000c5e:	b510      	push	{r4, lr}
 8000c60:	4614      	mov	r4, r2
  HAL_PCD_EP_Open(pdev->pData, ep_addr, ep_mps, ep_type);
 8000c62:	f8d0 02c8 	ldr.w	r0, [r0, #712]	; 0x2c8
{
 8000c66:	461a      	mov	r2, r3
  HAL_PCD_EP_Open(pdev->pData, ep_addr, ep_mps, ep_type);
 8000c68:	4623      	mov	r3, r4
 8000c6a:	f000 fdc7 	bl	80017fc <HAL_PCD_EP_Open>
  return USBD_OK; 
}
 8000c6e:	2000      	movs	r0, #0
 8000c70:	bd10      	pop	{r4, pc}

08000c72 <USBD_LL_CloseEP>:
  * @param  pdev: Device handle
  * @param  ep_addr: Endpoint Number      
  * @retval USBD Status
  */
USBD_StatusTypeDef USBD_LL_CloseEP(USBD_HandleTypeDef *pdev, uint8_t ep_addr)   
{
 8000c72:	b508      	push	{r3, lr}
  HAL_PCD_EP_Close(pdev->pData, ep_addr);
 8000c74:	f8d0 02c8 	ldr.w	r0, [r0, #712]	; 0x2c8
 8000c78:	f000 fdf8 	bl	800186c <HAL_PCD_EP_Close>
  return USBD_OK; 
}
 8000c7c:	2000      	movs	r0, #0
 8000c7e:	bd08      	pop	{r3, pc}

08000c80 <USBD_LL_StallEP>:
  * @param  pdev: Device handle
  * @param  ep_addr: Endpoint Number      
  * @retval USBD Status
  */
USBD_StatusTypeDef USBD_LL_StallEP(USBD_HandleTypeDef *pdev, uint8_t ep_addr)   
{
 8000c80:	b508      	push	{r3, lr}
  HAL_PCD_EP_SetStall(pdev->pData, ep_addr);
 8000c82:	f8d0 02c8 	ldr.w	r0, [r0, #712]	; 0x2c8
 8000c86:	f000 fe6c 	bl	8001962 <HAL_PCD_EP_SetStall>
  return USBD_OK; 
}
 8000c8a:	2000      	movs	r0, #0
 8000c8c:	bd08      	pop	{r3, pc}

08000c8e <USBD_LL_ClearStallEP>:
  * @param  pdev: Device handle
  * @param  ep_addr: Endpoint Number      
  * @retval USBD Status
  */
USBD_StatusTypeDef USBD_LL_ClearStallEP(USBD_HandleTypeDef *pdev, uint8_t ep_addr)   
{
 8000c8e:	b508      	push	{r3, lr}
  HAL_PCD_EP_ClrStall(pdev->pData, ep_addr);  
 8000c90:	f8d0 02c8 	ldr.w	r0, [r0, #712]	; 0x2c8
 8000c94:	f000 fe9f 	bl	80019d6 <HAL_PCD_EP_ClrStall>
  return USBD_OK; 
}
 8000c98:	2000      	movs	r0, #0
 8000c9a:	bd08      	pop	{r3, pc}

08000c9c <USBD_LL_IsStallEP>:
  */
uint8_t USBD_LL_IsStallEP(USBD_HandleTypeDef *pdev, uint8_t ep_addr)   
{
  PCD_HandleTypeDef *hpcd = pdev->pData; 
  
  if((ep_addr & 0x80) == 0x80)
 8000c9c:	f011 0f80 	tst.w	r1, #128	; 0x80
  PCD_HandleTypeDef *hpcd = pdev->pData; 
 8000ca0:	f8d0 32c8 	ldr.w	r3, [r0, #712]	; 0x2c8
  if((ep_addr & 0x80) == 0x80)
 8000ca4:	f04f 0224 	mov.w	r2, #36	; 0x24
  {
    return hpcd->IN_ep[ep_addr & 0x7F].is_stall; 
 8000ca8:	bf1b      	ittet	ne
 8000caa:	f001 017f 	andne.w	r1, r1, #127	; 0x7f
 8000cae:	fb02 3301 	mlane	r3, r2, r1, r3
  }
  else
  {
    return hpcd->OUT_ep[ep_addr & 0x7F].is_stall; 
 8000cb2:	fb02 3301 	mlaeq	r3, r2, r1, r3
    return hpcd->IN_ep[ep_addr & 0x7F].is_stall; 
 8000cb6:	f893 003e 	ldrbne.w	r0, [r3, #62]	; 0x3e
    return hpcd->OUT_ep[ep_addr & 0x7F].is_stall; 
 8000cba:	bf08      	it	eq
 8000cbc:	f893 027e 	ldrbeq.w	r0, [r3, #638]	; 0x27e
  }
}
 8000cc0:	4770      	bx	lr

08000cc2 <USBD_LL_SetUSBAddress>:
  * @param  pdev: Device handle
  * @param  dev_addr: USB address      
  * @retval USBD Status
  */
USBD_StatusTypeDef USBD_LL_SetUSBAddress(USBD_HandleTypeDef *pdev, uint8_t dev_addr)   
{
 8000cc2:	b508      	push	{r3, lr}
  HAL_PCD_SetAddress(pdev->pData, dev_addr);
 8000cc4:	f8d0 02c8 	ldr.w	r0, [r0, #712]	; 0x2c8
 8000cc8:	f000 fd84 	bl	80017d4 <HAL_PCD_SetAddress>
  return USBD_OK; 
}
 8000ccc:	2000      	movs	r0, #0
 8000cce:	bd08      	pop	{r3, pc}

08000cd0 <USBD_LL_Transmit>:
USBD_StatusTypeDef USBD_LL_Transmit(USBD_HandleTypeDef *pdev, 
                                    uint8_t  ep_addr,                                      
                                    uint8_t  *pbuf,
                                    uint32_t  size)

{
 8000cd0:	b508      	push	{r3, lr}
  HAL_PCD_EP_Transmit(pdev->pData, ep_addr, pbuf, size);
 8000cd2:	f8d0 02c8 	ldr.w	r0, [r0, #712]	; 0x2c8
 8000cd6:	f000 fe24 	bl	8001922 <HAL_PCD_EP_Transmit>
  return USBD_OK;   
}
 8000cda:	2000      	movs	r0, #0
 8000cdc:	bd08      	pop	{r3, pc}

08000cde <USBD_LL_PrepareReceive>:
  */
USBD_StatusTypeDef USBD_LL_PrepareReceive(USBD_HandleTypeDef *pdev, 
                                          uint8_t  ep_addr,                                      
                                          uint8_t  *pbuf,
                                          uint32_t  size)
{
 8000cde:	b508      	push	{r3, lr}
  HAL_PCD_EP_Receive(pdev->pData, ep_addr, pbuf, size);
 8000ce0:	f8d0 02c8 	ldr.w	r0, [r0, #712]	; 0x2c8
 8000ce4:	f000 fdf1 	bl	80018ca <HAL_PCD_EP_Receive>
  return USBD_OK;   
}
 8000ce8:	2000      	movs	r0, #0
 8000cea:	bd08      	pop	{r3, pc}

08000cec <USBD_LL_GetRxDataSize>:
  * @param  ep_addr: Endpoint Number
  * @retval Received Data Size
  */
uint32_t USBD_LL_GetRxDataSize(USBD_HandleTypeDef *pdev, uint8_t  ep_addr)  
{
  return HAL_PCD_EP_GetRxCount(pdev->pData, ep_addr);
 8000cec:	f8d0 02c8 	ldr.w	r0, [r0, #712]	; 0x2c8
 8000cf0:	f000 be0f 	b.w	8001912 <HAL_PCD_EP_GetRxCount>

08000cf4 <USBD_VCP_DeviceDescriptor>:
uint8_t *USBD_VCP_DeviceDescriptor(USBD_SpeedTypeDef speed, uint16_t *length)
{
  /* Prevent unused argument(s) compilation warning */
  UNUSED(speed);

  *length = sizeof(USBD_DeviceDesc);
 8000cf4:	2312      	movs	r3, #18
  return (uint8_t*)USBD_DeviceDesc;
}
 8000cf6:	4801      	ldr	r0, [pc, #4]	; (8000cfc <USBD_VCP_DeviceDescriptor+0x8>)
  *length = sizeof(USBD_DeviceDesc);
 8000cf8:	800b      	strh	r3, [r1, #0]
}
 8000cfa:	4770      	bx	lr
 8000cfc:	2000001c 	.word	0x2000001c

08000d00 <USBD_VCP_LangIDStrDescriptor>:
uint8_t *USBD_VCP_LangIDStrDescriptor(USBD_SpeedTypeDef speed, uint16_t *length)
{
  /* Prevent unused argument(s) compilation warning */
  UNUSED(speed);

  *length = sizeof(USBD_LangIDDesc);  
 8000d00:	2304      	movs	r3, #4
  return (uint8_t*)USBD_LangIDDesc;
}
 8000d02:	4801      	ldr	r0, [pc, #4]	; (8000d08 <USBD_VCP_LangIDStrDescriptor+0x8>)
  *length = sizeof(USBD_LangIDDesc);  
 8000d04:	800b      	strh	r3, [r1, #0]
}
 8000d06:	4770      	bx	lr
 8000d08:	20000030 	.word	0x20000030

08000d0c <IntToUnicode>:
  * @param  pbuf: pointer to the buffer 
  * @param  len: buffer length
  * @retval None
  */
static void IntToUnicode (uint32_t value , uint8_t *pbuf , uint8_t len)
{
 8000d0c:	2300      	movs	r3, #0
 8000d0e:	b570      	push	{r4, r5, r6, lr}
      pbuf[2* idx] = (value >> 28) + 'A' - 10; 
    }
    
    value = value << 4;
    
    pbuf[ 2* idx + 1] = 0;
 8000d10:	1c4d      	adds	r5, r1, #1
 8000d12:	461e      	mov	r6, r3
      pbuf[ 2* idx] = (value >> 28) + '0';
 8000d14:	0f04      	lsrs	r4, r0, #28
    if( ((value >> 28)) < 0xA )
 8000d16:	f1b0 4f20 	cmp.w	r0, #2684354560	; 0xa0000000
      pbuf[ 2* idx] = (value >> 28) + '0';
 8000d1a:	bf34      	ite	cc
 8000d1c:	3430      	addcc	r4, #48	; 0x30
      pbuf[2* idx] = (value >> 28) + 'A' - 10; 
 8000d1e:	3437      	addcs	r4, #55	; 0x37
      pbuf[ 2* idx] = (value >> 28) + '0';
 8000d20:	f801 4013 	strb.w	r4, [r1, r3, lsl #1]
    pbuf[ 2* idx + 1] = 0;
 8000d24:	f805 6013 	strb.w	r6, [r5, r3, lsl #1]
  for( idx = 0; idx < len; idx ++)
 8000d28:	3301      	adds	r3, #1
 8000d2a:	b2dc      	uxtb	r4, r3
 8000d2c:	42a2      	cmp	r2, r4
    value = value << 4;
 8000d2e:	ea4f 1000 	mov.w	r0, r0, lsl #4
  for( idx = 0; idx < len; idx ++)
 8000d32:	d8ef      	bhi.n	8000d14 <IntToUnicode+0x8>
  }
}
 8000d34:	bd70      	pop	{r4, r5, r6, pc}
	...

08000d38 <USBD_VCP_SerialStrDescriptor>:
  *length = USB_SIZ_STRING_SERIAL;
 8000d38:	231a      	movs	r3, #26
{
 8000d3a:	b510      	push	{r4, lr}
  *length = USB_SIZ_STRING_SERIAL;
 8000d3c:	800b      	strh	r3, [r1, #0]
  deviceserial0 = *(uint32_t*)DEVICE_ID1;
 8000d3e:	4b0a      	ldr	r3, [pc, #40]	; (8000d68 <USBD_VCP_SerialStrDescriptor+0x30>)
 8000d40:	f8d3 0a10 	ldr.w	r0, [r3, #2576]	; 0xa10
  deviceserial0 += deviceserial2;
 8000d44:	f8d3 2a18 	ldr.w	r2, [r3, #2584]	; 0xa18
  if (deviceserial0 != 0)
 8000d48:	1880      	adds	r0, r0, r2
 8000d4a:	d00a      	beq.n	8000d62 <USBD_VCP_SerialStrDescriptor+0x2a>
  deviceserial1 = *(uint32_t*)DEVICE_ID2;
 8000d4c:	f8d3 4a14 	ldr.w	r4, [r3, #2580]	; 0xa14
    IntToUnicode (deviceserial0, &USBD_StringSerial[2] ,8);
 8000d50:	4906      	ldr	r1, [pc, #24]	; (8000d6c <USBD_VCP_SerialStrDescriptor+0x34>)
 8000d52:	2208      	movs	r2, #8
 8000d54:	f7ff ffda 	bl	8000d0c <IntToUnicode>
    IntToUnicode (deviceserial1, &USBD_StringSerial[18] ,4);
 8000d58:	2204      	movs	r2, #4
 8000d5a:	3110      	adds	r1, #16
 8000d5c:	4620      	mov	r0, r4
 8000d5e:	f7ff ffd5 	bl	8000d0c <IntToUnicode>
}
 8000d62:	4803      	ldr	r0, [pc, #12]	; (8000d70 <USBD_VCP_SerialStrDescriptor+0x38>)
 8000d64:	bd10      	pop	{r4, pc}
 8000d66:	bf00      	nop
 8000d68:	1fff7000 	.word	0x1fff7000
 8000d6c:	20000036 	.word	0x20000036
 8000d70:	20000034 	.word	0x20000034

08000d74 <USBD_VCP_ManufacturerStrDescriptor>:
{
 8000d74:	b510      	push	{r4, lr}
  USBD_GetString((uint8_t *)USBD_MANUFACTURER_STRING, USBD_StrDesc, length);
 8000d76:	4c04      	ldr	r4, [pc, #16]	; (8000d88 <USBD_VCP_ManufacturerStrDescriptor+0x14>)
 8000d78:	4804      	ldr	r0, [pc, #16]	; (8000d8c <USBD_VCP_ManufacturerStrDescriptor+0x18>)
{
 8000d7a:	460a      	mov	r2, r1
  USBD_GetString((uint8_t *)USBD_MANUFACTURER_STRING, USBD_StrDesc, length);
 8000d7c:	4621      	mov	r1, r4
 8000d7e:	f003 fcc8 	bl	8004712 <USBD_GetString>
}
 8000d82:	4620      	mov	r0, r4
 8000d84:	bd10      	pop	{r4, pc}
 8000d86:	bf00      	nop
 8000d88:	20001a4c 	.word	0x20001a4c
 8000d8c:	08004aac 	.word	0x08004aac

08000d90 <USBD_VCP_ProductStrDescriptor>:
{
 8000d90:	460a      	mov	r2, r1
 8000d92:	b508      	push	{r3, lr}
    USBD_GetString((uint8_t *)USBD_PRODUCT_HS_STRING, USBD_StrDesc, length);
 8000d94:	4904      	ldr	r1, [pc, #16]	; (8000da8 <USBD_VCP_ProductStrDescriptor+0x18>)
  if(speed == 0)
 8000d96:	b920      	cbnz	r0, 8000da2 <USBD_VCP_ProductStrDescriptor+0x12>
    USBD_GetString((uint8_t *)USBD_PRODUCT_HS_STRING, USBD_StrDesc, length);
 8000d98:	4804      	ldr	r0, [pc, #16]	; (8000dac <USBD_VCP_ProductStrDescriptor+0x1c>)
    USBD_GetString((uint8_t *)USBD_PRODUCT_FS_STRING, USBD_StrDesc, length);    
 8000d9a:	f003 fcba 	bl	8004712 <USBD_GetString>
}
 8000d9e:	4802      	ldr	r0, [pc, #8]	; (8000da8 <USBD_VCP_ProductStrDescriptor+0x18>)
 8000da0:	bd08      	pop	{r3, pc}
    USBD_GetString((uint8_t *)USBD_PRODUCT_FS_STRING, USBD_StrDesc, length);    
 8000da2:	4803      	ldr	r0, [pc, #12]	; (8000db0 <USBD_VCP_ProductStrDescriptor+0x20>)
 8000da4:	e7f9      	b.n	8000d9a <USBD_VCP_ProductStrDescriptor+0xa>
 8000da6:	bf00      	nop
 8000da8:	20001a4c 	.word	0x20001a4c
 8000dac:	08004abf 	.word	0x08004abf
 8000db0:	08004ae0 	.word	0x08004ae0

08000db4 <USBD_VCP_ConfigStrDescriptor>:
{
 8000db4:	b510      	push	{r4, lr}
    USBD_GetString((uint8_t *)USBD_CONFIGURATION_HS_STRING, USBD_StrDesc, length);
 8000db6:	4c04      	ldr	r4, [pc, #16]	; (8000dc8 <USBD_VCP_ConfigStrDescriptor+0x14>)
 8000db8:	4804      	ldr	r0, [pc, #16]	; (8000dcc <USBD_VCP_ConfigStrDescriptor+0x18>)
{
 8000dba:	460a      	mov	r2, r1
    USBD_GetString((uint8_t *)USBD_CONFIGURATION_HS_STRING, USBD_StrDesc, length);
 8000dbc:	4621      	mov	r1, r4
 8000dbe:	f003 fca8 	bl	8004712 <USBD_GetString>
}
 8000dc2:	4620      	mov	r0, r4
 8000dc4:	bd10      	pop	{r4, pc}
 8000dc6:	bf00      	nop
 8000dc8:	20001a4c 	.word	0x20001a4c
 8000dcc:	08004b01 	.word	0x08004b01

08000dd0 <USBD_VCP_InterfaceStrDescriptor>:
{
 8000dd0:	b510      	push	{r4, lr}
    USBD_GetString((uint8_t *)USBD_INTERFACE_HS_STRING, USBD_StrDesc, length);
 8000dd2:	4c04      	ldr	r4, [pc, #16]	; (8000de4 <USBD_VCP_InterfaceStrDescriptor+0x14>)
 8000dd4:	4804      	ldr	r0, [pc, #16]	; (8000de8 <USBD_VCP_InterfaceStrDescriptor+0x18>)
{
 8000dd6:	460a      	mov	r2, r1
    USBD_GetString((uint8_t *)USBD_INTERFACE_HS_STRING, USBD_StrDesc, length);
 8000dd8:	4621      	mov	r1, r4
 8000dda:	f003 fc9a 	bl	8004712 <USBD_GetString>
}
 8000dde:	4620      	mov	r0, r4
 8000de0:	bd10      	pop	{r4, pc}
 8000de2:	bf00      	nop
 8000de4:	20001a4c 	.word	0x20001a4c
 8000de8:	08004b0c 	.word	0x08004b0c

08000dec <SystemInit>:
  */
void SystemInit(void)
{
  /* FPU settings ------------------------------------------------------------*/
  #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
    SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
 8000dec:	490f      	ldr	r1, [pc, #60]	; (8000e2c <SystemInit+0x40>)
 8000dee:	f8d1 3088 	ldr.w	r3, [r1, #136]	; 0x88
 8000df2:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
 8000df6:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
  #endif
  /* Reset the RCC clock configuration to the default reset state ------------*/
  /* Set HSION bit */
  RCC->CR |= (uint32_t)0x00000001;
 8000dfa:	4b0d      	ldr	r3, [pc, #52]	; (8000e30 <SystemInit+0x44>)
 8000dfc:	681a      	ldr	r2, [r3, #0]

  /* Reset CFGR register */
  RCC->CFGR = 0x00000000;
 8000dfe:	2000      	movs	r0, #0
  RCC->CR |= (uint32_t)0x00000001;
 8000e00:	f042 0201 	orr.w	r2, r2, #1
 8000e04:	601a      	str	r2, [r3, #0]
  RCC->CFGR = 0x00000000;
 8000e06:	6098      	str	r0, [r3, #8]

  /* Reset HSEON, CSSON and PLLON bits */
  RCC->CR &= (uint32_t)0xFEF6FFFF;
 8000e08:	681a      	ldr	r2, [r3, #0]
 8000e0a:	f022 7284 	bic.w	r2, r2, #17301504	; 0x1080000
 8000e0e:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 8000e12:	601a      	str	r2, [r3, #0]

  /* Reset PLLCFGR register */
  RCC->PLLCFGR = 0x24003010;
 8000e14:	4a07      	ldr	r2, [pc, #28]	; (8000e34 <SystemInit+0x48>)
 8000e16:	605a      	str	r2, [r3, #4]

  /* Reset HSEBYP bit */
  RCC->CR &= (uint32_t)0xFFFBFFFF;
 8000e18:	681a      	ldr	r2, [r3, #0]
 8000e1a:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 8000e1e:	601a      	str	r2, [r3, #0]

  /* Disable all interrupts */
  RCC->CIR = 0x00000000;
 8000e20:	60d8      	str	r0, [r3, #12]

  /* Configure the Vector Table location add offset address ------------------*/
#ifdef VECT_TAB_SRAM
  SCB->VTOR = SRAM_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM */
#else
  SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH */
 8000e22:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
 8000e26:	608b      	str	r3, [r1, #8]
#endif
}
 8000e28:	4770      	bx	lr
 8000e2a:	bf00      	nop
 8000e2c:	e000ed00 	.word	0xe000ed00
 8000e30:	40023800 	.word	0x40023800
 8000e34:	24003010 	.word	0x24003010

08000e38 <HAL_MspInit>:
__weak void HAL_MspInit(void)
{
  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_MspInit could be implemented in the user file
   */
}
 8000e38:	4770      	bx	lr
	...

08000e3c <HAL_InitTick>:
  *       implementation  in user file.
  * @param TickPriority Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 8000e3c:	b570      	push	{r4, r5, r6, lr}
  /* Configure the SysTick to have interrupt in 1ms time basis*/
  if (HAL_SYSTICK_Config(SystemCoreClock / (1000U / uwTickFreq)) > 0U)
 8000e3e:	4e0e      	ldr	r6, [pc, #56]	; (8000e78 <HAL_InitTick+0x3c>)
 8000e40:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 8000e44:	7832      	ldrb	r2, [r6, #0]
 8000e46:	fbb3 f3f2 	udiv	r3, r3, r2
 8000e4a:	4a0c      	ldr	r2, [pc, #48]	; (8000e7c <HAL_InitTick+0x40>)
{
 8000e4c:	4605      	mov	r5, r0
  if (HAL_SYSTICK_Config(SystemCoreClock / (1000U / uwTickFreq)) > 0U)
 8000e4e:	6810      	ldr	r0, [r2, #0]
 8000e50:	fbb0 f0f3 	udiv	r0, r0, r3
 8000e54:	f000 f8ba 	bl	8000fcc <HAL_SYSTICK_Config>
 8000e58:	4604      	mov	r4, r0
 8000e5a:	b950      	cbnz	r0, 8000e72 <HAL_InitTick+0x36>
  {
    return HAL_ERROR;
  }

  /* Configure the SysTick IRQ priority */
  if (TickPriority < (1UL << __NVIC_PRIO_BITS))
 8000e5c:	2d0f      	cmp	r5, #15
 8000e5e:	d808      	bhi.n	8000e72 <HAL_InitTick+0x36>
  {
    HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0U);
 8000e60:	4602      	mov	r2, r0
 8000e62:	4629      	mov	r1, r5
 8000e64:	f04f 30ff 	mov.w	r0, #4294967295
 8000e68:	f000 f85e 	bl	8000f28 <HAL_NVIC_SetPriority>
    uwTickPrio = TickPriority;
 8000e6c:	6075      	str	r5, [r6, #4]
 8000e6e:	4620      	mov	r0, r4
    return HAL_ERROR;
  }

  /* Return function status */
  return HAL_OK;
}
 8000e70:	bd70      	pop	{r4, r5, r6, pc}
    return HAL_ERROR;
 8000e72:	2001      	movs	r0, #1
 8000e74:	e7fc      	b.n	8000e70 <HAL_InitTick+0x34>
 8000e76:	bf00      	nop
 8000e78:	20000070 	.word	0x20000070
 8000e7c:	2000006c 	.word	0x2000006c

08000e80 <HAL_Init>:
{
 8000e80:	b508      	push	{r3, lr}
  __HAL_FLASH_INSTRUCTION_CACHE_ENABLE();
 8000e82:	4b09      	ldr	r3, [pc, #36]	; (8000ea8 <HAL_Init+0x28>)
 8000e84:	681a      	ldr	r2, [r3, #0]
 8000e86:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 8000e8a:	601a      	str	r2, [r3, #0]
  __HAL_FLASH_DATA_CACHE_ENABLE();
 8000e8c:	681a      	ldr	r2, [r3, #0]
 8000e8e:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 8000e92:	601a      	str	r2, [r3, #0]
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 8000e94:	2003      	movs	r0, #3
 8000e96:	f000 f835 	bl	8000f04 <HAL_NVIC_SetPriorityGrouping>
  HAL_InitTick(TICK_INT_PRIORITY);
 8000e9a:	200f      	movs	r0, #15
 8000e9c:	f7ff ffce 	bl	8000e3c <HAL_InitTick>
  HAL_MspInit();
 8000ea0:	f7ff ffca 	bl	8000e38 <HAL_MspInit>
}
 8000ea4:	2000      	movs	r0, #0
 8000ea6:	bd08      	pop	{r3, pc}
 8000ea8:	40023c00 	.word	0x40023c00

08000eac <HAL_IncTick>:
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
  uwTick += uwTickFreq;
 8000eac:	4a03      	ldr	r2, [pc, #12]	; (8000ebc <HAL_IncTick+0x10>)
 8000eae:	4b04      	ldr	r3, [pc, #16]	; (8000ec0 <HAL_IncTick+0x14>)
 8000eb0:	6811      	ldr	r1, [r2, #0]
 8000eb2:	781b      	ldrb	r3, [r3, #0]
 8000eb4:	440b      	add	r3, r1
 8000eb6:	6013      	str	r3, [r2, #0]
}
 8000eb8:	4770      	bx	lr
 8000eba:	bf00      	nop
 8000ebc:	20001b4c 	.word	0x20001b4c
 8000ec0:	20000070 	.word	0x20000070

08000ec4 <HAL_GetTick>:
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
  return uwTick;
 8000ec4:	4b01      	ldr	r3, [pc, #4]	; (8000ecc <HAL_GetTick+0x8>)
 8000ec6:	6818      	ldr	r0, [r3, #0]
}
 8000ec8:	4770      	bx	lr
 8000eca:	bf00      	nop
 8000ecc:	20001b4c 	.word	0x20001b4c

08000ed0 <HAL_Delay>:
  *       implementations in user file.
  * @param Delay specifies the delay time length, in milliseconds.
  * @retval None
  */
__weak void HAL_Delay(uint32_t Delay)
{
 8000ed0:	b538      	push	{r3, r4, r5, lr}
 8000ed2:	4604      	mov	r4, r0
  uint32_t tickstart = HAL_GetTick();
 8000ed4:	f7ff fff6 	bl	8000ec4 <HAL_GetTick>
  uint32_t wait = Delay;

  /* Add a freq to guarantee minimum wait */
  if (wait < HAL_MAX_DELAY)
 8000ed8:	1c63      	adds	r3, r4, #1
  {
    wait += (uint32_t)(uwTickFreq);
 8000eda:	bf1c      	itt	ne
 8000edc:	4b05      	ldrne	r3, [pc, #20]	; (8000ef4 <HAL_Delay+0x24>)
 8000ede:	781b      	ldrbne	r3, [r3, #0]
  uint32_t tickstart = HAL_GetTick();
 8000ee0:	4605      	mov	r5, r0
    wait += (uint32_t)(uwTickFreq);
 8000ee2:	bf18      	it	ne
 8000ee4:	18e4      	addne	r4, r4, r3
  }

  while((HAL_GetTick() - tickstart) < wait)
 8000ee6:	f7ff ffed 	bl	8000ec4 <HAL_GetTick>
 8000eea:	1b43      	subs	r3, r0, r5
 8000eec:	42a3      	cmp	r3, r4
 8000eee:	d3fa      	bcc.n	8000ee6 <HAL_Delay+0x16>
  {
  }
}
 8000ef0:	bd38      	pop	{r3, r4, r5, pc}
 8000ef2:	bf00      	nop
 8000ef4:	20000070 	.word	0x20000070

08000ef8 <HAL_GetREVID>:
  * @brief  Returns the device revision identifier.
  * @retval Device revision identifier
  */
uint32_t HAL_GetREVID(void)
{
  return((DBGMCU->IDCODE) >> 16U);
 8000ef8:	4b01      	ldr	r3, [pc, #4]	; (8000f00 <HAL_GetREVID+0x8>)
 8000efa:	6818      	ldr	r0, [r3, #0]
}
 8000efc:	0c00      	lsrs	r0, r0, #16
 8000efe:	4770      	bx	lr
 8000f00:	e0042000 	.word	0xe0042000

08000f04 <HAL_NVIC_SetPriorityGrouping>:
  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 8000f04:	4907      	ldr	r1, [pc, #28]	; (8000f24 <HAL_NVIC_SetPriorityGrouping+0x20>)
 8000f06:	68ca      	ldr	r2, [r1, #12]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 8000f08:	f422 62e0 	bic.w	r2, r2, #1792	; 0x700
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
 8000f0c:	0203      	lsls	r3, r0, #8
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 8000f0e:	0412      	lsls	r2, r2, #16
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
 8000f10:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 8000f14:	0c12      	lsrs	r2, r2, #16
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
 8000f16:	4313      	orrs	r3, r2
  reg_value  =  (reg_value                                   |
 8000f18:	f043 63bf 	orr.w	r3, r3, #100139008	; 0x5f80000
 8000f1c:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
  SCB->AIRCR =  reg_value;
 8000f20:	60cb      	str	r3, [r1, #12]
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));
  
  /* Set the PRIGROUP[10:8] bits according to the PriorityGroup parameter value */
  NVIC_SetPriorityGrouping(PriorityGroup);
}
 8000f22:	4770      	bx	lr
 8000f24:	e000ed00 	.word	0xe000ed00

08000f28 <HAL_NVIC_SetPriority>:
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 8000f28:	4b16      	ldr	r3, [pc, #88]	; (8000f84 <HAL_NVIC_SetPriority+0x5c>)
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.          
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{ 
 8000f2a:	b530      	push	{r4, r5, lr}
 8000f2c:	68dc      	ldr	r4, [r3, #12]
 8000f2e:	f3c4 2402 	ubfx	r4, r4, #8, #3
{
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 8000f32:	f1c4 0307 	rsb	r3, r4, #7
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8000f36:	1d25      	adds	r5, r4, #4
  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 8000f38:	2b04      	cmp	r3, #4
 8000f3a:	bf28      	it	cs
 8000f3c:	2304      	movcs	r3, #4
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8000f3e:	2d06      	cmp	r5, #6

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8000f40:	f04f 35ff 	mov.w	r5, #4294967295
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8000f44:	bf8c      	ite	hi
 8000f46:	3c03      	subhi	r4, #3
 8000f48:	2400      	movls	r4, #0
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8000f4a:	fa05 f303 	lsl.w	r3, r5, r3
 8000f4e:	ea21 0303 	bic.w	r3, r1, r3
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
 8000f52:	40a5      	lsls	r5, r4
 8000f54:	ea22 0205 	bic.w	r2, r2, r5
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8000f58:	40a3      	lsls	r3, r4
  if ((int32_t)(IRQn) >= 0)
 8000f5a:	2800      	cmp	r0, #0
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8000f5c:	ea43 0302 	orr.w	r3, r3, r2
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8000f60:	bfac      	ite	ge
 8000f62:	f100 4060 	addge.w	r0, r0, #3758096384	; 0xe0000000
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8000f66:	4a08      	ldrlt	r2, [pc, #32]	; (8000f88 <HAL_NVIC_SetPriority+0x60>)
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8000f68:	ea4f 1303 	mov.w	r3, r3, lsl #4
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8000f6c:	bfb8      	it	lt
 8000f6e:	f000 000f 	andlt.w	r0, r0, #15
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8000f72:	b2db      	uxtb	r3, r3
 8000f74:	bfaa      	itet	ge
 8000f76:	f500 4061 	addge.w	r0, r0, #57600	; 0xe100
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8000f7a:	5413      	strblt	r3, [r2, r0]
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8000f7c:	f880 3300 	strbge.w	r3, [r0, #768]	; 0x300
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));
  
  prioritygroup = NVIC_GetPriorityGrouping();
  
  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
}
 8000f80:	bd30      	pop	{r4, r5, pc}
 8000f82:	bf00      	nop
 8000f84:	e000ed00 	.word	0xe000ed00
 8000f88:	e000ed14 	.word	0xe000ed14

08000f8c <HAL_NVIC_EnableIRQ>:
  if ((int32_t)(IRQn) >= 0)
 8000f8c:	2800      	cmp	r0, #0
 8000f8e:	db07      	blt.n	8000fa0 <HAL_NVIC_EnableIRQ+0x14>
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 8000f90:	0941      	lsrs	r1, r0, #5
 8000f92:	4a04      	ldr	r2, [pc, #16]	; (8000fa4 <HAL_NVIC_EnableIRQ+0x18>)
 8000f94:	f000 001f 	and.w	r0, r0, #31
 8000f98:	2301      	movs	r3, #1
 8000f9a:	4083      	lsls	r3, r0
 8000f9c:	f842 3021 	str.w	r3, [r2, r1, lsl #2]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
  
  /* Enable interrupt */
  NVIC_EnableIRQ(IRQn);
}
 8000fa0:	4770      	bx	lr
 8000fa2:	bf00      	nop
 8000fa4:	e000e100 	.word	0xe000e100

08000fa8 <HAL_NVIC_DisableIRQ>:
  if ((int32_t)(IRQn) >= 0)
 8000fa8:	2800      	cmp	r0, #0
 8000faa:	db0c      	blt.n	8000fc6 <HAL_NVIC_DisableIRQ+0x1e>
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 8000fac:	0943      	lsrs	r3, r0, #5
 8000fae:	4906      	ldr	r1, [pc, #24]	; (8000fc8 <HAL_NVIC_DisableIRQ+0x20>)
 8000fb0:	f000 001f 	and.w	r0, r0, #31
 8000fb4:	3320      	adds	r3, #32
 8000fb6:	2201      	movs	r2, #1
 8000fb8:	4082      	lsls	r2, r0
 8000fba:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
 8000fbe:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 8000fc2:	f3bf 8f6f 	isb	sy
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
  
  /* Disable interrupt */
  NVIC_DisableIRQ(IRQn);
}
 8000fc6:	4770      	bx	lr
 8000fc8:	e000e100 	.word	0xe000e100

08000fcc <HAL_SYSTICK_Config>:
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
 8000fcc:	3801      	subs	r0, #1
 8000fce:	f1b0 7f80 	cmp.w	r0, #16777216	; 0x1000000
 8000fd2:	d20b      	bcs.n	8000fec <HAL_SYSTICK_Config+0x20>
  {
    return (1UL);                                                   /* Reload value impossible */
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 8000fd4:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8000fd8:	4a05      	ldr	r2, [pc, #20]	; (8000ff0 <HAL_SYSTICK_Config+0x24>)
  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 8000fda:	6158      	str	r0, [r3, #20]
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8000fdc:	21f0      	movs	r1, #240	; 0xf0
 8000fde:	f882 1023 	strb.w	r1, [r2, #35]	; 0x23
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 8000fe2:	2000      	movs	r0, #0
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 8000fe4:	2207      	movs	r2, #7
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 8000fe6:	6198      	str	r0, [r3, #24]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 8000fe8:	611a      	str	r2, [r3, #16]
                   SysTick_CTRL_TICKINT_Msk   |
                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
  return (0UL);                                                     /* Function successful */
 8000fea:	4770      	bx	lr
    return (1UL);                                                   /* Reload value impossible */
 8000fec:	2001      	movs	r0, #1
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
   return SysTick_Config(TicksNumb);
}
 8000fee:	4770      	bx	lr
 8000ff0:	e000ed00 	.word	0xe000ed00

08000ff4 <DMA_CalcBaseAndBitshift>:
  *                     the configuration information for the specified DMA Stream. 
  * @retval Stream base address
  */
static uint32_t DMA_CalcBaseAndBitshift(DMA_HandleTypeDef *hdma)
{
  uint32_t stream_number = (((uint32_t)hdma->Instance & 0xFFU) - 16U) / 24U;
 8000ff4:	6803      	ldr	r3, [r0, #0]
{
 8000ff6:	b510      	push	{r4, lr}
  uint32_t stream_number = (((uint32_t)hdma->Instance & 0xFFU) - 16U) / 24U;
 8000ff8:	b2da      	uxtb	r2, r3
 8000ffa:	3a10      	subs	r2, #16
  
  /* lookup table for necessary bitshift of flags within status registers */
  static const uint8_t flagBitshiftOffset[8U] = {0U, 6U, 16U, 22U, 0U, 6U, 16U, 22U};
  hdma->StreamIndex = flagBitshiftOffset[stream_number];
 8000ffc:	4c07      	ldr	r4, [pc, #28]	; (800101c <DMA_CalcBaseAndBitshift+0x28>)
  
  if (stream_number > 3U)
  {
    /* return pointer to HISR and HIFCR */
    hdma->StreamBaseAddress = (((uint32_t)hdma->Instance & (uint32_t)(~0x3FFU)) + 4U);
 8000ffe:	f423 737f 	bic.w	r3, r3, #1020	; 0x3fc
 8001002:	f023 0303 	bic.w	r3, r3, #3
  if (stream_number > 3U)
 8001006:	2a5f      	cmp	r2, #95	; 0x5f
    hdma->StreamBaseAddress = (((uint32_t)hdma->Instance & (uint32_t)(~0x3FFU)) + 4U);
 8001008:	bf88      	it	hi
 800100a:	3304      	addhi	r3, #4
  uint32_t stream_number = (((uint32_t)hdma->Instance & 0xFFU) - 16U) / 24U;
 800100c:	2118      	movs	r1, #24
 800100e:	fbb2 f1f1 	udiv	r1, r2, r1
  hdma->StreamIndex = flagBitshiftOffset[stream_number];
 8001012:	5c61      	ldrb	r1, [r4, r1]
 8001014:	65c1      	str	r1, [r0, #92]	; 0x5c
    hdma->StreamBaseAddress = (((uint32_t)hdma->Instance & (uint32_t)(~0x3FFU)) + 4U);
 8001016:	6583      	str	r3, [r0, #88]	; 0x58
    /* return pointer to LISR and LIFCR */
    hdma->StreamBaseAddress = ((uint32_t)hdma->Instance & (uint32_t)(~0x3FFU));
  }
  
  return hdma->StreamBaseAddress;
}
 8001018:	4618      	mov	r0, r3
 800101a:	bd10      	pop	{r4, pc}
 800101c:	08004aa4 	.word	0x08004aa4

08001020 <HAL_DMA_Init>:
{
 8001020:	b570      	push	{r4, r5, r6, lr}
 8001022:	4604      	mov	r4, r0
  uint32_t tickstart = HAL_GetTick();
 8001024:	f7ff ff4e 	bl	8000ec4 <HAL_GetTick>
 8001028:	4605      	mov	r5, r0
  if(hdma == NULL)
 800102a:	2c00      	cmp	r4, #0
 800102c:	d071      	beq.n	8001112 <HAL_DMA_Init+0xf2>
  hdma->State = HAL_DMA_STATE_BUSY;
 800102e:	2302      	movs	r3, #2
 8001030:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35
  __HAL_DMA_DISABLE(hdma);
 8001034:	6822      	ldr	r2, [r4, #0]
  __HAL_UNLOCK(hdma);
 8001036:	2300      	movs	r3, #0
 8001038:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
  __HAL_DMA_DISABLE(hdma);
 800103c:	6813      	ldr	r3, [r2, #0]
 800103e:	f023 0301 	bic.w	r3, r3, #1
 8001042:	6013      	str	r3, [r2, #0]
  while((hdma->Instance->CR & DMA_SxCR_EN) != RESET)
 8001044:	6822      	ldr	r2, [r4, #0]
 8001046:	6813      	ldr	r3, [r2, #0]
 8001048:	07d8      	lsls	r0, r3, #31
 800104a:	d42e      	bmi.n	80010aa <HAL_DMA_Init+0x8a>
  tmp = hdma->Instance->CR;
 800104c:	6813      	ldr	r3, [r2, #0]
  tmp &= ((uint32_t)~(DMA_SxCR_CHSEL | DMA_SxCR_MBURST | DMA_SxCR_PBURST | \
 800104e:	4832      	ldr	r0, [pc, #200]	; (8001118 <HAL_DMA_Init+0xf8>)
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
 8001050:	69a1      	ldr	r1, [r4, #24]
  tmp &= ((uint32_t)~(DMA_SxCR_CHSEL | DMA_SxCR_MBURST | DMA_SxCR_PBURST | \
 8001052:	4018      	ands	r0, r3
  tmp |=  hdma->Init.Channel             | hdma->Init.Direction        |
 8001054:	e9d4 3501 	ldrd	r3, r5, [r4, #4]
 8001058:	432b      	orrs	r3, r5
 800105a:	68e5      	ldr	r5, [r4, #12]
 800105c:	432b      	orrs	r3, r5
          hdma->Init.PeriphInc           | hdma->Init.MemInc           |
 800105e:	6925      	ldr	r5, [r4, #16]
 8001060:	432b      	orrs	r3, r5
 8001062:	6965      	ldr	r5, [r4, #20]
 8001064:	432b      	orrs	r3, r5
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
 8001066:	69e5      	ldr	r5, [r4, #28]
 8001068:	430b      	orrs	r3, r1
 800106a:	432b      	orrs	r3, r5
          hdma->Init.Mode                | hdma->Init.Priority;
 800106c:	6a25      	ldr	r5, [r4, #32]
 800106e:	432b      	orrs	r3, r5
  tmp |=  hdma->Init.Channel             | hdma->Init.Direction        |
 8001070:	4303      	orrs	r3, r0
  if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)
 8001072:	6a60      	ldr	r0, [r4, #36]	; 0x24
 8001074:	2804      	cmp	r0, #4
    tmp |=  hdma->Init.MemBurst | hdma->Init.PeriphBurst;
 8001076:	bf02      	ittt	eq
 8001078:	e9d4 560b 	ldrdeq	r5, r6, [r4, #44]	; 0x2c
 800107c:	4335      	orreq	r5, r6
 800107e:	432b      	orreq	r3, r5
  hdma->Instance->CR = tmp;  
 8001080:	6013      	str	r3, [r2, #0]
  tmp = hdma->Instance->FCR;
 8001082:	6953      	ldr	r3, [r2, #20]
  if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)
 8001084:	2804      	cmp	r0, #4
  tmp &= (uint32_t)~(DMA_SxFCR_DMDIS | DMA_SxFCR_FTH);
 8001086:	f023 0307 	bic.w	r3, r3, #7
  tmp |= hdma->Init.FIFOMode;
 800108a:	ea43 0300 	orr.w	r3, r3, r0
  if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)
 800108e:	d132      	bne.n	80010f6 <HAL_DMA_Init+0xd6>
    tmp |= hdma->Init.FIFOThreshold;
 8001090:	6aa0      	ldr	r0, [r4, #40]	; 0x28
    if (hdma->Init.MemBurst != DMA_MBURST_SINGLE)
 8001092:	6ae5      	ldr	r5, [r4, #44]	; 0x2c
    tmp |= hdma->Init.FIFOThreshold;
 8001094:	4303      	orrs	r3, r0
    if (hdma->Init.MemBurst != DMA_MBURST_SINGLE)
 8001096:	b375      	cbz	r5, 80010f6 <HAL_DMA_Init+0xd6>
{
  HAL_StatusTypeDef status = HAL_OK;
  uint32_t tmp = hdma->Init.FIFOThreshold;
  
  /* Memory Data size equal to Byte */
  if(hdma->Init.MemDataAlignment == DMA_MDATAALIGN_BYTE)
 8001098:	b991      	cbnz	r1, 80010c0 <HAL_DMA_Init+0xa0>
  {
    switch (tmp)
 800109a:	2801      	cmp	r0, #1
 800109c:	d020      	beq.n	80010e0 <HAL_DMA_Init+0xc0>
 800109e:	f030 0102 	bics.w	r1, r0, #2
 80010a2:	d128      	bne.n	80010f6 <HAL_DMA_Init+0xd6>
    case DMA_FIFO_THRESHOLD_HALFFULL:
    case DMA_FIFO_THRESHOLD_3QUARTERSFULL:
      status = HAL_ERROR;
      break;
    case DMA_FIFO_THRESHOLD_FULL:
      if ((hdma->Init.MemBurst & DMA_SxCR_MBURST_1) == DMA_SxCR_MBURST_1)
 80010a4:	01e9      	lsls	r1, r5, #7
 80010a6:	d526      	bpl.n	80010f6 <HAL_DMA_Init+0xd6>
 80010a8:	e01d      	b.n	80010e6 <HAL_DMA_Init+0xc6>
    if((HAL_GetTick() - tickstart ) > HAL_TIMEOUT_DMA_ABORT)
 80010aa:	f7ff ff0b 	bl	8000ec4 <HAL_GetTick>
 80010ae:	1b40      	subs	r0, r0, r5
 80010b0:	2805      	cmp	r0, #5
 80010b2:	d9c7      	bls.n	8001044 <HAL_DMA_Init+0x24>
      hdma->ErrorCode = HAL_DMA_ERROR_TIMEOUT;
 80010b4:	2320      	movs	r3, #32
 80010b6:	6563      	str	r3, [r4, #84]	; 0x54
      hdma->State = HAL_DMA_STATE_TIMEOUT;
 80010b8:	2003      	movs	r0, #3
        hdma->State = HAL_DMA_STATE_READY;
 80010ba:	f884 0035 	strb.w	r0, [r4, #53]	; 0x35
}
 80010be:	bd70      	pop	{r4, r5, r6, pc}
  else if (hdma->Init.MemDataAlignment == DMA_MDATAALIGN_HALFWORD)
 80010c0:	f5b1 5f00 	cmp.w	r1, #8192	; 0x2000
 80010c4:	d113      	bne.n	80010ee <HAL_DMA_Init+0xce>
    switch (tmp)
 80010c6:	2803      	cmp	r0, #3
 80010c8:	d815      	bhi.n	80010f6 <HAL_DMA_Init+0xd6>
 80010ca:	a101      	add	r1, pc, #4	; (adr r1, 80010d0 <HAL_DMA_Init+0xb0>)
 80010cc:	f851 f020 	ldr.w	pc, [r1, r0, lsl #2]
 80010d0:	080010e7 	.word	0x080010e7
 80010d4:	080010a5 	.word	0x080010a5
 80010d8:	080010e7 	.word	0x080010e7
 80010dc:	080010e1 	.word	0x080010e1
      if (hdma->Init.MemBurst == DMA_MBURST_INC16)
 80010e0:	f1b5 7fc0 	cmp.w	r5, #25165824	; 0x1800000
 80010e4:	d107      	bne.n	80010f6 <HAL_DMA_Init+0xd6>
        hdma->ErrorCode = HAL_DMA_ERROR_PARAM;
 80010e6:	2340      	movs	r3, #64	; 0x40
 80010e8:	6563      	str	r3, [r4, #84]	; 0x54
        hdma->State = HAL_DMA_STATE_READY;
 80010ea:	2001      	movs	r0, #1
 80010ec:	e7e5      	b.n	80010ba <HAL_DMA_Init+0x9a>
    switch (tmp)
 80010ee:	2802      	cmp	r0, #2
 80010f0:	d9f9      	bls.n	80010e6 <HAL_DMA_Init+0xc6>
 80010f2:	2803      	cmp	r0, #3
 80010f4:	d0d6      	beq.n	80010a4 <HAL_DMA_Init+0x84>
  hdma->Instance->FCR = tmp;
 80010f6:	6153      	str	r3, [r2, #20]
  regs = (DMA_Base_Registers *)DMA_CalcBaseAndBitshift(hdma);
 80010f8:	4620      	mov	r0, r4
 80010fa:	f7ff ff7b 	bl	8000ff4 <DMA_CalcBaseAndBitshift>
  regs->IFCR = 0x3FU << hdma->StreamIndex;
 80010fe:	6de2      	ldr	r2, [r4, #92]	; 0x5c
 8001100:	233f      	movs	r3, #63	; 0x3f
 8001102:	4093      	lsls	r3, r2
 8001104:	6083      	str	r3, [r0, #8]
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 8001106:	2000      	movs	r0, #0
  hdma->State = HAL_DMA_STATE_READY;
 8001108:	2301      	movs	r3, #1
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 800110a:	6560      	str	r0, [r4, #84]	; 0x54
  hdma->State = HAL_DMA_STATE_READY;
 800110c:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35
  return HAL_OK;
 8001110:	e7d5      	b.n	80010be <HAL_DMA_Init+0x9e>
    return HAL_ERROR;
 8001112:	2001      	movs	r0, #1
 8001114:	e7d3      	b.n	80010be <HAL_DMA_Init+0x9e>
 8001116:	bf00      	nop
 8001118:	f010803f 	.word	0xf010803f

0800111c <HAL_DMA_Start_IT>:
{
 800111c:	b570      	push	{r4, r5, r6, lr}
  __HAL_LOCK(hdma);
 800111e:	f890 4034 	ldrb.w	r4, [r0, #52]	; 0x34
  DMA_Base_Registers *regs = (DMA_Base_Registers *)hdma->StreamBaseAddress;
 8001122:	6d86      	ldr	r6, [r0, #88]	; 0x58
  __HAL_LOCK(hdma);
 8001124:	2c01      	cmp	r4, #1
 8001126:	d031      	beq.n	800118c <HAL_DMA_Start_IT+0x70>
 8001128:	2401      	movs	r4, #1
 800112a:	f880 4034 	strb.w	r4, [r0, #52]	; 0x34
  if(HAL_DMA_STATE_READY == hdma->State)
 800112e:	f890 4035 	ldrb.w	r4, [r0, #53]	; 0x35
 8001132:	2c01      	cmp	r4, #1
 8001134:	f04f 0500 	mov.w	r5, #0
 8001138:	f04f 0402 	mov.w	r4, #2
 800113c:	d124      	bne.n	8001188 <HAL_DMA_Start_IT+0x6c>
    hdma->State = HAL_DMA_STATE_BUSY;
 800113e:	f880 4035 	strb.w	r4, [r0, #53]	; 0x35
  hdma->Instance->CR &= (uint32_t)(~DMA_SxCR_DBM);
 8001142:	6804      	ldr	r4, [r0, #0]
    hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 8001144:	6545      	str	r5, [r0, #84]	; 0x54
  hdma->Instance->CR &= (uint32_t)(~DMA_SxCR_DBM);
 8001146:	6825      	ldr	r5, [r4, #0]
 8001148:	f425 2580 	bic.w	r5, r5, #262144	; 0x40000
 800114c:	6025      	str	r5, [r4, #0]
  hdma->Instance->NDTR = DataLength;
 800114e:	6063      	str	r3, [r4, #4]
  if((hdma->Init.Direction) == DMA_MEMORY_TO_PERIPH)
 8001150:	6883      	ldr	r3, [r0, #8]
 8001152:	2b40      	cmp	r3, #64	; 0x40
    hdma->Instance->PAR = DstAddress;
 8001154:	bf0e      	itee	eq
 8001156:	60a2      	streq	r2, [r4, #8]
    hdma->Instance->PAR = SrcAddress;
 8001158:	60a1      	strne	r1, [r4, #8]
    hdma->Instance->M0AR = DstAddress;
 800115a:	60e2      	strne	r2, [r4, #12]
    regs->IFCR = 0x3FU << hdma->StreamIndex;
 800115c:	6dc2      	ldr	r2, [r0, #92]	; 0x5c
    hdma->Instance->M0AR = SrcAddress;
 800115e:	bf08      	it	eq
 8001160:	60e1      	streq	r1, [r4, #12]
    regs->IFCR = 0x3FU << hdma->StreamIndex;
 8001162:	233f      	movs	r3, #63	; 0x3f
 8001164:	4093      	lsls	r3, r2
 8001166:	60b3      	str	r3, [r6, #8]
    hdma->Instance->CR  |= DMA_IT_TC | DMA_IT_TE | DMA_IT_DME;
 8001168:	6823      	ldr	r3, [r4, #0]
 800116a:	f043 0316 	orr.w	r3, r3, #22
 800116e:	6023      	str	r3, [r4, #0]
    if(hdma->XferHalfCpltCallback != NULL)
 8001170:	6c03      	ldr	r3, [r0, #64]	; 0x40
 8001172:	b11b      	cbz	r3, 800117c <HAL_DMA_Start_IT+0x60>
      hdma->Instance->CR  |= DMA_IT_HT;
 8001174:	6823      	ldr	r3, [r4, #0]
 8001176:	f043 0308 	orr.w	r3, r3, #8
 800117a:	6023      	str	r3, [r4, #0]
    __HAL_DMA_ENABLE(hdma);
 800117c:	6823      	ldr	r3, [r4, #0]
 800117e:	f043 0301 	orr.w	r3, r3, #1
 8001182:	6023      	str	r3, [r4, #0]
  HAL_StatusTypeDef status = HAL_OK;
 8001184:	2000      	movs	r0, #0
}
 8001186:	bd70      	pop	{r4, r5, r6, pc}
    __HAL_UNLOCK(hdma);	  
 8001188:	f880 5034 	strb.w	r5, [r0, #52]	; 0x34
  __HAL_LOCK(hdma);
 800118c:	2002      	movs	r0, #2
 800118e:	e7fa      	b.n	8001186 <HAL_DMA_Start_IT+0x6a>

08001190 <HAL_DMA_Abort>:
{
 8001190:	b570      	push	{r4, r5, r6, lr}
 8001192:	4604      	mov	r4, r0
  DMA_Base_Registers *regs = (DMA_Base_Registers *)hdma->StreamBaseAddress;
 8001194:	6d86      	ldr	r6, [r0, #88]	; 0x58
  uint32_t tickstart = HAL_GetTick();
 8001196:	f7ff fe95 	bl	8000ec4 <HAL_GetTick>
  if(hdma->State != HAL_DMA_STATE_BUSY)
 800119a:	f894 3035 	ldrb.w	r3, [r4, #53]	; 0x35
 800119e:	2b02      	cmp	r3, #2
  uint32_t tickstart = HAL_GetTick();
 80011a0:	4605      	mov	r5, r0
  if(hdma->State != HAL_DMA_STATE_BUSY)
 80011a2:	d006      	beq.n	80011b2 <HAL_DMA_Abort+0x22>
    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
 80011a4:	2380      	movs	r3, #128	; 0x80
 80011a6:	6563      	str	r3, [r4, #84]	; 0x54
    return HAL_ERROR;
 80011a8:	2001      	movs	r0, #1
    __HAL_UNLOCK(hdma);
 80011aa:	2300      	movs	r3, #0
 80011ac:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
}
 80011b0:	bd70      	pop	{r4, r5, r6, pc}
    hdma->Instance->CR  &= ~(DMA_IT_TC | DMA_IT_TE | DMA_IT_DME);
 80011b2:	6823      	ldr	r3, [r4, #0]
 80011b4:	681a      	ldr	r2, [r3, #0]
 80011b6:	f022 0216 	bic.w	r2, r2, #22
 80011ba:	601a      	str	r2, [r3, #0]
    hdma->Instance->FCR &= ~(DMA_IT_FE);
 80011bc:	695a      	ldr	r2, [r3, #20]
 80011be:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 80011c2:	615a      	str	r2, [r3, #20]
    if((hdma->XferHalfCpltCallback != NULL) || (hdma->XferM1HalfCpltCallback != NULL))
 80011c4:	6c22      	ldr	r2, [r4, #64]	; 0x40
 80011c6:	b90a      	cbnz	r2, 80011cc <HAL_DMA_Abort+0x3c>
 80011c8:	6ca2      	ldr	r2, [r4, #72]	; 0x48
 80011ca:	b11a      	cbz	r2, 80011d4 <HAL_DMA_Abort+0x44>
      hdma->Instance->CR  &= ~(DMA_IT_HT);
 80011cc:	681a      	ldr	r2, [r3, #0]
 80011ce:	f022 0208 	bic.w	r2, r2, #8
 80011d2:	601a      	str	r2, [r3, #0]
    __HAL_DMA_DISABLE(hdma);
 80011d4:	681a      	ldr	r2, [r3, #0]
 80011d6:	f022 0201 	bic.w	r2, r2, #1
 80011da:	601a      	str	r2, [r3, #0]
    while((hdma->Instance->CR & DMA_SxCR_EN) != RESET)
 80011dc:	6823      	ldr	r3, [r4, #0]
 80011de:	681b      	ldr	r3, [r3, #0]
 80011e0:	f013 0301 	ands.w	r3, r3, #1
 80011e4:	d108      	bne.n	80011f8 <HAL_DMA_Abort+0x68>
    regs->IFCR = 0x3FU << hdma->StreamIndex;
 80011e6:	6de1      	ldr	r1, [r4, #92]	; 0x5c
 80011e8:	223f      	movs	r2, #63	; 0x3f
 80011ea:	408a      	lsls	r2, r1
 80011ec:	60b2      	str	r2, [r6, #8]
    hdma->State = HAL_DMA_STATE_READY;
 80011ee:	2201      	movs	r2, #1
 80011f0:	f884 2035 	strb.w	r2, [r4, #53]	; 0x35
  return HAL_OK;
 80011f4:	4618      	mov	r0, r3
 80011f6:	e7d8      	b.n	80011aa <HAL_DMA_Abort+0x1a>
      if((HAL_GetTick() - tickstart ) > HAL_TIMEOUT_DMA_ABORT)
 80011f8:	f7ff fe64 	bl	8000ec4 <HAL_GetTick>
 80011fc:	1b40      	subs	r0, r0, r5
 80011fe:	2805      	cmp	r0, #5
 8001200:	d9ec      	bls.n	80011dc <HAL_DMA_Abort+0x4c>
        hdma->ErrorCode = HAL_DMA_ERROR_TIMEOUT;
 8001202:	2320      	movs	r3, #32
        hdma->State = HAL_DMA_STATE_TIMEOUT;
 8001204:	2003      	movs	r0, #3
        hdma->ErrorCode = HAL_DMA_ERROR_TIMEOUT;
 8001206:	6563      	str	r3, [r4, #84]	; 0x54
        hdma->State = HAL_DMA_STATE_TIMEOUT;
 8001208:	f884 0035 	strb.w	r0, [r4, #53]	; 0x35
        return HAL_TIMEOUT;
 800120c:	e7cd      	b.n	80011aa <HAL_DMA_Abort+0x1a>

0800120e <HAL_DMA_Abort_IT>:
  if(hdma->State != HAL_DMA_STATE_BUSY)
 800120e:	f890 3035 	ldrb.w	r3, [r0, #53]	; 0x35
 8001212:	2b02      	cmp	r3, #2
 8001214:	d003      	beq.n	800121e <HAL_DMA_Abort_IT+0x10>
    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
 8001216:	2380      	movs	r3, #128	; 0x80
 8001218:	6543      	str	r3, [r0, #84]	; 0x54
    return HAL_ERROR;
 800121a:	2001      	movs	r0, #1
 800121c:	4770      	bx	lr
    __HAL_DMA_DISABLE(hdma);
 800121e:	6802      	ldr	r2, [r0, #0]
    hdma->State = HAL_DMA_STATE_ABORT;
 8001220:	2305      	movs	r3, #5
 8001222:	f880 3035 	strb.w	r3, [r0, #53]	; 0x35
    __HAL_DMA_DISABLE(hdma);
 8001226:	6813      	ldr	r3, [r2, #0]
 8001228:	f023 0301 	bic.w	r3, r3, #1
 800122c:	6013      	str	r3, [r2, #0]
  return HAL_OK;
 800122e:	2000      	movs	r0, #0
}
 8001230:	4770      	bx	lr
	...

08001234 <HAL_DMA_IRQHandler>:
{
 8001234:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
  __IO uint32_t count = 0U;
 8001236:	2300      	movs	r3, #0
 8001238:	9301      	str	r3, [sp, #4]
  uint32_t timeout = SystemCoreClock / 9600U;
 800123a:	4b5c      	ldr	r3, [pc, #368]	; (80013ac <HAL_DMA_IRQHandler+0x178>)
  DMA_Base_Registers *regs = (DMA_Base_Registers *)hdma->StreamBaseAddress;
 800123c:	6d85      	ldr	r5, [r0, #88]	; 0x58
  uint32_t timeout = SystemCoreClock / 9600U;
 800123e:	681f      	ldr	r7, [r3, #0]
  if ((tmpisr & (DMA_FLAG_TEIF0_4 << hdma->StreamIndex)) != RESET)
 8001240:	6dc3      	ldr	r3, [r0, #92]	; 0x5c
  tmpisr = regs->ISR;
 8001242:	682e      	ldr	r6, [r5, #0]
  if ((tmpisr & (DMA_FLAG_TEIF0_4 << hdma->StreamIndex)) != RESET)
 8001244:	2208      	movs	r2, #8
 8001246:	409a      	lsls	r2, r3
 8001248:	4232      	tst	r2, r6
{
 800124a:	4604      	mov	r4, r0
  if ((tmpisr & (DMA_FLAG_TEIF0_4 << hdma->StreamIndex)) != RESET)
 800124c:	d00c      	beq.n	8001268 <HAL_DMA_IRQHandler+0x34>
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_TE) != RESET)
 800124e:	6801      	ldr	r1, [r0, #0]
 8001250:	6808      	ldr	r0, [r1, #0]
 8001252:	0740      	lsls	r0, r0, #29
 8001254:	d508      	bpl.n	8001268 <HAL_DMA_IRQHandler+0x34>
      hdma->Instance->CR  &= ~(DMA_IT_TE);
 8001256:	6808      	ldr	r0, [r1, #0]
 8001258:	f020 0004 	bic.w	r0, r0, #4
 800125c:	6008      	str	r0, [r1, #0]
      regs->IFCR = DMA_FLAG_TEIF0_4 << hdma->StreamIndex;
 800125e:	60aa      	str	r2, [r5, #8]
      hdma->ErrorCode |= HAL_DMA_ERROR_TE;
 8001260:	6d62      	ldr	r2, [r4, #84]	; 0x54
 8001262:	f042 0201 	orr.w	r2, r2, #1
 8001266:	6562      	str	r2, [r4, #84]	; 0x54
  if ((tmpisr & (DMA_FLAG_FEIF0_4 << hdma->StreamIndex)) != RESET)
 8001268:	2201      	movs	r2, #1
 800126a:	409a      	lsls	r2, r3
 800126c:	4232      	tst	r2, r6
 800126e:	d008      	beq.n	8001282 <HAL_DMA_IRQHandler+0x4e>
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_FE) != RESET)
 8001270:	6821      	ldr	r1, [r4, #0]
 8001272:	6949      	ldr	r1, [r1, #20]
 8001274:	0609      	lsls	r1, r1, #24
      regs->IFCR = DMA_FLAG_FEIF0_4 << hdma->StreamIndex;
 8001276:	bf41      	itttt	mi
 8001278:	60aa      	strmi	r2, [r5, #8]
      hdma->ErrorCode |= HAL_DMA_ERROR_FE;
 800127a:	6d62      	ldrmi	r2, [r4, #84]	; 0x54
 800127c:	f042 0202 	orrmi.w	r2, r2, #2
 8001280:	6562      	strmi	r2, [r4, #84]	; 0x54
  if ((tmpisr & (DMA_FLAG_DMEIF0_4 << hdma->StreamIndex)) != RESET)
 8001282:	2204      	movs	r2, #4
 8001284:	409a      	lsls	r2, r3
 8001286:	4232      	tst	r2, r6
 8001288:	d008      	beq.n	800129c <HAL_DMA_IRQHandler+0x68>
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_DME) != RESET)
 800128a:	6821      	ldr	r1, [r4, #0]
 800128c:	6809      	ldr	r1, [r1, #0]
 800128e:	0788      	lsls	r0, r1, #30
      regs->IFCR = DMA_FLAG_DMEIF0_4 << hdma->StreamIndex;
 8001290:	bf41      	itttt	mi
 8001292:	60aa      	strmi	r2, [r5, #8]
      hdma->ErrorCode |= HAL_DMA_ERROR_DME;
 8001294:	6d62      	ldrmi	r2, [r4, #84]	; 0x54
 8001296:	f042 0204 	orrmi.w	r2, r2, #4
 800129a:	6562      	strmi	r2, [r4, #84]	; 0x54
  if ((tmpisr & (DMA_FLAG_HTIF0_4 << hdma->StreamIndex)) != RESET)
 800129c:	2210      	movs	r2, #16
 800129e:	409a      	lsls	r2, r3
 80012a0:	4232      	tst	r2, r6
 80012a2:	d010      	beq.n	80012c6 <HAL_DMA_IRQHandler+0x92>
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_HT) != RESET)
 80012a4:	6823      	ldr	r3, [r4, #0]
 80012a6:	6819      	ldr	r1, [r3, #0]
 80012a8:	0709      	lsls	r1, r1, #28
 80012aa:	d50c      	bpl.n	80012c6 <HAL_DMA_IRQHandler+0x92>
      regs->IFCR = DMA_FLAG_HTIF0_4 << hdma->StreamIndex;
 80012ac:	60aa      	str	r2, [r5, #8]
      if(((hdma->Instance->CR) & (uint32_t)(DMA_SxCR_DBM)) != RESET)
 80012ae:	681a      	ldr	r2, [r3, #0]
 80012b0:	0350      	lsls	r0, r2, #13
 80012b2:	d537      	bpl.n	8001324 <HAL_DMA_IRQHandler+0xf0>
        if((hdma->Instance->CR & DMA_SxCR_CT) == RESET)
 80012b4:	681b      	ldr	r3, [r3, #0]
 80012b6:	0319      	lsls	r1, r3, #12
 80012b8:	d401      	bmi.n	80012be <HAL_DMA_IRQHandler+0x8a>
        if(hdma->XferHalfCpltCallback != NULL)
 80012ba:	6c23      	ldr	r3, [r4, #64]	; 0x40
 80012bc:	e000      	b.n	80012c0 <HAL_DMA_IRQHandler+0x8c>
          if(hdma->XferM1HalfCpltCallback != NULL)
 80012be:	6ca3      	ldr	r3, [r4, #72]	; 0x48
        if(hdma->XferHalfCpltCallback != NULL)
 80012c0:	b10b      	cbz	r3, 80012c6 <HAL_DMA_IRQHandler+0x92>
          hdma->XferHalfCpltCallback(hdma);
 80012c2:	4620      	mov	r0, r4
 80012c4:	4798      	blx	r3
  if ((tmpisr & (DMA_FLAG_TCIF0_4 << hdma->StreamIndex)) != RESET)
 80012c6:	6de1      	ldr	r1, [r4, #92]	; 0x5c
 80012c8:	2220      	movs	r2, #32
 80012ca:	408a      	lsls	r2, r1
 80012cc:	4232      	tst	r2, r6
 80012ce:	d03a      	beq.n	8001346 <HAL_DMA_IRQHandler+0x112>
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_TC) != RESET)
 80012d0:	6823      	ldr	r3, [r4, #0]
 80012d2:	6818      	ldr	r0, [r3, #0]
 80012d4:	06c6      	lsls	r6, r0, #27
 80012d6:	d536      	bpl.n	8001346 <HAL_DMA_IRQHandler+0x112>
      regs->IFCR = DMA_FLAG_TCIF0_4 << hdma->StreamIndex;
 80012d8:	60aa      	str	r2, [r5, #8]
      if(HAL_DMA_STATE_ABORT == hdma->State)
 80012da:	f894 2035 	ldrb.w	r2, [r4, #53]	; 0x35
 80012de:	2a05      	cmp	r2, #5
        hdma->Instance->CR  &= ~(DMA_IT_TC | DMA_IT_TE | DMA_IT_DME);
 80012e0:	681a      	ldr	r2, [r3, #0]
      if(HAL_DMA_STATE_ABORT == hdma->State)
 80012e2:	d127      	bne.n	8001334 <HAL_DMA_IRQHandler+0x100>
        hdma->Instance->CR  &= ~(DMA_IT_TC | DMA_IT_TE | DMA_IT_DME);
 80012e4:	f022 0216 	bic.w	r2, r2, #22
 80012e8:	601a      	str	r2, [r3, #0]
        hdma->Instance->FCR &= ~(DMA_IT_FE);
 80012ea:	695a      	ldr	r2, [r3, #20]
 80012ec:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 80012f0:	615a      	str	r2, [r3, #20]
        if((hdma->XferHalfCpltCallback != NULL) || (hdma->XferM1HalfCpltCallback != NULL))
 80012f2:	6c22      	ldr	r2, [r4, #64]	; 0x40
 80012f4:	b90a      	cbnz	r2, 80012fa <HAL_DMA_IRQHandler+0xc6>
 80012f6:	6ca2      	ldr	r2, [r4, #72]	; 0x48
 80012f8:	b11a      	cbz	r2, 8001302 <HAL_DMA_IRQHandler+0xce>
          hdma->Instance->CR  &= ~(DMA_IT_HT);
 80012fa:	681a      	ldr	r2, [r3, #0]
 80012fc:	f022 0208 	bic.w	r2, r2, #8
 8001300:	601a      	str	r2, [r3, #0]
        regs->IFCR = 0x3FU << hdma->StreamIndex;
 8001302:	233f      	movs	r3, #63	; 0x3f
 8001304:	408b      	lsls	r3, r1
 8001306:	60ab      	str	r3, [r5, #8]
        hdma->State = HAL_DMA_STATE_READY;
 8001308:	2301      	movs	r3, #1
 800130a:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35
        __HAL_UNLOCK(hdma);
 800130e:	2300      	movs	r3, #0
 8001310:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
        if(hdma->XferAbortCallback != NULL)
 8001314:	6d23      	ldr	r3, [r4, #80]	; 0x50
    if(hdma->XferErrorCallback != NULL)
 8001316:	2b00      	cmp	r3, #0
 8001318:	d045      	beq.n	80013a6 <HAL_DMA_IRQHandler+0x172>
      hdma->XferErrorCallback(hdma);
 800131a:	4620      	mov	r0, r4
}
 800131c:	b003      	add	sp, #12
 800131e:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
      hdma->XferErrorCallback(hdma);
 8001322:	4718      	bx	r3
        if((hdma->Instance->CR & DMA_SxCR_CIRC) == RESET)
 8001324:	681a      	ldr	r2, [r3, #0]
 8001326:	05d2      	lsls	r2, r2, #23
          hdma->Instance->CR  &= ~(DMA_IT_HT);
 8001328:	bf5e      	ittt	pl
 800132a:	681a      	ldrpl	r2, [r3, #0]
 800132c:	f022 0208 	bicpl.w	r2, r2, #8
 8001330:	601a      	strpl	r2, [r3, #0]
 8001332:	e7c2      	b.n	80012ba <HAL_DMA_IRQHandler+0x86>
      if(((hdma->Instance->CR) & (uint32_t)(DMA_SxCR_DBM)) != RESET)
 8001334:	0350      	lsls	r0, r2, #13
 8001336:	d527      	bpl.n	8001388 <HAL_DMA_IRQHandler+0x154>
        if((hdma->Instance->CR & DMA_SxCR_CT) == RESET)
 8001338:	681b      	ldr	r3, [r3, #0]
 800133a:	0319      	lsls	r1, r3, #12
 800133c:	d431      	bmi.n	80013a2 <HAL_DMA_IRQHandler+0x16e>
          if(hdma->XferM1CpltCallback != NULL)
 800133e:	6c63      	ldr	r3, [r4, #68]	; 0x44
        if(hdma->XferCpltCallback != NULL)
 8001340:	b10b      	cbz	r3, 8001346 <HAL_DMA_IRQHandler+0x112>
          hdma->XferCpltCallback(hdma);
 8001342:	4620      	mov	r0, r4
 8001344:	4798      	blx	r3
  if(hdma->ErrorCode != HAL_DMA_ERROR_NONE)
 8001346:	6d63      	ldr	r3, [r4, #84]	; 0x54
 8001348:	b36b      	cbz	r3, 80013a6 <HAL_DMA_IRQHandler+0x172>
    if((hdma->ErrorCode & HAL_DMA_ERROR_TE) != RESET)
 800134a:	6d63      	ldr	r3, [r4, #84]	; 0x54
 800134c:	07da      	lsls	r2, r3, #31
 800134e:	d519      	bpl.n	8001384 <HAL_DMA_IRQHandler+0x150>
      __HAL_DMA_DISABLE(hdma);
 8001350:	6822      	ldr	r2, [r4, #0]
  uint32_t timeout = SystemCoreClock / 9600U;
 8001352:	f44f 5316 	mov.w	r3, #9600	; 0x2580
 8001356:	fbb7 f7f3 	udiv	r7, r7, r3
      hdma->State = HAL_DMA_STATE_ABORT;
 800135a:	2305      	movs	r3, #5
 800135c:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35
      __HAL_DMA_DISABLE(hdma);
 8001360:	6813      	ldr	r3, [r2, #0]
 8001362:	f023 0301 	bic.w	r3, r3, #1
 8001366:	6013      	str	r3, [r2, #0]
        if (++count > timeout)
 8001368:	9b01      	ldr	r3, [sp, #4]
 800136a:	3301      	adds	r3, #1
 800136c:	42bb      	cmp	r3, r7
 800136e:	9301      	str	r3, [sp, #4]
 8001370:	d802      	bhi.n	8001378 <HAL_DMA_IRQHandler+0x144>
      while((hdma->Instance->CR & DMA_SxCR_EN) != RESET);
 8001372:	6813      	ldr	r3, [r2, #0]
 8001374:	07db      	lsls	r3, r3, #31
 8001376:	d4f7      	bmi.n	8001368 <HAL_DMA_IRQHandler+0x134>
      hdma->State = HAL_DMA_STATE_READY;
 8001378:	2301      	movs	r3, #1
 800137a:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35
      __HAL_UNLOCK(hdma);
 800137e:	2300      	movs	r3, #0
 8001380:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
    if(hdma->XferErrorCallback != NULL)
 8001384:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 8001386:	e7c6      	b.n	8001316 <HAL_DMA_IRQHandler+0xe2>
        if((hdma->Instance->CR & DMA_SxCR_CIRC) == RESET)
 8001388:	681a      	ldr	r2, [r3, #0]
 800138a:	f412 7280 	ands.w	r2, r2, #256	; 0x100
 800138e:	d108      	bne.n	80013a2 <HAL_DMA_IRQHandler+0x16e>
          hdma->Instance->CR  &= ~(DMA_IT_TC);
 8001390:	6819      	ldr	r1, [r3, #0]
 8001392:	f021 0110 	bic.w	r1, r1, #16
 8001396:	6019      	str	r1, [r3, #0]
          hdma->State = HAL_DMA_STATE_READY;
 8001398:	2301      	movs	r3, #1
 800139a:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35
          __HAL_UNLOCK(hdma);
 800139e:	f884 2034 	strb.w	r2, [r4, #52]	; 0x34
        if(hdma->XferCpltCallback != NULL)
 80013a2:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 80013a4:	e7cc      	b.n	8001340 <HAL_DMA_IRQHandler+0x10c>
}
 80013a6:	b003      	add	sp, #12
 80013a8:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80013aa:	bf00      	nop
 80013ac:	2000006c 	.word	0x2000006c

080013b0 <HAL_GPIO_Init>:
  * @param  GPIO_Init pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
 80013b0:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if((GPIO_Init->Mode & EXTI_MODE) != 0x00U)
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 80013b4:	f8df 91a8 	ldr.w	r9, [pc, #424]	; 8001560 <HAL_GPIO_Init+0x1b0>
        temp &= ~(0x0FU << (4U * (position & 0x03U)));
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
        SYSCFG->EXTICR[position >> 2U] = temp;

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR;
 80013b8:	4a67      	ldr	r2, [pc, #412]	; (8001558 <HAL_GPIO_Init+0x1a8>)
  for(position = 0U; position < GPIO_NUMBER; position++)
 80013ba:	2300      	movs	r3, #0
    iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;
 80013bc:	680d      	ldr	r5, [r1, #0]
    ioposition = 0x01U << position;
 80013be:	2401      	movs	r4, #1
 80013c0:	409c      	lsls	r4, r3
    iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;
 80013c2:	ea04 0c05 	and.w	ip, r4, r5
    if(iocurrent == ioposition)
 80013c6:	43ac      	bics	r4, r5
 80013c8:	f040 80b1 	bne.w	800152e <HAL_GPIO_Init+0x17e>
      if(((GPIO_Init->Mode & GPIO_MODE) == MODE_OUTPUT) || \
 80013cc:	684d      	ldr	r5, [r1, #4]
 80013ce:	f005 0403 	and.w	r4, r5, #3
 80013d2:	ea4f 0843 	mov.w	r8, r3, lsl #1
        temp &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2U));
 80013d6:	2603      	movs	r6, #3
      if(((GPIO_Init->Mode & GPIO_MODE) == MODE_OUTPUT) || \
 80013d8:	1e67      	subs	r7, r4, #1
        temp &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2U));
 80013da:	fa06 f608 	lsl.w	r6, r6, r8
      if(((GPIO_Init->Mode & GPIO_MODE) == MODE_OUTPUT) || \
 80013de:	2f01      	cmp	r7, #1
        temp &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2U));
 80013e0:	ea6f 0606 	mvn.w	r6, r6
      if(((GPIO_Init->Mode & GPIO_MODE) == MODE_OUTPUT) || \
 80013e4:	d834      	bhi.n	8001450 <HAL_GPIO_Init+0xa0>
        temp = GPIOx->OSPEEDR; 
 80013e6:	6887      	ldr	r7, [r0, #8]
        temp &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2U));
 80013e8:	ea07 0e06 	and.w	lr, r7, r6
        temp |= (GPIO_Init->Speed << (position * 2U));
 80013ec:	68cf      	ldr	r7, [r1, #12]
 80013ee:	fa07 f708 	lsl.w	r7, r7, r8
 80013f2:	ea47 070e 	orr.w	r7, r7, lr
        GPIOx->OSPEEDR = temp;
 80013f6:	6087      	str	r7, [r0, #8]
        temp = GPIOx->OTYPER;
 80013f8:	6847      	ldr	r7, [r0, #4]
        temp &= ~(GPIO_OTYPER_OT_0 << position) ;
 80013fa:	ea27 0e0c 	bic.w	lr, r7, ip
        temp |= (((GPIO_Init->Mode & OUTPUT_TYPE) >> OUTPUT_TYPE_Pos) << position);
 80013fe:	f3c5 1700 	ubfx	r7, r5, #4, #1
 8001402:	409f      	lsls	r7, r3
 8001404:	ea47 070e 	orr.w	r7, r7, lr
        GPIOx->OTYPER = temp;
 8001408:	6047      	str	r7, [r0, #4]
        temp = GPIOx->PUPDR;
 800140a:	68c7      	ldr	r7, [r0, #12]
        temp &= ~(GPIO_PUPDR_PUPDR0 << (position * 2U));
 800140c:	ea07 0e06 	and.w	lr, r7, r6
        temp |= ((GPIO_Init->Pull) << (position * 2U));
 8001410:	688f      	ldr	r7, [r1, #8]
 8001412:	fa07 f708 	lsl.w	r7, r7, r8
 8001416:	ea47 070e 	orr.w	r7, r7, lr
      if((GPIO_Init->Mode & GPIO_MODE) == MODE_AF)
 800141a:	2c02      	cmp	r4, #2
        GPIOx->PUPDR = temp;
 800141c:	60c7      	str	r7, [r0, #12]
      if((GPIO_Init->Mode & GPIO_MODE) == MODE_AF)
 800141e:	d119      	bne.n	8001454 <HAL_GPIO_Init+0xa4>
        temp = GPIOx->AFR[position >> 3U];
 8001420:	ea4f 0ad3 	mov.w	sl, r3, lsr #3
 8001424:	eb00 0a8a 	add.w	sl, r0, sl, lsl #2
        temp &= ~(0xFU << ((uint32_t)(position & 0x07U) * 4U)) ;
 8001428:	f003 0b07 	and.w	fp, r3, #7
        temp = GPIOx->AFR[position >> 3U];
 800142c:	f8da 7020 	ldr.w	r7, [sl, #32]
        temp &= ~(0xFU << ((uint32_t)(position & 0x07U) * 4U)) ;
 8001430:	ea4f 0b8b 	mov.w	fp, fp, lsl #2
 8001434:	f04f 0e0f 	mov.w	lr, #15
 8001438:	fa0e fe0b 	lsl.w	lr, lr, fp
 800143c:	ea27 0e0e 	bic.w	lr, r7, lr
        temp |= ((uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & 0x07U) * 4U));
 8001440:	690f      	ldr	r7, [r1, #16]
 8001442:	fa07 f70b 	lsl.w	r7, r7, fp
 8001446:	ea47 070e 	orr.w	r7, r7, lr
        GPIOx->AFR[position >> 3U] = temp;
 800144a:	f8ca 7020 	str.w	r7, [sl, #32]
 800144e:	e001      	b.n	8001454 <HAL_GPIO_Init+0xa4>
      if((GPIO_Init->Mode & GPIO_MODE) != MODE_ANALOG)
 8001450:	2c03      	cmp	r4, #3
 8001452:	d1da      	bne.n	800140a <HAL_GPIO_Init+0x5a>
      temp = GPIOx->MODER;
 8001454:	6807      	ldr	r7, [r0, #0]
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 8001456:	fa04 f408 	lsl.w	r4, r4, r8
      temp &= ~(GPIO_MODER_MODER0 << (position * 2U));
 800145a:	4037      	ands	r7, r6
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 800145c:	433c      	orrs	r4, r7
      if((GPIO_Init->Mode & EXTI_MODE) != 0x00U)
 800145e:	f415 3f40 	tst.w	r5, #196608	; 0x30000
      GPIOx->MODER = temp;
 8001462:	6004      	str	r4, [r0, #0]
      if((GPIO_Init->Mode & EXTI_MODE) != 0x00U)
 8001464:	d063      	beq.n	800152e <HAL_GPIO_Init+0x17e>
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8001466:	f04f 0a00 	mov.w	sl, #0
 800146a:	f8cd a004 	str.w	sl, [sp, #4]
 800146e:	f8d9 6044 	ldr.w	r6, [r9, #68]	; 0x44
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
 8001472:	4c3a      	ldr	r4, [pc, #232]	; (800155c <HAL_GPIO_Init+0x1ac>)
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8001474:	f446 4680 	orr.w	r6, r6, #16384	; 0x4000
 8001478:	f8c9 6044 	str.w	r6, [r9, #68]	; 0x44
 800147c:	f8d9 6044 	ldr.w	r6, [r9, #68]	; 0x44
 8001480:	f406 4680 	and.w	r6, r6, #16384	; 0x4000
 8001484:	9601      	str	r6, [sp, #4]
 8001486:	9e01      	ldr	r6, [sp, #4]
        temp = SYSCFG->EXTICR[position >> 2U];
 8001488:	f023 0603 	bic.w	r6, r3, #3
 800148c:	f106 4680 	add.w	r6, r6, #1073741824	; 0x40000000
 8001490:	f506 369c 	add.w	r6, r6, #79872	; 0x13800
        temp &= ~(0x0FU << (4U * (position & 0x03U)));
 8001494:	f003 0e03 	and.w	lr, r3, #3
        temp = SYSCFG->EXTICR[position >> 2U];
 8001498:	f8d6 8008 	ldr.w	r8, [r6, #8]
        temp &= ~(0x0FU << (4U * (position & 0x03U)));
 800149c:	ea4f 0e8e 	mov.w	lr, lr, lsl #2
 80014a0:	270f      	movs	r7, #15
 80014a2:	fa07 f70e 	lsl.w	r7, r7, lr
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
 80014a6:	42a0      	cmp	r0, r4
        temp &= ~(0x0FU << (4U * (position & 0x03U)));
 80014a8:	ea28 0707 	bic.w	r7, r8, r7
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
 80014ac:	d046      	beq.n	800153c <HAL_GPIO_Init+0x18c>
 80014ae:	f504 6480 	add.w	r4, r4, #1024	; 0x400
 80014b2:	42a0      	cmp	r0, r4
 80014b4:	d044      	beq.n	8001540 <HAL_GPIO_Init+0x190>
 80014b6:	f504 6480 	add.w	r4, r4, #1024	; 0x400
 80014ba:	42a0      	cmp	r0, r4
 80014bc:	d042      	beq.n	8001544 <HAL_GPIO_Init+0x194>
 80014be:	f504 6480 	add.w	r4, r4, #1024	; 0x400
 80014c2:	42a0      	cmp	r0, r4
 80014c4:	d040      	beq.n	8001548 <HAL_GPIO_Init+0x198>
 80014c6:	f504 6480 	add.w	r4, r4, #1024	; 0x400
 80014ca:	42a0      	cmp	r0, r4
 80014cc:	d03e      	beq.n	800154c <HAL_GPIO_Init+0x19c>
 80014ce:	f504 6480 	add.w	r4, r4, #1024	; 0x400
 80014d2:	42a0      	cmp	r0, r4
 80014d4:	d03c      	beq.n	8001550 <HAL_GPIO_Init+0x1a0>
 80014d6:	f504 6480 	add.w	r4, r4, #1024	; 0x400
 80014da:	42a0      	cmp	r0, r4
 80014dc:	d03a      	beq.n	8001554 <HAL_GPIO_Init+0x1a4>
 80014de:	f504 6480 	add.w	r4, r4, #1024	; 0x400
 80014e2:	42a0      	cmp	r0, r4
 80014e4:	bf0c      	ite	eq
 80014e6:	2407      	moveq	r4, #7
 80014e8:	2408      	movne	r4, #8
 80014ea:	fa04 f40e 	lsl.w	r4, r4, lr
 80014ee:	433c      	orrs	r4, r7
        SYSCFG->EXTICR[position >> 2U] = temp;
 80014f0:	60b4      	str	r4, [r6, #8]
        temp = EXTI->RTSR;
 80014f2:	6894      	ldr	r4, [r2, #8]
        temp &= ~((uint32_t)iocurrent);
 80014f4:	ea6f 060c 	mvn.w	r6, ip
        if((GPIO_Init->Mode & TRIGGER_RISING) != 0x00U)
 80014f8:	02ef      	lsls	r7, r5, #11
        temp &= ~((uint32_t)iocurrent);
 80014fa:	bf54      	ite	pl
 80014fc:	4034      	andpl	r4, r6
        {
          temp |= iocurrent;
 80014fe:	ea4c 0404 	orrmi.w	r4, ip, r4
        }
        EXTI->RTSR = temp;
 8001502:	6094      	str	r4, [r2, #8]

        temp = EXTI->FTSR;
 8001504:	68d4      	ldr	r4, [r2, #12]
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & TRIGGER_FALLING) != 0x00U)
 8001506:	02af      	lsls	r7, r5, #10
        temp &= ~((uint32_t)iocurrent);
 8001508:	bf54      	ite	pl
 800150a:	4034      	andpl	r4, r6
        {
          temp |= iocurrent;
 800150c:	ea4c 0404 	orrmi.w	r4, ip, r4
        }
        EXTI->FTSR = temp;
 8001510:	60d4      	str	r4, [r2, #12]

        temp = EXTI->EMR;
 8001512:	6854      	ldr	r4, [r2, #4]
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & EXTI_EVT) != 0x00U)
 8001514:	03af      	lsls	r7, r5, #14
        temp &= ~((uint32_t)iocurrent);
 8001516:	bf54      	ite	pl
 8001518:	4034      	andpl	r4, r6
        {
          temp |= iocurrent;
 800151a:	ea4c 0404 	orrmi.w	r4, ip, r4
        }
        EXTI->EMR = temp;
 800151e:	6054      	str	r4, [r2, #4]

        /* Clear EXTI line configuration */
        temp = EXTI->IMR;
 8001520:	6814      	ldr	r4, [r2, #0]
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & EXTI_IT) != 0x00U)
 8001522:	03ed      	lsls	r5, r5, #15
        temp &= ~((uint32_t)iocurrent);
 8001524:	bf54      	ite	pl
 8001526:	4034      	andpl	r4, r6
        {
          temp |= iocurrent;
 8001528:	ea4c 0404 	orrmi.w	r4, ip, r4
        }
        EXTI->IMR = temp;
 800152c:	6014      	str	r4, [r2, #0]
  for(position = 0U; position < GPIO_NUMBER; position++)
 800152e:	3301      	adds	r3, #1
 8001530:	2b10      	cmp	r3, #16
 8001532:	f47f af43 	bne.w	80013bc <HAL_GPIO_Init+0xc>
      }
    }
  }
}
 8001536:	b003      	add	sp, #12
 8001538:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
 800153c:	4654      	mov	r4, sl
 800153e:	e7d4      	b.n	80014ea <HAL_GPIO_Init+0x13a>
 8001540:	2401      	movs	r4, #1
 8001542:	e7d2      	b.n	80014ea <HAL_GPIO_Init+0x13a>
 8001544:	2402      	movs	r4, #2
 8001546:	e7d0      	b.n	80014ea <HAL_GPIO_Init+0x13a>
 8001548:	2403      	movs	r4, #3
 800154a:	e7ce      	b.n	80014ea <HAL_GPIO_Init+0x13a>
 800154c:	2404      	movs	r4, #4
 800154e:	e7cc      	b.n	80014ea <HAL_GPIO_Init+0x13a>
 8001550:	2405      	movs	r4, #5
 8001552:	e7ca      	b.n	80014ea <HAL_GPIO_Init+0x13a>
 8001554:	2406      	movs	r4, #6
 8001556:	e7c8      	b.n	80014ea <HAL_GPIO_Init+0x13a>
 8001558:	40013c00 	.word	0x40013c00
 800155c:	40020000 	.word	0x40020000
 8001560:	40023800 	.word	0x40023800

08001564 <HAL_GPIO_DeInit>:
  * @param  GPIO_Pin specifies the port bit to be written.
  *          This parameter can be one of GPIO_PIN_x where x can be (0..15).
  * @retval None
  */
void HAL_GPIO_DeInit(GPIO_TypeDef  *GPIOx, uint32_t GPIO_Pin)
{
 8001564:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
      tmp = SYSCFG->EXTICR[position >> 2U];
      tmp &= (0x0FU << (4U * (position & 0x03U)));
      if(tmp == ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U))))
      {
        /* Clear EXTI line configuration */
        EXTI->IMR &= ~((uint32_t)iocurrent);
 8001568:	4c43      	ldr	r4, [pc, #268]	; (8001678 <HAL_GPIO_DeInit+0x114>)
      if(tmp == ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U))))
 800156a:	f8df 9114 	ldr.w	r9, [pc, #276]	; 8001680 <HAL_GPIO_DeInit+0x11c>
 800156e:	f8df a114 	ldr.w	sl, [pc, #276]	; 8001684 <HAL_GPIO_DeInit+0x120>
 8001572:	f8df b114 	ldr.w	fp, [pc, #276]	; 8001688 <HAL_GPIO_DeInit+0x124>
  for(position = 0U; position < GPIO_NUMBER; position++)
 8001576:	2200      	movs	r2, #0
    ioposition = 0x01U << position;
 8001578:	2301      	movs	r3, #1
 800157a:	fa03 fe02 	lsl.w	lr, r3, r2
    if(iocurrent == ioposition)
 800157e:	ea3e 0501 	bics.w	r5, lr, r1
    iocurrent = (GPIO_Pin) & ioposition;
 8001582:	ea0e 0701 	and.w	r7, lr, r1
    if(iocurrent == ioposition)
 8001586:	d164      	bne.n	8001652 <HAL_GPIO_DeInit+0xee>
      tmp = SYSCFG->EXTICR[position >> 2U];
 8001588:	f022 0503 	bic.w	r5, r2, #3
 800158c:	f105 4580 	add.w	r5, r5, #1073741824	; 0x40000000
 8001590:	f505 359c 	add.w	r5, r5, #79872	; 0x13800
      if(tmp == ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U))))
 8001594:	4b39      	ldr	r3, [pc, #228]	; (800167c <HAL_GPIO_DeInit+0x118>)
      tmp = SYSCFG->EXTICR[position >> 2U];
 8001596:	f8d5 8008 	ldr.w	r8, [r5, #8]
      tmp &= (0x0FU << (4U * (position & 0x03U)));
 800159a:	f002 0c03 	and.w	ip, r2, #3
 800159e:	ea4f 0c8c 	mov.w	ip, ip, lsl #2
 80015a2:	260f      	movs	r6, #15
 80015a4:	fa06 f60c 	lsl.w	r6, r6, ip
      if(tmp == ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U))))
 80015a8:	4298      	cmp	r0, r3
      tmp &= (0x0FU << (4U * (position & 0x03U)));
 80015aa:	ea06 0808 	and.w	r8, r6, r8
      if(tmp == ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U))))
 80015ae:	d055      	beq.n	800165c <HAL_GPIO_DeInit+0xf8>
 80015b0:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 80015b4:	4298      	cmp	r0, r3
 80015b6:	d053      	beq.n	8001660 <HAL_GPIO_DeInit+0xfc>
 80015b8:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 80015bc:	4298      	cmp	r0, r3
 80015be:	d051      	beq.n	8001664 <HAL_GPIO_DeInit+0x100>
 80015c0:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 80015c4:	4298      	cmp	r0, r3
 80015c6:	d04f      	beq.n	8001668 <HAL_GPIO_DeInit+0x104>
 80015c8:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 80015cc:	4298      	cmp	r0, r3
 80015ce:	d04d      	beq.n	800166c <HAL_GPIO_DeInit+0x108>
 80015d0:	4548      	cmp	r0, r9
 80015d2:	d04d      	beq.n	8001670 <HAL_GPIO_DeInit+0x10c>
 80015d4:	4550      	cmp	r0, sl
 80015d6:	d04d      	beq.n	8001674 <HAL_GPIO_DeInit+0x110>
 80015d8:	4558      	cmp	r0, fp
 80015da:	bf0c      	ite	eq
 80015dc:	2307      	moveq	r3, #7
 80015de:	2308      	movne	r3, #8
 80015e0:	fa03 f30c 	lsl.w	r3, r3, ip
 80015e4:	4543      	cmp	r3, r8
 80015e6:	d113      	bne.n	8001610 <HAL_GPIO_DeInit+0xac>
        EXTI->IMR &= ~((uint32_t)iocurrent);
 80015e8:	6823      	ldr	r3, [r4, #0]
 80015ea:	ea23 0307 	bic.w	r3, r3, r7
 80015ee:	6023      	str	r3, [r4, #0]
        EXTI->EMR &= ~((uint32_t)iocurrent);
 80015f0:	6863      	ldr	r3, [r4, #4]
 80015f2:	ea23 0307 	bic.w	r3, r3, r7
 80015f6:	6063      	str	r3, [r4, #4]
        
        /* Clear Rising Falling edge configuration */
        EXTI->FTSR &= ~((uint32_t)iocurrent);
 80015f8:	68e3      	ldr	r3, [r4, #12]
 80015fa:	ea23 0307 	bic.w	r3, r3, r7
 80015fe:	60e3      	str	r3, [r4, #12]
        EXTI->RTSR &= ~((uint32_t)iocurrent);
 8001600:	68a3      	ldr	r3, [r4, #8]
 8001602:	ea23 0307 	bic.w	r3, r3, r7
 8001606:	60a3      	str	r3, [r4, #8]

        /* Configure the External Interrupt or event for the current IO */
        tmp = 0x0FU << (4U * (position & 0x03U));
        SYSCFG->EXTICR[position >> 2U] &= ~tmp;
 8001608:	68ab      	ldr	r3, [r5, #8]
 800160a:	ea23 0306 	bic.w	r3, r3, r6
 800160e:	60ab      	str	r3, [r5, #8]
      }

      /*------------------------- GPIO Mode Configuration --------------------*/
      /* Configure IO Direction in Input Floating Mode */
      GPIOx->MODER &= ~(GPIO_MODER_MODER0 << (position * 2U));
 8001610:	6805      	ldr	r5, [r0, #0]
 8001612:	0056      	lsls	r6, r2, #1
 8001614:	2303      	movs	r3, #3
 8001616:	40b3      	lsls	r3, r6
 8001618:	ea25 0503 	bic.w	r5, r5, r3
 800161c:	6005      	str	r5, [r0, #0]

      /* Configure the default Alternate Function in current IO */
      GPIOx->AFR[position >> 3U] &= ~(0xFU << ((uint32_t)(position & 0x07U) * 4U)) ;
 800161e:	08d5      	lsrs	r5, r2, #3
 8001620:	eb00 0585 	add.w	r5, r0, r5, lsl #2
 8001624:	f002 0c07 	and.w	ip, r2, #7
 8001628:	6a2e      	ldr	r6, [r5, #32]
 800162a:	ea4f 0c8c 	mov.w	ip, ip, lsl #2
 800162e:	270f      	movs	r7, #15
 8001630:	fa07 f70c 	lsl.w	r7, r7, ip
 8001634:	ea26 0607 	bic.w	r6, r6, r7
 8001638:	622e      	str	r6, [r5, #32]

      /* Deactivate the Pull-up and Pull-down resistor for the current IO */
      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPDR0 << (position * 2U));
 800163a:	68c5      	ldr	r5, [r0, #12]
 800163c:	ea25 0503 	bic.w	r5, r5, r3
 8001640:	60c5      	str	r5, [r0, #12]

      /* Configure the default value IO Output Type */
      GPIOx->OTYPER  &= ~(GPIO_OTYPER_OT_0 << position) ;
 8001642:	6845      	ldr	r5, [r0, #4]
 8001644:	ea25 050e 	bic.w	r5, r5, lr
 8001648:	6045      	str	r5, [r0, #4]

      /* Configure the default value for IO Speed */
      GPIOx->OSPEEDR &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2U));
 800164a:	6885      	ldr	r5, [r0, #8]
 800164c:	ea25 0303 	bic.w	r3, r5, r3
 8001650:	6083      	str	r3, [r0, #8]
  for(position = 0U; position < GPIO_NUMBER; position++)
 8001652:	3201      	adds	r2, #1
 8001654:	2a10      	cmp	r2, #16
 8001656:	d18f      	bne.n	8001578 <HAL_GPIO_DeInit+0x14>
    }
  }
}
 8001658:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      if(tmp == ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U))))
 800165c:	2300      	movs	r3, #0
 800165e:	e7bf      	b.n	80015e0 <HAL_GPIO_DeInit+0x7c>
 8001660:	2301      	movs	r3, #1
 8001662:	e7bd      	b.n	80015e0 <HAL_GPIO_DeInit+0x7c>
 8001664:	2302      	movs	r3, #2
 8001666:	e7bb      	b.n	80015e0 <HAL_GPIO_DeInit+0x7c>
 8001668:	2303      	movs	r3, #3
 800166a:	e7b9      	b.n	80015e0 <HAL_GPIO_DeInit+0x7c>
 800166c:	2304      	movs	r3, #4
 800166e:	e7b7      	b.n	80015e0 <HAL_GPIO_DeInit+0x7c>
 8001670:	2305      	movs	r3, #5
 8001672:	e7b5      	b.n	80015e0 <HAL_GPIO_DeInit+0x7c>
 8001674:	2306      	movs	r3, #6
 8001676:	e7b3      	b.n	80015e0 <HAL_GPIO_DeInit+0x7c>
 8001678:	40013c00 	.word	0x40013c00
 800167c:	40020000 	.word	0x40020000
 8001680:	40021400 	.word	0x40021400
 8001684:	40021800 	.word	0x40021800
 8001688:	40021c00 	.word	0x40021c00

0800168c <HAL_PCD_Init>:
  *         parameters in the PCD_InitTypeDef and initialize the associated handle.
  * @param  hpcd PCD handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_Init(PCD_HandleTypeDef *hpcd)
{
 800168c:	b5f0      	push	{r4, r5, r6, r7, lr}
  USB_OTG_GlobalTypeDef *USBx;
  uint8_t i;

  /* Check the PCD handle allocation */
  if (hpcd == NULL)
 800168e:	4604      	mov	r4, r0
{
 8001690:	b08b      	sub	sp, #44	; 0x2c
  if (hpcd == NULL)
 8001692:	b360      	cbz	r0, 80016ee <HAL_PCD_Init+0x62>
  /* Check the parameters */
  assert_param(IS_PCD_ALL_INSTANCE(hpcd->Instance));

  USBx = hpcd->Instance;

  if (hpcd->State == HAL_PCD_STATE_RESET)
 8001694:	f890 34bd 	ldrb.w	r3, [r0, #1213]	; 0x4bd
  USBx = hpcd->Instance;
 8001698:	6805      	ldr	r5, [r0, #0]
  if (hpcd->State == HAL_PCD_STATE_RESET)
 800169a:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 800169e:	b91b      	cbnz	r3, 80016a8 <HAL_PCD_Init+0x1c>
  {
    /* Allocate lock resource and initialize it */
    hpcd->Lock = HAL_UNLOCKED;
 80016a0:	f880 24bc 	strb.w	r2, [r0, #1212]	; 0x4bc

    /* Init the low level hardware */
    hpcd->MspInitCallback(hpcd);
#else
    /* Init the low level hardware : GPIO, CLOCK, NVIC... */
    HAL_PCD_MspInit(hpcd);
 80016a4:	f7ff f972 	bl	800098c <HAL_PCD_MspInit>
#endif /* (USE_HAL_PCD_REGISTER_CALLBACKS) */
  }

  hpcd->State = HAL_PCD_STATE_BUSY;
 80016a8:	2303      	movs	r3, #3
 80016aa:	f884 34bd 	strb.w	r3, [r4, #1213]	; 0x4bd

  /* Disable DMA mode for FS instance */
  if ((USBx->CID & (0x1U << 8)) == 0U)
 80016ae:	6beb      	ldr	r3, [r5, #60]	; 0x3c
  {
    hpcd->Init.dma_enable = 0U;
  }

  /* Disable the Interrupts */
  __HAL_PCD_DISABLE(hpcd);
 80016b0:	4625      	mov	r5, r4
  if ((USBx->CID & (0x1U << 8)) == 0U)
 80016b2:	f413 7380 	ands.w	r3, r3, #256	; 0x100
  __HAL_PCD_DISABLE(hpcd);
 80016b6:	f855 0b10 	ldr.w	r0, [r5], #16
    hpcd->Init.dma_enable = 0U;
 80016ba:	bf08      	it	eq
 80016bc:	6123      	streq	r3, [r4, #16]
  __HAL_PCD_DISABLE(hpcd);
 80016be:	f001 fd77 	bl	80031b0 <USB_DisableGlobalInt>

  /*Init the Core (common init.) */
  if (USB_CoreInit(hpcd->Instance, hpcd->Init) != HAL_OK)
 80016c2:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 80016c4:	466e      	mov	r6, sp
 80016c6:	c60f      	stmia	r6!, {r0, r1, r2, r3}
 80016c8:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 80016ca:	c60f      	stmia	r6!, {r0, r1, r2, r3}
 80016cc:	e895 0003 	ldmia.w	r5, {r0, r1}
 80016d0:	e886 0003 	stmia.w	r6, {r0, r1}
 80016d4:	4625      	mov	r5, r4
 80016d6:	1d27      	adds	r7, r4, #4
 80016d8:	e897 000e 	ldmia.w	r7, {r1, r2, r3}
 80016dc:	f855 0b10 	ldr.w	r0, [r5], #16
 80016e0:	f001 fcb0 	bl	8003044 <USB_CoreInit>
 80016e4:	4606      	mov	r6, r0
 80016e6:	b120      	cbz	r0, 80016f2 <HAL_PCD_Init+0x66>
  {
    hpcd->State = HAL_PCD_STATE_ERROR;
 80016e8:	2302      	movs	r3, #2
 80016ea:	f884 34bd 	strb.w	r3, [r4, #1213]	; 0x4bd
    return HAL_ERROR;
 80016ee:	2501      	movs	r5, #1
 80016f0:	e04e      	b.n	8001790 <HAL_PCD_Init+0x104>
    return HAL_ERROR;
  }

  /* Force Device Mode*/
  (void)USB_SetCurrentMode(hpcd->Instance, USB_DEVICE_MODE);
 80016f2:	4601      	mov	r1, r0
 80016f4:	6820      	ldr	r0, [r4, #0]
 80016f6:	f001 fd61 	bl	80031bc <USB_SetCurrentMode>

  /* Init endpoints structures */
  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 80016fa:	4630      	mov	r0, r6
 80016fc:	f8d4 c004 	ldr.w	ip, [r4, #4]
  {
    /* Init ep structure */
    hpcd->IN_ep[i].is_in = 1U;
 8001700:	2624      	movs	r6, #36	; 0x24
 8001702:	f04f 0e01 	mov.w	lr, #1
    hpcd->IN_ep[i].num = i;
    hpcd->IN_ep[i].tx_fifo_num = i;
    /* Control until ep is activated */
    hpcd->IN_ep[i].type = EP_TYPE_CTRL;
 8001706:	4601      	mov	r1, r0
 8001708:	b2c2      	uxtb	r2, r0
  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 800170a:	4594      	cmp	ip, r2
 800170c:	f100 0001 	add.w	r0, r0, #1
 8001710:	d81c      	bhi.n	800174c <HAL_PCD_Init+0xc0>
 8001712:	2300      	movs	r3, #0
    hpcd->IN_ep[i].xfer_len = 0U;
  }

  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
  {
    hpcd->OUT_ep[i].is_in = 0U;
 8001714:	2624      	movs	r6, #36	; 0x24
 8001716:	4619      	mov	r1, r3
 8001718:	b2d8      	uxtb	r0, r3
  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 800171a:	4584      	cmp	ip, r0
 800171c:	f103 0301 	add.w	r3, r3, #1
 8001720:	d822      	bhi.n	8001768 <HAL_PCD_Init+0xdc>
    hpcd->OUT_ep[i].xfer_buff = 0U;
    hpcd->OUT_ep[i].xfer_len = 0U;
  }

  /* Init Device */
  if (USB_DevInit(hpcd->Instance, hpcd->Init) != HAL_OK)
 8001722:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8001724:	466e      	mov	r6, sp
 8001726:	c60f      	stmia	r6!, {r0, r1, r2, r3}
 8001728:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 800172a:	c60f      	stmia	r6!, {r0, r1, r2, r3}
 800172c:	e895 0003 	ldmia.w	r5, {r0, r1}
 8001730:	e886 0003 	stmia.w	r6, {r0, r1}
 8001734:	e897 000e 	ldmia.w	r7, {r1, r2, r3}
 8001738:	6820      	ldr	r0, [r4, #0]
 800173a:	f001 fdc1 	bl	80032c0 <USB_DevInit>
 800173e:	2301      	movs	r3, #1
 8001740:	4605      	mov	r5, r0
 8001742:	b1f0      	cbz	r0, 8001782 <HAL_PCD_Init+0xf6>
  {
    hpcd->State = HAL_PCD_STATE_ERROR;
 8001744:	2202      	movs	r2, #2
 8001746:	f884 24bd 	strb.w	r2, [r4, #1213]	; 0x4bd
    return HAL_ERROR;
 800174a:	e7d0      	b.n	80016ee <HAL_PCD_Init+0x62>
    hpcd->IN_ep[i].is_in = 1U;
 800174c:	fb06 4302 	mla	r3, r6, r2, r4
    hpcd->IN_ep[i].xfer_buff = 0U;
 8001750:	e9c3 1112 	strd	r1, r1, [r3, #72]	; 0x48
    hpcd->IN_ep[i].is_in = 1U;
 8001754:	f883 e03d 	strb.w	lr, [r3, #61]	; 0x3d
    hpcd->IN_ep[i].num = i;
 8001758:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
    hpcd->IN_ep[i].tx_fifo_num = i;
 800175c:	f8a3 2044 	strh.w	r2, [r3, #68]	; 0x44
    hpcd->IN_ep[i].type = EP_TYPE_CTRL;
 8001760:	f883 1040 	strb.w	r1, [r3, #64]	; 0x40
    hpcd->IN_ep[i].xfer_len = 0U;
 8001764:	6559      	str	r1, [r3, #84]	; 0x54
  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 8001766:	e7cf      	b.n	8001708 <HAL_PCD_Init+0x7c>
    hpcd->OUT_ep[i].is_in = 0U;
 8001768:	fb06 4200 	mla	r2, r6, r0, r4
    hpcd->OUT_ep[i].xfer_buff = 0U;
 800176c:	e9c2 11a2 	strd	r1, r1, [r2, #648]	; 0x288
    hpcd->OUT_ep[i].is_in = 0U;
 8001770:	f882 127d 	strb.w	r1, [r2, #637]	; 0x27d
    hpcd->OUT_ep[i].num = i;
 8001774:	f882 027c 	strb.w	r0, [r2, #636]	; 0x27c
    hpcd->OUT_ep[i].type = EP_TYPE_CTRL;
 8001778:	f882 1280 	strb.w	r1, [r2, #640]	; 0x280
    hpcd->OUT_ep[i].xfer_len = 0U;
 800177c:	f8c2 1294 	str.w	r1, [r2, #660]	; 0x294
  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 8001780:	e7ca      	b.n	8001718 <HAL_PCD_Init+0x8c>
  }

  hpcd->USB_Address = 0U;
 8001782:	f884 0038 	strb.w	r0, [r4, #56]	; 0x38
  if (hpcd->Init.lpm_enable == 1U)
  {
    (void)HAL_PCDEx_ActivateLPM(hpcd);
  }
#endif /* defined(STM32F446xx) || defined(STM32F469xx) || defined(STM32F479xx) || defined(STM32F412Zx) || defined(STM32F412Vx) || defined(STM32F412Rx) || defined(STM32F412Cx) || defined(STM32F413xx) || defined(STM32F423xx) */
  (void)USB_DevDisconnect(hpcd->Instance);
 8001786:	6820      	ldr	r0, [r4, #0]
  hpcd->State = HAL_PCD_STATE_READY;
 8001788:	f884 34bd 	strb.w	r3, [r4, #1213]	; 0x4bd
  (void)USB_DevDisconnect(hpcd->Instance);
 800178c:	f002 f93e 	bl	8003a0c <USB_DevDisconnect>

  return HAL_OK;
}
 8001790:	4628      	mov	r0, r5
 8001792:	b00b      	add	sp, #44	; 0x2c
 8001794:	bdf0      	pop	{r4, r5, r6, r7, pc}

08001796 <HAL_PCD_Start>:
  * @brief  Start the USB device
  * @param  hpcd PCD handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_Start(PCD_HandleTypeDef *hpcd)
{
 8001796:	b510      	push	{r4, lr}
 8001798:	4604      	mov	r4, r0
  USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;
 800179a:	6800      	ldr	r0, [r0, #0]

  __HAL_LOCK(hpcd);
 800179c:	f894 34bc 	ldrb.w	r3, [r4, #1212]	; 0x4bc
 80017a0:	2b01      	cmp	r3, #1
 80017a2:	d015      	beq.n	80017d0 <HAL_PCD_Start+0x3a>
 80017a4:	2301      	movs	r3, #1
 80017a6:	f884 34bc 	strb.w	r3, [r4, #1212]	; 0x4bc

  if ((hpcd->Init.battery_charging_enable == 1U) &&
 80017aa:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 80017ac:	2b01      	cmp	r3, #1
 80017ae:	d106      	bne.n	80017be <HAL_PCD_Start+0x28>
 80017b0:	69a3      	ldr	r3, [r4, #24]
 80017b2:	2b01      	cmp	r3, #1
      (hpcd->Init.phy_itface != USB_OTG_ULPI_PHY))
  {
    /* Enable USB Transceiver */
    USBx->GCCFG |= USB_OTG_GCCFG_PWRDWN;
 80017b4:	bf1e      	ittt	ne
 80017b6:	6b83      	ldrne	r3, [r0, #56]	; 0x38
 80017b8:	f443 3380 	orrne.w	r3, r3, #65536	; 0x10000
 80017bc:	6383      	strne	r3, [r0, #56]	; 0x38
  }

  __HAL_PCD_ENABLE(hpcd);
 80017be:	f001 fcf1 	bl	80031a4 <USB_EnableGlobalInt>
  (void)USB_DevConnect(hpcd->Instance);
 80017c2:	6820      	ldr	r0, [r4, #0]
 80017c4:	f002 f914 	bl	80039f0 <USB_DevConnect>
  __HAL_UNLOCK(hpcd);
 80017c8:	2000      	movs	r0, #0
 80017ca:	f884 04bc 	strb.w	r0, [r4, #1212]	; 0x4bc

  return HAL_OK;
}
 80017ce:	bd10      	pop	{r4, pc}
  __HAL_LOCK(hpcd);
 80017d0:	2002      	movs	r0, #2
 80017d2:	e7fc      	b.n	80017ce <HAL_PCD_Start+0x38>

080017d4 <HAL_PCD_SetAddress>:
  * @param  hpcd PCD handle
  * @param  address new device address
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_SetAddress(PCD_HandleTypeDef *hpcd, uint8_t address)
{
 80017d4:	b510      	push	{r4, lr}
  __HAL_LOCK(hpcd);
 80017d6:	f890 24bc 	ldrb.w	r2, [r0, #1212]	; 0x4bc
 80017da:	2a01      	cmp	r2, #1
{
 80017dc:	4604      	mov	r4, r0
  __HAL_LOCK(hpcd);
 80017de:	d00b      	beq.n	80017f8 <HAL_PCD_SetAddress+0x24>
 80017e0:	2201      	movs	r2, #1
 80017e2:	f880 24bc 	strb.w	r2, [r0, #1212]	; 0x4bc
  hpcd->USB_Address = address;
 80017e6:	f880 1038 	strb.w	r1, [r0, #56]	; 0x38
  (void)USB_SetDevAddress(hpcd->Instance, address);
 80017ea:	6800      	ldr	r0, [r0, #0]
 80017ec:	f002 f8f0 	bl	80039d0 <USB_SetDevAddress>
  __HAL_UNLOCK(hpcd);
 80017f0:	2000      	movs	r0, #0
 80017f2:	f884 04bc 	strb.w	r0, [r4, #1212]	; 0x4bc

  return HAL_OK;
}
 80017f6:	bd10      	pop	{r4, pc}
  __HAL_LOCK(hpcd);
 80017f8:	2002      	movs	r0, #2
 80017fa:	e7fc      	b.n	80017f6 <HAL_PCD_SetAddress+0x22>

080017fc <HAL_PCD_EP_Open>:
  * @param  ep_type endpoint type
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_EP_Open(PCD_HandleTypeDef *hpcd, uint8_t ep_addr,
                                  uint16_t ep_mps, uint8_t ep_type)
{
 80017fc:	b570      	push	{r4, r5, r6, lr}
 80017fe:	f001 060f 	and.w	r6, r1, #15
 8001802:	eb06 04c6 	add.w	r4, r6, r6, lsl #3
  HAL_StatusTypeDef  ret = HAL_OK;
  PCD_EPTypeDef *ep;

  if ((ep_addr & 0x80U) == 0x80U)
 8001806:	f011 0f80 	tst.w	r1, #128	; 0x80
{
 800180a:	4605      	mov	r5, r0
 800180c:	ea4f 0484 	mov.w	r4, r4, lsl #2
 8001810:	f04f 0024 	mov.w	r0, #36	; 0x24
  if ((ep_addr & 0x80U) == 0x80U)
 8001814:	d01f      	beq.n	8001856 <HAL_PCD_EP_Open+0x5a>
  {
    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
    ep->is_in = 1U;
 8001816:	fb00 5006 	mla	r0, r0, r6, r5
    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 800181a:	f104 013c 	add.w	r1, r4, #60	; 0x3c
    ep->is_in = 1U;
 800181e:	2401      	movs	r4, #1
    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 8001820:	4429      	add	r1, r5
    ep->is_in = 1U;
 8001822:	f880 403d 	strb.w	r4, [r0, #61]	; 0x3d
    ep = &hpcd->OUT_ep[ep_addr & EP_ADDR_MSK];
    ep->is_in = 0U;
  }

  ep->num = ep_addr & EP_ADDR_MSK;
  ep->maxpacket = ep_mps;
 8001826:	60ca      	str	r2, [r1, #12]
  ep->type = ep_type;

  if (ep->is_in != 0U)
 8001828:	784a      	ldrb	r2, [r1, #1]
  ep->num = ep_addr & EP_ADDR_MSK;
 800182a:	700e      	strb	r6, [r1, #0]
  ep->type = ep_type;
 800182c:	710b      	strb	r3, [r1, #4]
  if (ep->is_in != 0U)
 800182e:	b102      	cbz	r2, 8001832 <HAL_PCD_EP_Open+0x36>
  {
    /* Assign a Tx FIFO */
    ep->tx_fifo_num = ep->num;
 8001830:	810e      	strh	r6, [r1, #8]
  }
  /* Set initial data PID. */
  if (ep_type == EP_TYPE_BULK)
 8001832:	2b02      	cmp	r3, #2
  {
    ep->data_pid_start = 0U;
 8001834:	bf04      	itt	eq
 8001836:	2300      	moveq	r3, #0
 8001838:	714b      	strbeq	r3, [r1, #5]
  }

  __HAL_LOCK(hpcd);
 800183a:	f895 34bc 	ldrb.w	r3, [r5, #1212]	; 0x4bc
 800183e:	2b01      	cmp	r3, #1
 8001840:	d012      	beq.n	8001868 <HAL_PCD_EP_Open+0x6c>
 8001842:	2301      	movs	r3, #1
  (void)USB_ActivateEndpoint(hpcd->Instance, ep);
 8001844:	6828      	ldr	r0, [r5, #0]
  __HAL_LOCK(hpcd);
 8001846:	f885 34bc 	strb.w	r3, [r5, #1212]	; 0x4bc
  (void)USB_ActivateEndpoint(hpcd->Instance, ep);
 800184a:	f001 fdfc 	bl	8003446 <USB_ActivateEndpoint>
  __HAL_UNLOCK(hpcd);
 800184e:	2000      	movs	r0, #0
 8001850:	f885 04bc 	strb.w	r0, [r5, #1212]	; 0x4bc

  return ret;
}
 8001854:	bd70      	pop	{r4, r5, r6, pc}
    ep->is_in = 0U;
 8001856:	fb00 5006 	mla	r0, r0, r6, r5
    ep = &hpcd->OUT_ep[ep_addr & EP_ADDR_MSK];
 800185a:	f504 711f 	add.w	r1, r4, #636	; 0x27c
    ep->is_in = 0U;
 800185e:	2400      	movs	r4, #0
    ep = &hpcd->OUT_ep[ep_addr & EP_ADDR_MSK];
 8001860:	4429      	add	r1, r5
    ep->is_in = 0U;
 8001862:	f880 427d 	strb.w	r4, [r0, #637]	; 0x27d
 8001866:	e7de      	b.n	8001826 <HAL_PCD_EP_Open+0x2a>
  __HAL_LOCK(hpcd);
 8001868:	2002      	movs	r0, #2
 800186a:	e7f3      	b.n	8001854 <HAL_PCD_EP_Open+0x58>

0800186c <HAL_PCD_EP_Close>:
  * @param  hpcd PCD handle
  * @param  ep_addr endpoint address
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_EP_Close(PCD_HandleTypeDef *hpcd, uint8_t ep_addr)
{
 800186c:	b510      	push	{r4, lr}
 800186e:	4604      	mov	r4, r0
 8001870:	f001 000f 	and.w	r0, r1, #15
 8001874:	eb00 03c0 	add.w	r3, r0, r0, lsl #3
  PCD_EPTypeDef *ep;

  if ((ep_addr & 0x80U) == 0x80U)
 8001878:	f011 0f80 	tst.w	r1, #128	; 0x80
 800187c:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8001880:	f04f 0224 	mov.w	r2, #36	; 0x24
 8001884:	d016      	beq.n	80018b4 <HAL_PCD_EP_Close+0x48>
  {
    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
    ep->is_in = 1U;
 8001886:	fb02 4200 	mla	r2, r2, r0, r4
    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 800188a:	f103 013c 	add.w	r1, r3, #60	; 0x3c
    ep->is_in = 1U;
 800188e:	2301      	movs	r3, #1
    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 8001890:	4421      	add	r1, r4
    ep->is_in = 1U;
 8001892:	f882 303d 	strb.w	r3, [r2, #61]	; 0x3d
  else
  {
    ep = &hpcd->OUT_ep[ep_addr & EP_ADDR_MSK];
    ep->is_in = 0U;
  }
  ep->num   = ep_addr & EP_ADDR_MSK;
 8001896:	7008      	strb	r0, [r1, #0]

  __HAL_LOCK(hpcd);
 8001898:	f894 34bc 	ldrb.w	r3, [r4, #1212]	; 0x4bc
 800189c:	2b01      	cmp	r3, #1
 800189e:	d012      	beq.n	80018c6 <HAL_PCD_EP_Close+0x5a>
 80018a0:	2301      	movs	r3, #1
  (void)USB_DeactivateEndpoint(hpcd->Instance, ep);
 80018a2:	6820      	ldr	r0, [r4, #0]
  __HAL_LOCK(hpcd);
 80018a4:	f884 34bc 	strb.w	r3, [r4, #1212]	; 0x4bc
  (void)USB_DeactivateEndpoint(hpcd->Instance, ep);
 80018a8:	f001 fe0c 	bl	80034c4 <USB_DeactivateEndpoint>
  __HAL_UNLOCK(hpcd);
 80018ac:	2000      	movs	r0, #0
 80018ae:	f884 04bc 	strb.w	r0, [r4, #1212]	; 0x4bc
  return HAL_OK;
}
 80018b2:	bd10      	pop	{r4, pc}
    ep->is_in = 0U;
 80018b4:	fb02 4200 	mla	r2, r2, r0, r4
    ep = &hpcd->OUT_ep[ep_addr & EP_ADDR_MSK];
 80018b8:	f503 711f 	add.w	r1, r3, #636	; 0x27c
    ep->is_in = 0U;
 80018bc:	2300      	movs	r3, #0
    ep = &hpcd->OUT_ep[ep_addr & EP_ADDR_MSK];
 80018be:	4421      	add	r1, r4
    ep->is_in = 0U;
 80018c0:	f882 327d 	strb.w	r3, [r2, #637]	; 0x27d
 80018c4:	e7e7      	b.n	8001896 <HAL_PCD_EP_Close+0x2a>
  __HAL_LOCK(hpcd);
 80018c6:	2002      	movs	r0, #2
 80018c8:	e7f3      	b.n	80018b2 <HAL_PCD_EP_Close+0x46>

080018ca <HAL_PCD_EP_Receive>:
  * @param  pBuf pointer to the reception buffer
  * @param  len amount of data to be received
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_EP_Receive(PCD_HandleTypeDef *hpcd, uint8_t ep_addr, uint8_t *pBuf, uint32_t len)
{
 80018ca:	b538      	push	{r3, r4, r5, lr}
 80018cc:	f001 050f 	and.w	r5, r1, #15
  PCD_EPTypeDef *ep;

  ep = &hpcd->OUT_ep[ep_addr & EP_ADDR_MSK];
 80018d0:	2424      	movs	r4, #36	; 0x24
 80018d2:	fb04 0105 	mla	r1, r4, r5, r0

  /*setup and start the Xfer */
  ep->xfer_buff = pBuf;
 80018d6:	fb04 0405 	mla	r4, r4, r5, r0
  ep = &hpcd->OUT_ep[ep_addr & EP_ADDR_MSK];
 80018da:	f501 711f 	add.w	r1, r1, #636	; 0x27c
  ep->xfer_len = len;
 80018de:	f8c4 3294 	str.w	r3, [r4, #660]	; 0x294
  ep->xfer_count = 0U;
 80018e2:	2300      	movs	r3, #0
  ep->xfer_buff = pBuf;
 80018e4:	f8c4 228c 	str.w	r2, [r4, #652]	; 0x28c
  ep->xfer_count = 0U;
 80018e8:	f8c4 329c 	str.w	r3, [r4, #668]	; 0x29c
  ep->is_in = 0U;
 80018ec:	f884 327d 	strb.w	r3, [r4, #637]	; 0x27d
  ep->num = ep_addr & EP_ADDR_MSK;
 80018f0:	f884 527c 	strb.w	r5, [r4, #636]	; 0x27c

  if (hpcd->Init.dma_enable == 1U)
 80018f4:	6903      	ldr	r3, [r0, #16]
    ep->dma_addr = (uint32_t)pBuf;
  }

  if ((ep_addr & EP_ADDR_MSK) == 0U)
  {
    (void)USB_EP0StartXfer(hpcd->Instance, ep, (uint8_t)hpcd->Init.dma_enable);
 80018f6:	6800      	ldr	r0, [r0, #0]
  if (hpcd->Init.dma_enable == 1U)
 80018f8:	2b01      	cmp	r3, #1
    ep->dma_addr = (uint32_t)pBuf;
 80018fa:	bf08      	it	eq
 80018fc:	f8c4 2290 	streq.w	r2, [r4, #656]	; 0x290
    (void)USB_EP0StartXfer(hpcd->Instance, ep, (uint8_t)hpcd->Init.dma_enable);
 8001900:	b2da      	uxtb	r2, r3
  if ((ep_addr & EP_ADDR_MSK) == 0U)
 8001902:	b91d      	cbnz	r5, 800190c <HAL_PCD_EP_Receive+0x42>
    (void)USB_EP0StartXfer(hpcd->Instance, ep, (uint8_t)hpcd->Init.dma_enable);
 8001904:	f001 fe34 	bl	8003570 <USB_EP0StartXfer>
  {
    (void)USB_EPStartXfer(hpcd->Instance, ep, (uint8_t)hpcd->Init.dma_enable);
  }

  return HAL_OK;
}
 8001908:	2000      	movs	r0, #0
 800190a:	bd38      	pop	{r3, r4, r5, pc}
    (void)USB_EPStartXfer(hpcd->Instance, ep, (uint8_t)hpcd->Init.dma_enable);
 800190c:	f001 ff02 	bl	8003714 <USB_EPStartXfer>
 8001910:	e7fa      	b.n	8001908 <HAL_PCD_EP_Receive+0x3e>

08001912 <HAL_PCD_EP_GetRxCount>:
  * @param  ep_addr endpoint address
  * @retval Data Size
  */
uint32_t HAL_PCD_EP_GetRxCount(PCD_HandleTypeDef *hpcd, uint8_t ep_addr)
{
  return hpcd->OUT_ep[ep_addr & EP_ADDR_MSK].xfer_count;
 8001912:	f001 010f 	and.w	r1, r1, #15
 8001916:	2324      	movs	r3, #36	; 0x24
 8001918:	fb03 0001 	mla	r0, r3, r1, r0
}
 800191c:	f8d0 029c 	ldr.w	r0, [r0, #668]	; 0x29c
 8001920:	4770      	bx	lr

08001922 <HAL_PCD_EP_Transmit>:
  * @param  pBuf pointer to the transmission buffer
  * @param  len amount of data to be sent
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_EP_Transmit(PCD_HandleTypeDef *hpcd, uint8_t ep_addr, uint8_t *pBuf, uint32_t len)
{
 8001922:	b538      	push	{r3, r4, r5, lr}
 8001924:	f001 050f 	and.w	r5, r1, #15
  PCD_EPTypeDef *ep;

  ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 8001928:	2424      	movs	r4, #36	; 0x24
 800192a:	fb04 0105 	mla	r1, r4, r5, r0

  /*setup and start the Xfer */
  ep->xfer_buff = pBuf;
 800192e:	fb04 0405 	mla	r4, r4, r5, r0
  ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 8001932:	313c      	adds	r1, #60	; 0x3c
  ep->xfer_len = len;
 8001934:	6563      	str	r3, [r4, #84]	; 0x54
  ep->xfer_count = 0U;
 8001936:	2300      	movs	r3, #0
 8001938:	65e3      	str	r3, [r4, #92]	; 0x5c
  ep->is_in = 1U;
 800193a:	2301      	movs	r3, #1
  ep->xfer_buff = pBuf;
 800193c:	64e2      	str	r2, [r4, #76]	; 0x4c
  ep->is_in = 1U;
 800193e:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
  ep->num = ep_addr & EP_ADDR_MSK;
 8001942:	f884 503c 	strb.w	r5, [r4, #60]	; 0x3c

  if (hpcd->Init.dma_enable == 1U)
 8001946:	6903      	ldr	r3, [r0, #16]
    ep->dma_addr = (uint32_t)pBuf;
  }

  if ((ep_addr & EP_ADDR_MSK) == 0U)
  {
    (void)USB_EP0StartXfer(hpcd->Instance, ep, (uint8_t)hpcd->Init.dma_enable);
 8001948:	6800      	ldr	r0, [r0, #0]
  if (hpcd->Init.dma_enable == 1U)
 800194a:	2b01      	cmp	r3, #1
    ep->dma_addr = (uint32_t)pBuf;
 800194c:	bf08      	it	eq
 800194e:	6522      	streq	r2, [r4, #80]	; 0x50
    (void)USB_EP0StartXfer(hpcd->Instance, ep, (uint8_t)hpcd->Init.dma_enable);
 8001950:	b2da      	uxtb	r2, r3
  if ((ep_addr & EP_ADDR_MSK) == 0U)
 8001952:	b91d      	cbnz	r5, 800195c <HAL_PCD_EP_Transmit+0x3a>
    (void)USB_EP0StartXfer(hpcd->Instance, ep, (uint8_t)hpcd->Init.dma_enable);
 8001954:	f001 fe0c 	bl	8003570 <USB_EP0StartXfer>
  {
    (void)USB_EPStartXfer(hpcd->Instance, ep, (uint8_t)hpcd->Init.dma_enable);
  }

  return HAL_OK;
}
 8001958:	2000      	movs	r0, #0
 800195a:	bd38      	pop	{r3, r4, r5, pc}
    (void)USB_EPStartXfer(hpcd->Instance, ep, (uint8_t)hpcd->Init.dma_enable);
 800195c:	f001 feda 	bl	8003714 <USB_EPStartXfer>
 8001960:	e7fa      	b.n	8001958 <HAL_PCD_EP_Transmit+0x36>

08001962 <HAL_PCD_EP_SetStall>:
  * @param  hpcd PCD handle
  * @param  ep_addr endpoint address
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_EP_SetStall(PCD_HandleTypeDef *hpcd, uint8_t ep_addr)
{
 8001962:	b538      	push	{r3, r4, r5, lr}
  PCD_EPTypeDef *ep;

  if (((uint32_t)ep_addr & EP_ADDR_MSK) > hpcd->Init.dev_endpoints)
 8001964:	6843      	ldr	r3, [r0, #4]
 8001966:	f001 050f 	and.w	r5, r1, #15
 800196a:	429d      	cmp	r5, r3
{
 800196c:	4604      	mov	r4, r0
  if (((uint32_t)ep_addr & EP_ADDR_MSK) > hpcd->Init.dev_endpoints)
 800196e:	d82e      	bhi.n	80019ce <HAL_PCD_EP_SetStall+0x6c>
  {
    return HAL_ERROR;
  }

  if ((0x80U & ep_addr) == 0x80U)
 8001970:	f011 0f80 	tst.w	r1, #128	; 0x80
 8001974:	f04f 0224 	mov.w	r2, #36	; 0x24
 8001978:	d01f      	beq.n	80019ba <HAL_PCD_EP_SetStall+0x58>
  {
    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 800197a:	fb02 0305 	mla	r3, r2, r5, r0
    ep->is_in = 1U;
 800197e:	fb02 0205 	mla	r2, r2, r5, r0
 8001982:	2101      	movs	r1, #1
    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 8001984:	333c      	adds	r3, #60	; 0x3c
    ep->is_in = 1U;
 8001986:	f882 103d 	strb.w	r1, [r2, #61]	; 0x3d
  {
    ep = &hpcd->OUT_ep[ep_addr];
    ep->is_in = 0U;
  }

  ep->is_stall = 1U;
 800198a:	2201      	movs	r2, #1
 800198c:	709a      	strb	r2, [r3, #2]
  ep->num = ep_addr & EP_ADDR_MSK;
 800198e:	701d      	strb	r5, [r3, #0]

  __HAL_LOCK(hpcd);
 8001990:	f894 14bc 	ldrb.w	r1, [r4, #1212]	; 0x4bc
 8001994:	4291      	cmp	r1, r2
 8001996:	d01c      	beq.n	80019d2 <HAL_PCD_EP_SetStall+0x70>

  (void)USB_EPSetStall(hpcd->Instance, ep);
 8001998:	6820      	ldr	r0, [r4, #0]
  __HAL_LOCK(hpcd);
 800199a:	f884 24bc 	strb.w	r2, [r4, #1212]	; 0x4bc
  (void)USB_EPSetStall(hpcd->Instance, ep);
 800199e:	4619      	mov	r1, r3
 80019a0:	f001 ffc2 	bl	8003928 <USB_EPSetStall>

  if ((ep_addr & EP_ADDR_MSK) == 0U)
 80019a4:	b92d      	cbnz	r5, 80019b2 <HAL_PCD_EP_SetStall+0x50>
  {
    (void)USB_EP0_OutStart(hpcd->Instance, (uint8_t)hpcd->Init.dma_enable, (uint8_t *)hpcd->Setup);
 80019a6:	7c21      	ldrb	r1, [r4, #16]
 80019a8:	6820      	ldr	r0, [r4, #0]
 80019aa:	f204 42c4 	addw	r2, r4, #1220	; 0x4c4
 80019ae:	f002 f87d 	bl	8003aac <USB_EP0_OutStart>
  }

  __HAL_UNLOCK(hpcd);
 80019b2:	2000      	movs	r0, #0
 80019b4:	f884 04bc 	strb.w	r0, [r4, #1212]	; 0x4bc

  return HAL_OK;
}
 80019b8:	bd38      	pop	{r3, r4, r5, pc}
    ep = &hpcd->OUT_ep[ep_addr];
 80019ba:	fb02 0301 	mla	r3, r2, r1, r0
    ep->is_in = 0U;
 80019be:	fb02 0101 	mla	r1, r2, r1, r0
 80019c2:	2200      	movs	r2, #0
    ep = &hpcd->OUT_ep[ep_addr];
 80019c4:	f503 731f 	add.w	r3, r3, #636	; 0x27c
    ep->is_in = 0U;
 80019c8:	f881 227d 	strb.w	r2, [r1, #637]	; 0x27d
 80019cc:	e7dd      	b.n	800198a <HAL_PCD_EP_SetStall+0x28>
    return HAL_ERROR;
 80019ce:	2001      	movs	r0, #1
 80019d0:	e7f2      	b.n	80019b8 <HAL_PCD_EP_SetStall+0x56>
  __HAL_LOCK(hpcd);
 80019d2:	2002      	movs	r0, #2
 80019d4:	e7f0      	b.n	80019b8 <HAL_PCD_EP_SetStall+0x56>

080019d6 <HAL_PCD_EP_ClrStall>:
  * @param  hpcd PCD handle
  * @param  ep_addr endpoint address
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_EP_ClrStall(PCD_HandleTypeDef *hpcd, uint8_t ep_addr)
{
 80019d6:	b538      	push	{r3, r4, r5, lr}
  PCD_EPTypeDef *ep;

  if (((uint32_t)ep_addr & 0x0FU) > hpcd->Init.dev_endpoints)
 80019d8:	6843      	ldr	r3, [r0, #4]
 80019da:	f001 020f 	and.w	r2, r1, #15
 80019de:	429a      	cmp	r2, r3
{
 80019e0:	4604      	mov	r4, r0
  if (((uint32_t)ep_addr & 0x0FU) > hpcd->Init.dev_endpoints)
 80019e2:	d82a      	bhi.n	8001a3a <HAL_PCD_EP_ClrStall+0x64>
  {
    return HAL_ERROR;
  }

  if ((0x80U & ep_addr) == 0x80U)
 80019e4:	eb02 03c2 	add.w	r3, r2, r2, lsl #3
 80019e8:	f011 0f80 	tst.w	r1, #128	; 0x80
 80019ec:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80019f0:	f04f 0024 	mov.w	r0, #36	; 0x24
 80019f4:	d018      	beq.n	8001a28 <HAL_PCD_EP_ClrStall+0x52>
  {
    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
    ep->is_in = 1U;
 80019f6:	fb00 4002 	mla	r0, r0, r2, r4
    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 80019fa:	f103 013c 	add.w	r1, r3, #60	; 0x3c
    ep->is_in = 1U;
 80019fe:	2301      	movs	r3, #1
    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 8001a00:	4421      	add	r1, r4
    ep->is_in = 1U;
 8001a02:	f880 303d 	strb.w	r3, [r0, #61]	; 0x3d
  {
    ep = &hpcd->OUT_ep[ep_addr & EP_ADDR_MSK];
    ep->is_in = 0U;
  }

  ep->is_stall = 0U;
 8001a06:	2500      	movs	r5, #0
 8001a08:	708d      	strb	r5, [r1, #2]
  ep->num = ep_addr & EP_ADDR_MSK;
 8001a0a:	700a      	strb	r2, [r1, #0]

  __HAL_LOCK(hpcd);
 8001a0c:	f894 34bc 	ldrb.w	r3, [r4, #1212]	; 0x4bc
 8001a10:	2b01      	cmp	r3, #1
 8001a12:	d014      	beq.n	8001a3e <HAL_PCD_EP_ClrStall+0x68>
 8001a14:	2301      	movs	r3, #1
  (void)USB_EPClearStall(hpcd->Instance, ep);
 8001a16:	6820      	ldr	r0, [r4, #0]
  __HAL_LOCK(hpcd);
 8001a18:	f884 34bc 	strb.w	r3, [r4, #1212]	; 0x4bc
  (void)USB_EPClearStall(hpcd->Instance, ep);
 8001a1c:	f001 ffaf 	bl	800397e <USB_EPClearStall>
  __HAL_UNLOCK(hpcd);
 8001a20:	f884 54bc 	strb.w	r5, [r4, #1212]	; 0x4bc

  return HAL_OK;
 8001a24:	4628      	mov	r0, r5
}
 8001a26:	bd38      	pop	{r3, r4, r5, pc}
    ep->is_in = 0U;
 8001a28:	fb00 4002 	mla	r0, r0, r2, r4
    ep = &hpcd->OUT_ep[ep_addr & EP_ADDR_MSK];
 8001a2c:	f503 711f 	add.w	r1, r3, #636	; 0x27c
    ep->is_in = 0U;
 8001a30:	2300      	movs	r3, #0
    ep = &hpcd->OUT_ep[ep_addr & EP_ADDR_MSK];
 8001a32:	4421      	add	r1, r4
    ep->is_in = 0U;
 8001a34:	f880 327d 	strb.w	r3, [r0, #637]	; 0x27d
 8001a38:	e7e5      	b.n	8001a06 <HAL_PCD_EP_ClrStall+0x30>
    return HAL_ERROR;
 8001a3a:	2001      	movs	r0, #1
 8001a3c:	e7f3      	b.n	8001a26 <HAL_PCD_EP_ClrStall+0x50>
  __HAL_LOCK(hpcd);
 8001a3e:	2002      	movs	r0, #2
 8001a40:	e7f1      	b.n	8001a26 <HAL_PCD_EP_ClrStall+0x50>

08001a42 <HAL_PCD_EP_Abort>:
HAL_StatusTypeDef HAL_PCD_EP_Abort(PCD_HandleTypeDef *hpcd, uint8_t ep_addr)
{
  HAL_StatusTypeDef ret;
  PCD_EPTypeDef *ep;

  if ((0x80U & ep_addr) == 0x80U)
 8001a42:	f001 030f 	and.w	r3, r1, #15
 8001a46:	eb03 03c3 	add.w	r3, r3, r3, lsl #3
 8001a4a:	060a      	lsls	r2, r1, #24
  {
    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 8001a4c:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8001a50:	bf4c      	ite	mi
 8001a52:	f103 013c 	addmi.w	r1, r3, #60	; 0x3c
  }
  else
  {
    ep = &hpcd->OUT_ep[ep_addr & EP_ADDR_MSK];
 8001a56:	f503 711f 	addpl.w	r1, r3, #636	; 0x27c
 8001a5a:	4401      	add	r1, r0
  }

  /* Stop Xfer */
  ret = USB_EPStopXfer(hpcd->Instance, ep);
 8001a5c:	6800      	ldr	r0, [r0, #0]
 8001a5e:	f001 be03 	b.w	8003668 <USB_EPStopXfer>
	...

08001a64 <HAL_PCD_IRQHandler>:
{
 8001a64:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;
 8001a68:	6806      	ldr	r6, [r0, #0]
{
 8001a6a:	b089      	sub	sp, #36	; 0x24
 8001a6c:	4604      	mov	r4, r0
  if (USB_GetMode(hpcd->Instance) == USB_OTG_MODE_DEVICE)
 8001a6e:	4630      	mov	r0, r6
 8001a70:	f002 f808 	bl	8003a84 <USB_GetMode>
 8001a74:	9003      	str	r0, [sp, #12]
 8001a76:	2800      	cmp	r0, #0
 8001a78:	f040 8157 	bne.w	8001d2a <HAL_PCD_IRQHandler+0x2c6>
    if (__HAL_PCD_IS_INVALID_INTERRUPT(hpcd))
 8001a7c:	6820      	ldr	r0, [r4, #0]
 8001a7e:	f001 ffd3 	bl	8003a28 <USB_ReadInterrupts>
 8001a82:	2800      	cmp	r0, #0
 8001a84:	f000 8151 	beq.w	8001d2a <HAL_PCD_IRQHandler+0x2c6>
    hpcd->FrameNumber = (USBx_DEVICE->DSTS & USB_OTG_DSTS_FNSOF_Msk) >> USB_OTG_DSTS_FNSOF_Pos;
 8001a88:	f8d6 3808 	ldr.w	r3, [r6, #2056]	; 0x808
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_MMIS))
 8001a8c:	6820      	ldr	r0, [r4, #0]
    hpcd->FrameNumber = (USBx_DEVICE->DSTS & USB_OTG_DSTS_FNSOF_Msk) >> USB_OTG_DSTS_FNSOF_Pos;
 8001a8e:	f3c3 230d 	ubfx	r3, r3, #8, #14
 8001a92:	f8c4 34fc 	str.w	r3, [r4, #1276]	; 0x4fc
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_MMIS))
 8001a96:	f001 ffc7 	bl	8003a28 <USB_ReadInterrupts>
 8001a9a:	0787      	lsls	r7, r0, #30
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_MMIS);
 8001a9c:	bf48      	it	mi
 8001a9e:	6822      	ldrmi	r2, [r4, #0]
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_RXFLVL))
 8001aa0:	6820      	ldr	r0, [r4, #0]
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_MMIS);
 8001aa2:	bf42      	ittt	mi
 8001aa4:	6953      	ldrmi	r3, [r2, #20]
 8001aa6:	f003 0302 	andmi.w	r3, r3, #2
 8001aaa:	6153      	strmi	r3, [r2, #20]
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_RXFLVL))
 8001aac:	f001 ffbc 	bl	8003a28 <USB_ReadInterrupts>
 8001ab0:	06c0      	lsls	r0, r0, #27
    hpcd->FrameNumber = (USBx_DEVICE->DSTS & USB_OTG_DSTS_FNSOF_Msk) >> USB_OTG_DSTS_FNSOF_Pos;
 8001ab2:	f506 6500 	add.w	r5, r6, #2048	; 0x800
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_RXFLVL))
 8001ab6:	d52c      	bpl.n	8001b12 <HAL_PCD_IRQHandler+0xae>
      USB_MASK_INTERRUPT(hpcd->Instance, USB_OTG_GINTSTS_RXFLVL);
 8001ab8:	6822      	ldr	r2, [r4, #0]
 8001aba:	6993      	ldr	r3, [r2, #24]
 8001abc:	f023 0310 	bic.w	r3, r3, #16
 8001ac0:	6193      	str	r3, [r2, #24]
      RegVal = USBx->GRXSTSP;
 8001ac2:	f8d6 8020 	ldr.w	r8, [r6, #32]
      if (((RegVal & USB_OTG_GRXSTSP_PKTSTS) >> 17) ==  STS_DATA_UPDT)
 8001ac6:	f3c8 4343 	ubfx	r3, r8, #17, #4
 8001aca:	2b02      	cmp	r3, #2
      ep = &hpcd->OUT_ep[RegVal & USB_OTG_GRXSTSP_EPNUM];
 8001acc:	f008 070f 	and.w	r7, r8, #15
      if (((RegVal & USB_OTG_GRXSTSP_PKTSTS) >> 17) ==  STS_DATA_UPDT)
 8001ad0:	f040 812e 	bne.w	8001d30 <HAL_PCD_IRQHandler+0x2cc>
        if ((RegVal & USB_OTG_GRXSTSP_BCNT) != 0U)
 8001ad4:	f647 73f0 	movw	r3, #32752	; 0x7ff0
 8001ad8:	ea18 0f03 	tst.w	r8, r3
 8001adc:	d014      	beq.n	8001b08 <HAL_PCD_IRQHandler+0xa4>
          (void)USB_ReadPacket(USBx, ep->xfer_buff,
 8001ade:	2324      	movs	r3, #36	; 0x24
 8001ae0:	fb03 4707 	mla	r7, r3, r7, r4
 8001ae4:	f3c8 190a 	ubfx	r9, r8, #4, #11
 8001ae8:	f8d7 128c 	ldr.w	r1, [r7, #652]	; 0x28c
 8001aec:	464a      	mov	r2, r9
 8001aee:	4630      	mov	r0, r6
 8001af0:	f001 fefa 	bl	80038e8 <USB_ReadPacket>
          ep->xfer_buff += (RegVal & USB_OTG_GRXSTSP_BCNT) >> 4;
 8001af4:	f8d7 328c 	ldr.w	r3, [r7, #652]	; 0x28c
 8001af8:	444b      	add	r3, r9
 8001afa:	f8c7 328c 	str.w	r3, [r7, #652]	; 0x28c
          ep->xfer_count += (RegVal & USB_OTG_GRXSTSP_BCNT) >> 4;
 8001afe:	f8d7 329c 	ldr.w	r3, [r7, #668]	; 0x29c
 8001b02:	444b      	add	r3, r9
        ep->xfer_count += (RegVal & USB_OTG_GRXSTSP_BCNT) >> 4;
 8001b04:	f8c7 329c 	str.w	r3, [r7, #668]	; 0x29c
      USB_UNMASK_INTERRUPT(hpcd->Instance, USB_OTG_GINTSTS_RXFLVL);
 8001b08:	6822      	ldr	r2, [r4, #0]
 8001b0a:	6993      	ldr	r3, [r2, #24]
 8001b0c:	f043 0310 	orr.w	r3, r3, #16
 8001b10:	6193      	str	r3, [r2, #24]
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_OEPINT))
 8001b12:	6820      	ldr	r0, [r4, #0]
 8001b14:	f001 ff88 	bl	8003a28 <USB_ReadInterrupts>
 8001b18:	0301      	lsls	r1, r0, #12
 8001b1a:	f100 811b 	bmi.w	8001d54 <HAL_PCD_IRQHandler+0x2f0>
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_IEPINT))
 8001b1e:	6820      	ldr	r0, [r4, #0]
 8001b20:	f001 ff82 	bl	8003a28 <USB_ReadInterrupts>
 8001b24:	0342      	lsls	r2, r0, #13
 8001b26:	d50d      	bpl.n	8001b44 <HAL_PCD_IRQHandler+0xe0>
      ep_intr = USB_ReadDevAllInEpInterrupt(hpcd->Instance);
 8001b28:	6820      	ldr	r0, [r4, #0]
 8001b2a:	f001 ff89 	bl	8003a40 <USB_ReadDevAllInEpInterrupt>
 8001b2e:	4627      	mov	r7, r4
 8001b30:	9004      	str	r0, [sp, #16]
      while (ep_intr != 0U)
 8001b32:	f506 6a10 	add.w	sl, r6, #2304	; 0x900
      epnum = 0U;
 8001b36:	f04f 0900 	mov.w	r9, #0
      while (ep_intr != 0U)
 8001b3a:	9b04      	ldr	r3, [sp, #16]
          epint = USB_ReadDevInEPInterrupt(hpcd->Instance, (uint8_t)epnum);
 8001b3c:	6820      	ldr	r0, [r4, #0]
      while (ep_intr != 0U)
 8001b3e:	2b00      	cmp	r3, #0
 8001b40:	f040 81d0 	bne.w	8001ee4 <HAL_PCD_IRQHandler+0x480>
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_WKUINT))
 8001b44:	6820      	ldr	r0, [r4, #0]
 8001b46:	f001 ff6f 	bl	8003a28 <USB_ReadInterrupts>
 8001b4a:	2800      	cmp	r0, #0
 8001b4c:	da13      	bge.n	8001b76 <HAL_PCD_IRQHandler+0x112>
      USBx_DEVICE->DCTL &= ~USB_OTG_DCTL_RWUSIG;
 8001b4e:	686b      	ldr	r3, [r5, #4]
 8001b50:	f023 0301 	bic.w	r3, r3, #1
 8001b54:	606b      	str	r3, [r5, #4]
      if (hpcd->LPM_State == LPM_L1)
 8001b56:	f894 34f4 	ldrb.w	r3, [r4, #1268]	; 0x4f4
 8001b5a:	2b01      	cmp	r3, #1
 8001b5c:	f040 826b 	bne.w	8002036 <HAL_PCD_IRQHandler+0x5d2>
        hpcd->LPM_State = LPM_L0;
 8001b60:	2100      	movs	r1, #0
 8001b62:	f884 14f4 	strb.w	r1, [r4, #1268]	; 0x4f4
        HAL_PCDEx_LPM_Callback(hpcd, PCD_LPM_L0_ACTIVE);
 8001b66:	4620      	mov	r0, r4
 8001b68:	f000 fae8 	bl	800213c <HAL_PCDEx_LPM_Callback>
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_WKUINT);
 8001b6c:	6822      	ldr	r2, [r4, #0]
 8001b6e:	6953      	ldr	r3, [r2, #20]
 8001b70:	f003 4300 	and.w	r3, r3, #2147483648	; 0x80000000
 8001b74:	6153      	str	r3, [r2, #20]
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_USBSUSP))
 8001b76:	6820      	ldr	r0, [r4, #0]
 8001b78:	f001 ff56 	bl	8003a28 <USB_ReadInterrupts>
 8001b7c:	0501      	lsls	r1, r0, #20
 8001b7e:	d50a      	bpl.n	8001b96 <HAL_PCD_IRQHandler+0x132>
      if ((USBx_DEVICE->DSTS & USB_OTG_DSTS_SUSPSTS) == USB_OTG_DSTS_SUSPSTS)
 8001b80:	68ab      	ldr	r3, [r5, #8]
 8001b82:	07da      	lsls	r2, r3, #31
 8001b84:	d502      	bpl.n	8001b8c <HAL_PCD_IRQHandler+0x128>
        HAL_PCD_SuspendCallback(hpcd);
 8001b86:	4620      	mov	r0, r4
 8001b88:	f7ff f819 	bl	8000bbe <HAL_PCD_SuspendCallback>
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_USBSUSP);
 8001b8c:	6822      	ldr	r2, [r4, #0]
 8001b8e:	6953      	ldr	r3, [r2, #20]
 8001b90:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 8001b94:	6153      	str	r3, [r2, #20]
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_USBRST))
 8001b96:	6820      	ldr	r0, [r4, #0]
 8001b98:	f001 ff46 	bl	8003a28 <USB_ReadInterrupts>
 8001b9c:	04c3      	lsls	r3, r0, #19
 8001b9e:	d533      	bpl.n	8001c08 <HAL_PCD_IRQHandler+0x1a4>
      USBx_DEVICE->DCTL &= ~USB_OTG_DCTL_RWUSIG;
 8001ba0:	686b      	ldr	r3, [r5, #4]
      (void)USB_FlushTxFifo(hpcd->Instance, 0x10U);
 8001ba2:	6820      	ldr	r0, [r4, #0]
      USBx_DEVICE->DCTL &= ~USB_OTG_DCTL_RWUSIG;
 8001ba4:	f023 0301 	bic.w	r3, r3, #1
 8001ba8:	606b      	str	r3, [r5, #4]
      (void)USB_FlushTxFifo(hpcd->Instance, 0x10U);
 8001baa:	2110      	movs	r1, #16
 8001bac:	f001 fb36 	bl	800321c <USB_FlushTxFifo>
      for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 8001bb0:	f506 6310 	add.w	r3, r6, #2304	; 0x900
        USBx_INEP(i)->DIEPINT = 0xFB7FU;
 8001bb4:	f64f 317f 	movw	r1, #64383	; 0xfb7f
      for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 8001bb8:	6862      	ldr	r2, [r4, #4]
 8001bba:	9803      	ldr	r0, [sp, #12]
 8001bbc:	4282      	cmp	r2, r0
 8001bbe:	f200 8243 	bhi.w	8002048 <HAL_PCD_IRQHandler+0x5e4>
      USBx_DEVICE->DAINTMSK |= 0x10001U;
 8001bc2:	69eb      	ldr	r3, [r5, #28]
 8001bc4:	f043 1301 	orr.w	r3, r3, #65537	; 0x10001
 8001bc8:	61eb      	str	r3, [r5, #28]
      if (hpcd->Init.use_dedicated_ep1 != 0U)
 8001bca:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8001bcc:	2b00      	cmp	r3, #0
 8001bce:	f000 8253 	beq.w	8002078 <HAL_PCD_IRQHandler+0x614>
        USBx_DEVICE->DOUTEP1MSK |= USB_OTG_DOEPMSK_STUPM |
 8001bd2:	f8d5 3084 	ldr.w	r3, [r5, #132]	; 0x84
 8001bd6:	f043 030b 	orr.w	r3, r3, #11
 8001bda:	f8c5 3084 	str.w	r3, [r5, #132]	; 0x84
        USBx_DEVICE->DINEP1MSK |= USB_OTG_DIEPMSK_TOM |
 8001bde:	6c6b      	ldr	r3, [r5, #68]	; 0x44
 8001be0:	f043 030b 	orr.w	r3, r3, #11
 8001be4:	646b      	str	r3, [r5, #68]	; 0x44
      USBx_DEVICE->DCFG &= ~USB_OTG_DCFG_DAD;
 8001be6:	f8d6 3800 	ldr.w	r3, [r6, #2048]	; 0x800
      (void)USB_EP0_OutStart(hpcd->Instance, (uint8_t)hpcd->Init.dma_enable,
 8001bea:	7c21      	ldrb	r1, [r4, #16]
 8001bec:	6820      	ldr	r0, [r4, #0]
      USBx_DEVICE->DCFG &= ~USB_OTG_DCFG_DAD;
 8001bee:	f423 63fe 	bic.w	r3, r3, #2032	; 0x7f0
 8001bf2:	f8c6 3800 	str.w	r3, [r6, #2048]	; 0x800
      (void)USB_EP0_OutStart(hpcd->Instance, (uint8_t)hpcd->Init.dma_enable,
 8001bf6:	f204 42c4 	addw	r2, r4, #1220	; 0x4c4
 8001bfa:	f001 ff57 	bl	8003aac <USB_EP0_OutStart>
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_USBRST);
 8001bfe:	6822      	ldr	r2, [r4, #0]
 8001c00:	6953      	ldr	r3, [r2, #20]
 8001c02:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
 8001c06:	6153      	str	r3, [r2, #20]
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_ENUMDNE))
 8001c08:	6820      	ldr	r0, [r4, #0]
 8001c0a:	f001 ff0d 	bl	8003a28 <USB_ReadInterrupts>
 8001c0e:	0487      	lsls	r7, r0, #18
 8001c10:	d516      	bpl.n	8001c40 <HAL_PCD_IRQHandler+0x1dc>
      (void)USB_ActivateSetup(hpcd->Instance);
 8001c12:	6820      	ldr	r0, [r4, #0]
 8001c14:	f001 ff3a 	bl	8003a8c <USB_ActivateSetup>
      hpcd->Init.speed = USB_GetDevSpeed(hpcd->Instance);
 8001c18:	6820      	ldr	r0, [r4, #0]
 8001c1a:	f001 fc09 	bl	8003430 <USB_GetDevSpeed>
 8001c1e:	60e0      	str	r0, [r4, #12]
      (void)USB_SetTurnaroundTime(hpcd->Instance,
 8001c20:	6827      	ldr	r7, [r4, #0]
 8001c22:	f000 fd01 	bl	8002628 <HAL_RCC_GetHCLKFreq>
 8001c26:	7b22      	ldrb	r2, [r4, #12]
 8001c28:	4601      	mov	r1, r0
 8001c2a:	4638      	mov	r0, r7
 8001c2c:	f001 fa4a 	bl	80030c4 <USB_SetTurnaroundTime>
      HAL_PCD_ResetCallback(hpcd);
 8001c30:	4620      	mov	r0, r4
 8001c32:	f7fe ffb4 	bl	8000b9e <HAL_PCD_ResetCallback>
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_ENUMDNE);
 8001c36:	6822      	ldr	r2, [r4, #0]
 8001c38:	6953      	ldr	r3, [r2, #20]
 8001c3a:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
 8001c3e:	6153      	str	r3, [r2, #20]
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_SOF))
 8001c40:	6820      	ldr	r0, [r4, #0]
 8001c42:	f001 fef1 	bl	8003a28 <USB_ReadInterrupts>
 8001c46:	0700      	lsls	r0, r0, #28
 8001c48:	d507      	bpl.n	8001c5a <HAL_PCD_IRQHandler+0x1f6>
      HAL_PCD_SOFCallback(hpcd);
 8001c4a:	4620      	mov	r0, r4
 8001c4c:	f7fe ffa3 	bl	8000b96 <HAL_PCD_SOFCallback>
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_SOF);
 8001c50:	6822      	ldr	r2, [r4, #0]
 8001c52:	6953      	ldr	r3, [r2, #20]
 8001c54:	f003 0308 	and.w	r3, r3, #8
 8001c58:	6153      	str	r3, [r2, #20]
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_BOUTNAKEFF))
 8001c5a:	6820      	ldr	r0, [r4, #0]
 8001c5c:	f001 fee4 	bl	8003a28 <USB_ReadInterrupts>
 8001c60:	0601      	lsls	r1, r0, #24
 8001c62:	f100 8214 	bmi.w	800208e <HAL_PCD_IRQHandler+0x62a>
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_IISOIXFR))
 8001c66:	6820      	ldr	r0, [r4, #0]
 8001c68:	f001 fede 	bl	8003a28 <USB_ReadInterrupts>
 8001c6c:	02c2      	lsls	r2, r0, #11
 8001c6e:	d50c      	bpl.n	8001c8a <HAL_PCD_IRQHandler+0x226>
 8001c70:	46a0      	mov	r8, r4
 8001c72:	f506 6912 	add.w	r9, r6, #2336	; 0x920
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 8001c76:	2701      	movs	r7, #1
 8001c78:	6863      	ldr	r3, [r4, #4]
 8001c7a:	42bb      	cmp	r3, r7
 8001c7c:	f200 8220 	bhi.w	80020c0 <HAL_PCD_IRQHandler+0x65c>
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_IISOIXFR);
 8001c80:	6822      	ldr	r2, [r4, #0]
 8001c82:	6953      	ldr	r3, [r2, #20]
 8001c84:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
 8001c88:	6153      	str	r3, [r2, #20]
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_PXFR_INCOMPISOOUT))
 8001c8a:	6820      	ldr	r0, [r4, #0]
 8001c8c:	f001 fecc 	bl	8003a28 <USB_ReadInterrupts>
 8001c90:	0283      	lsls	r3, r0, #10
 8001c92:	d52d      	bpl.n	8001cf0 <HAL_PCD_IRQHandler+0x28c>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 8001c94:	f8d4 e004 	ldr.w	lr, [r4, #4]
 8001c98:	4623      	mov	r3, r4
 8001c9a:	f506 6032 	add.w	r0, r6, #2848	; 0xb20
 8001c9e:	2101      	movs	r1, #1
 8001ca0:	458e      	cmp	lr, r1
 8001ca2:	d920      	bls.n	8001ce6 <HAL_PCD_IRQHandler+0x282>
        if ((hpcd->OUT_ep[epnum].type == EP_TYPE_ISOC) &&
 8001ca4:	f893 c2a4 	ldrb.w	ip, [r3, #676]	; 0x2a4
        RegVal = USBx_OUTEP(epnum)->DOEPCTL;
 8001ca8:	6802      	ldr	r2, [r0, #0]
        if ((hpcd->OUT_ep[epnum].type == EP_TYPE_ISOC) &&
 8001caa:	f1bc 0f01 	cmp.w	ip, #1
 8001cae:	f040 821d 	bne.w	80020ec <HAL_PCD_IRQHandler+0x688>
 8001cb2:	2a00      	cmp	r2, #0
 8001cb4:	f280 821a 	bge.w	80020ec <HAL_PCD_IRQHandler+0x688>
            ((RegVal & (0x1U << 16)) == (hpcd->FrameNumber & 0x1U)))
 8001cb8:	f8d4 74fc 	ldr.w	r7, [r4, #1276]	; 0x4fc
 8001cbc:	f402 3280 	and.w	r2, r2, #65536	; 0x10000
 8001cc0:	f007 0701 	and.w	r7, r7, #1
            ((RegVal & USB_OTG_DOEPCTL_EPENA) == USB_OTG_DOEPCTL_EPENA) &&
 8001cc4:	42ba      	cmp	r2, r7
 8001cc6:	f040 8211 	bne.w	80020ec <HAL_PCD_IRQHandler+0x688>
          hpcd->OUT_ep[epnum].is_iso_incomplete = 1U;
 8001cca:	f883 c2a3 	strb.w	ip, [r3, #675]	; 0x2a3
          USBx->GINTMSK |= USB_OTG_GINTMSK_GONAKEFFM;
 8001cce:	69b2      	ldr	r2, [r6, #24]
 8001cd0:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 8001cd4:	61b2      	str	r2, [r6, #24]
          if ((USBx->GINTSTS & USB_OTG_GINTSTS_BOUTNAKEFF) == 0U)
 8001cd6:	6972      	ldr	r2, [r6, #20]
 8001cd8:	0617      	lsls	r7, r2, #24
 8001cda:	f100 8207 	bmi.w	80020ec <HAL_PCD_IRQHandler+0x688>
            USBx_DEVICE->DCTL |= USB_OTG_DCTL_SGONAK;
 8001cde:	686b      	ldr	r3, [r5, #4]
 8001ce0:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 8001ce4:	606b      	str	r3, [r5, #4]
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_PXFR_INCOMPISOOUT);
 8001ce6:	6822      	ldr	r2, [r4, #0]
 8001ce8:	6953      	ldr	r3, [r2, #20]
 8001cea:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
 8001cee:	6153      	str	r3, [r2, #20]
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_SRQINT))
 8001cf0:	6820      	ldr	r0, [r4, #0]
 8001cf2:	f001 fe99 	bl	8003a28 <USB_ReadInterrupts>
 8001cf6:	0041      	lsls	r1, r0, #1
 8001cf8:	d507      	bpl.n	8001d0a <HAL_PCD_IRQHandler+0x2a6>
      HAL_PCD_ConnectCallback(hpcd);
 8001cfa:	4620      	mov	r0, r4
 8001cfc:	f7fe ff6f 	bl	8000bde <HAL_PCD_ConnectCallback>
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_SRQINT);
 8001d00:	6822      	ldr	r2, [r4, #0]
 8001d02:	6953      	ldr	r3, [r2, #20]
 8001d04:	f003 4380 	and.w	r3, r3, #1073741824	; 0x40000000
 8001d08:	6153      	str	r3, [r2, #20]
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_OTGINT))
 8001d0a:	6820      	ldr	r0, [r4, #0]
 8001d0c:	f001 fe8c 	bl	8003a28 <USB_ReadInterrupts>
 8001d10:	0742      	lsls	r2, r0, #29
 8001d12:	d50a      	bpl.n	8001d2a <HAL_PCD_IRQHandler+0x2c6>
      RegVal = hpcd->Instance->GOTGINT;
 8001d14:	6823      	ldr	r3, [r4, #0]
 8001d16:	685d      	ldr	r5, [r3, #4]
      if ((RegVal & USB_OTG_GOTGINT_SEDET) == USB_OTG_GOTGINT_SEDET)
 8001d18:	076b      	lsls	r3, r5, #29
 8001d1a:	d502      	bpl.n	8001d22 <HAL_PCD_IRQHandler+0x2be>
        HAL_PCD_DisconnectCallback(hpcd);
 8001d1c:	4620      	mov	r0, r4
 8001d1e:	f7fe ff62 	bl	8000be6 <HAL_PCD_DisconnectCallback>
      hpcd->Instance->GOTGINT |= RegVal;
 8001d22:	6822      	ldr	r2, [r4, #0]
 8001d24:	6853      	ldr	r3, [r2, #4]
 8001d26:	432b      	orrs	r3, r5
 8001d28:	6053      	str	r3, [r2, #4]
}
 8001d2a:	b009      	add	sp, #36	; 0x24
 8001d2c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      else if (((RegVal & USB_OTG_GRXSTSP_PKTSTS) >> 17) == STS_SETUP_UPDT)
 8001d30:	2b06      	cmp	r3, #6
 8001d32:	f47f aee9 	bne.w	8001b08 <HAL_PCD_IRQHandler+0xa4>
        (void)USB_ReadPacket(USBx, (uint8_t *)hpcd->Setup, 8U);
 8001d36:	2208      	movs	r2, #8
 8001d38:	f204 41c4 	addw	r1, r4, #1220	; 0x4c4
 8001d3c:	4630      	mov	r0, r6
 8001d3e:	f001 fdd3 	bl	80038e8 <USB_ReadPacket>
        ep->xfer_count += (RegVal & USB_OTG_GRXSTSP_BCNT) >> 4;
 8001d42:	2324      	movs	r3, #36	; 0x24
 8001d44:	fb03 4707 	mla	r7, r3, r7, r4
 8001d48:	f3c8 180a 	ubfx	r8, r8, #4, #11
 8001d4c:	f8d7 329c 	ldr.w	r3, [r7, #668]	; 0x29c
 8001d50:	4443      	add	r3, r8
 8001d52:	e6d7      	b.n	8001b04 <HAL_PCD_IRQHandler+0xa0>
      ep_intr = USB_ReadDevAllOutEpInterrupt(hpcd->Instance);
 8001d54:	6820      	ldr	r0, [r4, #0]
 8001d56:	f001 fe6b 	bl	8003a30 <USB_ReadDevAllOutEpInterrupt>
 8001d5a:	f506 6830 	add.w	r8, r6, #2816	; 0xb00
 8001d5e:	9004      	str	r0, [sp, #16]
      while (ep_intr != 0U)
 8001d60:	46a2      	mov	sl, r4
      epnum = 0U;
 8001d62:	2700      	movs	r7, #0
      while (ep_intr != 0U)
 8001d64:	9b04      	ldr	r3, [sp, #16]
          epint = USB_ReadDevOutEPInterrupt(hpcd->Instance, (uint8_t)epnum);
 8001d66:	6820      	ldr	r0, [r4, #0]
      while (ep_intr != 0U)
 8001d68:	2b00      	cmp	r3, #0
 8001d6a:	f43f aed8 	beq.w	8001b1e <HAL_PCD_IRQHandler+0xba>
        if ((ep_intr & 0x1U) != 0U)
 8001d6e:	9b04      	ldr	r3, [sp, #16]
 8001d70:	07db      	lsls	r3, r3, #31
 8001d72:	d575      	bpl.n	8001e60 <HAL_PCD_IRQHandler+0x3fc>
          epint = USB_ReadDevOutEPInterrupt(hpcd->Instance, (uint8_t)epnum);
 8001d74:	fa5f fb87 	uxtb.w	fp, r7
 8001d78:	4659      	mov	r1, fp
 8001d7a:	f001 fe69 	bl	8003a50 <USB_ReadDevOutEPInterrupt>
          if ((epint & USB_OTG_DOEPINT_XFRC) == USB_OTG_DOEPINT_XFRC)
 8001d7e:	f010 0f01 	tst.w	r0, #1
          epint = USB_ReadDevOutEPInterrupt(hpcd->Instance, (uint8_t)epnum);
 8001d82:	4681      	mov	r9, r0
          if ((epint & USB_OTG_DOEPINT_XFRC) == USB_OTG_DOEPINT_XFRC)
 8001d84:	d01c      	beq.n	8001dc0 <HAL_PCD_IRQHandler+0x35c>
  * @retval HAL status
  */
static HAL_StatusTypeDef PCD_EP_OutXfrComplete_int(PCD_HandleTypeDef *hpcd, uint32_t epnum)
{
  USB_OTG_EPTypeDef *ep;
  USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;
 8001d86:	6820      	ldr	r0, [r4, #0]
  uint32_t USBx_BASE = (uint32_t)USBx;
  uint32_t gSNPSiD = *(__IO uint32_t *)(&USBx->CID + 0x1U);
  uint32_t DoepintReg = USBx_OUTEP(epnum)->DOEPINT;

  if (hpcd->Init.dma_enable == 1U)
 8001d88:	6921      	ldr	r1, [r4, #16]
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_XFRC);
 8001d8a:	2301      	movs	r3, #1
 8001d8c:	f8c8 3008 	str.w	r3, [r8, #8]
  uint32_t DoepintReg = USBx_OUTEP(epnum)->DOEPINT;
 8001d90:	f500 6330 	add.w	r3, r0, #2816	; 0xb00
 8001d94:	eb03 1347 	add.w	r3, r3, r7, lsl #5
  if (hpcd->Init.dma_enable == 1U)
 8001d98:	2901      	cmp	r1, #1
  uint32_t gSNPSiD = *(__IO uint32_t *)(&USBx->CID + 0x1U);
 8001d9a:	f8d0 c040 	ldr.w	ip, [r0, #64]	; 0x40
  uint32_t DoepintReg = USBx_OUTEP(epnum)->DOEPINT;
 8001d9e:	689a      	ldr	r2, [r3, #8]
  if (hpcd->Init.dma_enable == 1U)
 8001da0:	f040 808b 	bne.w	8001eba <HAL_PCD_IRQHandler+0x456>
  {
    if ((DoepintReg & USB_OTG_DOEPINT_STUP) == USB_OTG_DOEPINT_STUP) /* Class C */
 8001da4:	0711      	lsls	r1, r2, #28
 8001da6:	d507      	bpl.n	8001db8 <HAL_PCD_IRQHandler+0x354>
    {
      /* StupPktRcvd = 1 this is a setup packet */
      if ((gSNPSiD > USB_OTG_CORE_ID_300A) &&
 8001da8:	49a5      	ldr	r1, [pc, #660]	; (8002040 <HAL_PCD_IRQHandler+0x5dc>)
 8001daa:	458c      	cmp	ip, r1
 8001dac:	d908      	bls.n	8001dc0 <HAL_PCD_IRQHandler+0x35c>
 8001dae:	0410      	lsls	r0, r2, #16
 8001db0:	d506      	bpl.n	8001dc0 <HAL_PCD_IRQHandler+0x35c>
    if (gSNPSiD == USB_OTG_CORE_ID_310A)
    {
      /* StupPktRcvd = 1 this is a setup packet */
      if ((DoepintReg & USB_OTG_DOEPINT_STPKTRX) == USB_OTG_DOEPINT_STPKTRX)
      {
        CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_STPKTRX);
 8001db2:	f44f 4200 	mov.w	r2, #32768	; 0x8000
 8001db6:	e002      	b.n	8001dbe <HAL_PCD_IRQHandler+0x35a>
    else if ((DoepintReg & USB_OTG_DOEPINT_OTEPSPR) == USB_OTG_DOEPINT_OTEPSPR) /* Class E */
 8001db8:	0691      	lsls	r1, r2, #26
 8001dba:	d55a      	bpl.n	8001e72 <HAL_PCD_IRQHandler+0x40e>
      CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_OTEPSPR);
 8001dbc:	2220      	movs	r2, #32
        CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_STPKTRX);
 8001dbe:	609a      	str	r2, [r3, #8]
          if ((epint & USB_OTG_DOEPINT_STUP) == USB_OTG_DOEPINT_STUP)
 8001dc0:	f019 0f08 	tst.w	r9, #8
 8001dc4:	d021      	beq.n	8001e0a <HAL_PCD_IRQHandler+0x3a6>
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_STUP);
 8001dc6:	2308      	movs	r3, #8
 8001dc8:	f8c8 3008 	str.w	r3, [r8, #8]
  * @param  epnum endpoint number
  * @retval HAL status
  */
static HAL_StatusTypeDef PCD_EP_OutSetupPacket_int(PCD_HandleTypeDef *hpcd, uint32_t epnum)
{
  USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;
 8001dcc:	6823      	ldr	r3, [r4, #0]
  uint32_t USBx_BASE = (uint32_t)USBx;
  uint32_t gSNPSiD = *(__IO uint32_t *)(&USBx->CID + 0x1U);
  uint32_t DoepintReg = USBx_OUTEP(epnum)->DOEPINT;

  if ((gSNPSiD > USB_OTG_CORE_ID_300A) &&
 8001dce:	489c      	ldr	r0, [pc, #624]	; (8002040 <HAL_PCD_IRQHandler+0x5dc>)
  uint32_t gSNPSiD = *(__IO uint32_t *)(&USBx->CID + 0x1U);
 8001dd0:	6c1a      	ldr	r2, [r3, #64]	; 0x40
  uint32_t DoepintReg = USBx_OUTEP(epnum)->DOEPINT;
 8001dd2:	f503 6330 	add.w	r3, r3, #2816	; 0xb00
 8001dd6:	eb03 1347 	add.w	r3, r3, r7, lsl #5
  if ((gSNPSiD > USB_OTG_CORE_ID_300A) &&
 8001dda:	4282      	cmp	r2, r0
  uint32_t DoepintReg = USBx_OUTEP(epnum)->DOEPINT;
 8001ddc:	6899      	ldr	r1, [r3, #8]
  if ((gSNPSiD > USB_OTG_CORE_ID_300A) &&
 8001dde:	d904      	bls.n	8001dea <HAL_PCD_IRQHandler+0x386>
 8001de0:	0409      	lsls	r1, r1, #16
      ((DoepintReg & USB_OTG_DOEPINT_STPKTRX) == USB_OTG_DOEPINT_STPKTRX))
  {
    CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_STPKTRX);
 8001de2:	bf44      	itt	mi
 8001de4:	f44f 4100 	movmi.w	r1, #32768	; 0x8000
 8001de8:	6099      	strmi	r1, [r3, #8]

  /* Inform the upper layer that a setup packet is available */
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
  hpcd->SetupStageCallback(hpcd);
#else
  HAL_PCD_SetupStageCallback(hpcd);
 8001dea:	4620      	mov	r0, r4
 8001dec:	9205      	str	r2, [sp, #20]
 8001dee:	f7fe febb 	bl	8000b68 <HAL_PCD_SetupStageCallback>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */

  if ((gSNPSiD > USB_OTG_CORE_ID_300A) && (hpcd->Init.dma_enable == 1U))
 8001df2:	4b93      	ldr	r3, [pc, #588]	; (8002040 <HAL_PCD_IRQHandler+0x5dc>)
 8001df4:	9a05      	ldr	r2, [sp, #20]
 8001df6:	429a      	cmp	r2, r3
 8001df8:	d907      	bls.n	8001e0a <HAL_PCD_IRQHandler+0x3a6>
 8001dfa:	6921      	ldr	r1, [r4, #16]
 8001dfc:	2901      	cmp	r1, #1
 8001dfe:	d104      	bne.n	8001e0a <HAL_PCD_IRQHandler+0x3a6>
  {
    (void)USB_EP0_OutStart(hpcd->Instance, 1U, (uint8_t *)hpcd->Setup);
 8001e00:	6820      	ldr	r0, [r4, #0]
 8001e02:	f204 42c4 	addw	r2, r4, #1220	; 0x4c4
 8001e06:	f001 fe51 	bl	8003aac <USB_EP0_OutStart>
          if ((epint & USB_OTG_DOEPINT_OTEPDIS) == USB_OTG_DOEPINT_OTEPDIS)
 8001e0a:	f019 0f10 	tst.w	r9, #16
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_OTEPDIS);
 8001e0e:	bf1c      	itt	ne
 8001e10:	2310      	movne	r3, #16
 8001e12:	f8c8 3008 	strne.w	r3, [r8, #8]
          if ((epint & USB_OTG_DOEPINT_EPDISD) == USB_OTG_DOEPINT_EPDISD)
 8001e16:	f019 0f02 	tst.w	r9, #2
 8001e1a:	d014      	beq.n	8001e46 <HAL_PCD_IRQHandler+0x3e2>
            if ((USBx->GINTSTS & USB_OTG_GINTSTS_BOUTNAKEFF) == USB_OTG_GINTSTS_BOUTNAKEFF)
 8001e1c:	6973      	ldr	r3, [r6, #20]
 8001e1e:	061a      	lsls	r2, r3, #24
              USBx_DEVICE->DCTL |= USB_OTG_DCTL_CGONAK;
 8001e20:	bf42      	ittt	mi
 8001e22:	686b      	ldrmi	r3, [r5, #4]
 8001e24:	f443 6380 	orrmi.w	r3, r3, #1024	; 0x400
 8001e28:	606b      	strmi	r3, [r5, #4]
            if (ep->is_iso_incomplete == 1U)
 8001e2a:	f89a 327f 	ldrb.w	r3, [sl, #639]	; 0x27f
 8001e2e:	2b01      	cmp	r3, #1
 8001e30:	d106      	bne.n	8001e40 <HAL_PCD_IRQHandler+0x3dc>
              ep->is_iso_incomplete = 0U;
 8001e32:	2300      	movs	r3, #0
 8001e34:	f88a 327f 	strb.w	r3, [sl, #639]	; 0x27f
              HAL_PCD_ISOOUTIncompleteCallback(hpcd, (uint8_t)epnum);
 8001e38:	4659      	mov	r1, fp
 8001e3a:	4620      	mov	r0, r4
 8001e3c:	f7fe fec7 	bl	8000bce <HAL_PCD_ISOOUTIncompleteCallback>
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_EPDISD);
 8001e40:	2302      	movs	r3, #2
 8001e42:	f8c8 3008 	str.w	r3, [r8, #8]
          if ((epint & USB_OTG_DOEPINT_OTEPSPR) == USB_OTG_DOEPINT_OTEPSPR)
 8001e46:	f019 0f20 	tst.w	r9, #32
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_OTEPSPR);
 8001e4a:	bf1c      	itt	ne
 8001e4c:	2320      	movne	r3, #32
 8001e4e:	f8c8 3008 	strne.w	r3, [r8, #8]
          if ((epint & USB_OTG_DOEPINT_NAK) == USB_OTG_DOEPINT_NAK)
 8001e52:	f419 5f00 	tst.w	r9, #8192	; 0x2000
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_NAK);
 8001e56:	bf1c      	itt	ne
 8001e58:	f44f 5300 	movne.w	r3, #8192	; 0x2000
 8001e5c:	f8c8 3008 	strne.w	r3, [r8, #8]
        ep_intr >>= 1U;
 8001e60:	9b04      	ldr	r3, [sp, #16]
 8001e62:	085b      	lsrs	r3, r3, #1
        epnum++;
 8001e64:	3701      	adds	r7, #1
        ep_intr >>= 1U;
 8001e66:	9304      	str	r3, [sp, #16]
 8001e68:	f108 0820 	add.w	r8, r8, #32
 8001e6c:	f10a 0a24 	add.w	sl, sl, #36	; 0x24
 8001e70:	e778      	b.n	8001d64 <HAL_PCD_IRQHandler+0x300>
    else if ((DoepintReg & (USB_OTG_DOEPINT_STUP | USB_OTG_DOEPINT_OTEPSPR)) == 0U)
 8001e72:	f012 0f28 	tst.w	r2, #40	; 0x28
 8001e76:	d1a3      	bne.n	8001dc0 <HAL_PCD_IRQHandler+0x35c>
      if ((gSNPSiD > USB_OTG_CORE_ID_300A) &&
 8001e78:	4971      	ldr	r1, [pc, #452]	; (8002040 <HAL_PCD_IRQHandler+0x5dc>)
 8001e7a:	458c      	cmp	ip, r1
 8001e7c:	d901      	bls.n	8001e82 <HAL_PCD_IRQHandler+0x41e>
 8001e7e:	0412      	lsls	r2, r2, #16
 8001e80:	d497      	bmi.n	8001db2 <HAL_PCD_IRQHandler+0x34e>
        ep->xfer_count = ep->xfer_size - (USBx_OUTEP(epnum)->DOEPTSIZ & USB_OTG_DOEPTSIZ_XFRSIZ);
 8001e82:	691a      	ldr	r2, [r3, #16]
 8001e84:	f8da 3298 	ldr.w	r3, [sl, #664]	; 0x298
 8001e88:	f3c2 0212 	ubfx	r2, r2, #0, #19
 8001e8c:	1a9b      	subs	r3, r3, r2
 8001e8e:	f8ca 329c 	str.w	r3, [sl, #668]	; 0x29c
        if (epnum == 0U)
 8001e92:	b96f      	cbnz	r7, 8001eb0 <HAL_PCD_IRQHandler+0x44c>
          if (ep->xfer_len == 0U)
 8001e94:	f8d4 2294 	ldr.w	r2, [r4, #660]	; 0x294
 8001e98:	b92a      	cbnz	r2, 8001ea6 <HAL_PCD_IRQHandler+0x442>
            (void)USB_EP0_OutStart(hpcd->Instance, 1U, (uint8_t *)hpcd->Setup);
 8001e9a:	f204 42c4 	addw	r2, r4, #1220	; 0x4c4
 8001e9e:	2101      	movs	r1, #1
        (void)USB_EP0_OutStart(hpcd->Instance, 0U, (uint8_t *)hpcd->Setup);
 8001ea0:	f001 fe04 	bl	8003aac <USB_EP0_OutStart>
 8001ea4:	e004      	b.n	8001eb0 <HAL_PCD_IRQHandler+0x44c>
            ep->xfer_buff += ep->xfer_count;
 8001ea6:	f8d4 228c 	ldr.w	r2, [r4, #652]	; 0x28c
 8001eaa:	441a      	add	r2, r3
 8001eac:	f8c4 228c 	str.w	r2, [r4, #652]	; 0x28c
      HAL_PCD_DataOutStageCallback(hpcd, (uint8_t)epnum);
 8001eb0:	4659      	mov	r1, fp
 8001eb2:	4620      	mov	r0, r4
 8001eb4:	f7fe fe5e 	bl	8000b74 <HAL_PCD_DataOutStageCallback>
 8001eb8:	e782      	b.n	8001dc0 <HAL_PCD_IRQHandler+0x35c>
    if (gSNPSiD == USB_OTG_CORE_ID_310A)
 8001eba:	4962      	ldr	r1, [pc, #392]	; (8002044 <HAL_PCD_IRQHandler+0x5e0>)
 8001ebc:	458c      	cmp	ip, r1
 8001ebe:	d107      	bne.n	8001ed0 <HAL_PCD_IRQHandler+0x46c>
      if ((DoepintReg & USB_OTG_DOEPINT_STPKTRX) == USB_OTG_DOEPINT_STPKTRX)
 8001ec0:	0411      	lsls	r1, r2, #16
 8001ec2:	f53f af76 	bmi.w	8001db2 <HAL_PCD_IRQHandler+0x34e>
        if ((DoepintReg & USB_OTG_DOEPINT_OTEPSPR) == USB_OTG_DOEPINT_OTEPSPR)
 8001ec6:	0690      	lsls	r0, r2, #26
 8001ec8:	d5f2      	bpl.n	8001eb0 <HAL_PCD_IRQHandler+0x44c>
          CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_OTEPSPR);
 8001eca:	2220      	movs	r2, #32
 8001ecc:	609a      	str	r2, [r3, #8]
        HAL_PCD_DataOutStageCallback(hpcd, (uint8_t)epnum);
 8001ece:	e7ef      	b.n	8001eb0 <HAL_PCD_IRQHandler+0x44c>
      if ((epnum == 0U) && (hpcd->OUT_ep[epnum].xfer_len == 0U))
 8001ed0:	2f00      	cmp	r7, #0
 8001ed2:	d1ed      	bne.n	8001eb0 <HAL_PCD_IRQHandler+0x44c>
 8001ed4:	f8d4 3294 	ldr.w	r3, [r4, #660]	; 0x294
 8001ed8:	2b00      	cmp	r3, #0
 8001eda:	d1e9      	bne.n	8001eb0 <HAL_PCD_IRQHandler+0x44c>
        (void)USB_EP0_OutStart(hpcd->Instance, 0U, (uint8_t *)hpcd->Setup);
 8001edc:	f204 42c4 	addw	r2, r4, #1220	; 0x4c4
 8001ee0:	4639      	mov	r1, r7
 8001ee2:	e7dd      	b.n	8001ea0 <HAL_PCD_IRQHandler+0x43c>
        if ((ep_intr & 0x1U) != 0U) /* In ITR */
 8001ee4:	9b04      	ldr	r3, [sp, #16]
 8001ee6:	07db      	lsls	r3, r3, #31
 8001ee8:	f140 809c 	bpl.w	8002024 <HAL_PCD_IRQHandler+0x5c0>
          epint = USB_ReadDevInEPInterrupt(hpcd->Instance, (uint8_t)epnum);
 8001eec:	fa5f fb89 	uxtb.w	fp, r9
 8001ef0:	4659      	mov	r1, fp
 8001ef2:	f001 fdb6 	bl	8003a62 <USB_ReadDevInEPInterrupt>
          if ((epint & USB_OTG_DIEPINT_XFRC) == USB_OTG_DIEPINT_XFRC)
 8001ef6:	f010 0f01 	tst.w	r0, #1
          epint = USB_ReadDevInEPInterrupt(hpcd->Instance, (uint8_t)epnum);
 8001efa:	4680      	mov	r8, r0
          if ((epint & USB_OTG_DIEPINT_XFRC) == USB_OTG_DIEPINT_XFRC)
 8001efc:	d020      	beq.n	8001f40 <HAL_PCD_IRQHandler+0x4dc>
            fifoemptymsk = (uint32_t)(0x1UL << (epnum & EP_ADDR_MSK));
 8001efe:	2101      	movs	r1, #1
            USBx_DEVICE->DIEPEMPMSK &= ~fifoemptymsk;
 8001f00:	6b6b      	ldr	r3, [r5, #52]	; 0x34
            fifoemptymsk = (uint32_t)(0x1UL << (epnum & EP_ADDR_MSK));
 8001f02:	f009 020f 	and.w	r2, r9, #15
 8001f06:	fa01 f202 	lsl.w	r2, r1, r2
            USBx_DEVICE->DIEPEMPMSK &= ~fifoemptymsk;
 8001f0a:	ea23 0302 	bic.w	r3, r3, r2
 8001f0e:	636b      	str	r3, [r5, #52]	; 0x34
            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_XFRC);
 8001f10:	460b      	mov	r3, r1
 8001f12:	f8ca 1008 	str.w	r1, [sl, #8]
            if (hpcd->Init.dma_enable == 1U)
 8001f16:	6921      	ldr	r1, [r4, #16]
 8001f18:	4299      	cmp	r1, r3
 8001f1a:	d10d      	bne.n	8001f38 <HAL_PCD_IRQHandler+0x4d4>
              hpcd->IN_ep[epnum].xfer_buff += hpcd->IN_ep[epnum].maxpacket;
 8001f1c:	e9d7 2312 	ldrd	r2, r3, [r7, #72]	; 0x48
 8001f20:	4413      	add	r3, r2
 8001f22:	64fb      	str	r3, [r7, #76]	; 0x4c
              if ((epnum == 0U) && (hpcd->IN_ep[epnum].xfer_len == 0U))
 8001f24:	f1b9 0f00 	cmp.w	r9, #0
 8001f28:	d106      	bne.n	8001f38 <HAL_PCD_IRQHandler+0x4d4>
 8001f2a:	6d63      	ldr	r3, [r4, #84]	; 0x54
 8001f2c:	b923      	cbnz	r3, 8001f38 <HAL_PCD_IRQHandler+0x4d4>
                (void)USB_EP0_OutStart(hpcd->Instance, 1U, (uint8_t *)hpcd->Setup);
 8001f2e:	6820      	ldr	r0, [r4, #0]
 8001f30:	f204 42c4 	addw	r2, r4, #1220	; 0x4c4
 8001f34:	f001 fdba 	bl	8003aac <USB_EP0_OutStart>
            HAL_PCD_DataInStageCallback(hpcd, (uint8_t)epnum);
 8001f38:	4659      	mov	r1, fp
 8001f3a:	4620      	mov	r0, r4
 8001f3c:	f7fe fe23 	bl	8000b86 <HAL_PCD_DataInStageCallback>
          if ((epint & USB_OTG_DIEPINT_TOC) == USB_OTG_DIEPINT_TOC)
 8001f40:	f018 0f08 	tst.w	r8, #8
            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_TOC);
 8001f44:	bf1c      	itt	ne
 8001f46:	2308      	movne	r3, #8
 8001f48:	f8ca 3008 	strne.w	r3, [sl, #8]
          if ((epint & USB_OTG_DIEPINT_ITTXFE) == USB_OTG_DIEPINT_ITTXFE)
 8001f4c:	f018 0f10 	tst.w	r8, #16
            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_ITTXFE);
 8001f50:	bf1c      	itt	ne
 8001f52:	2310      	movne	r3, #16
 8001f54:	f8ca 3008 	strne.w	r3, [sl, #8]
          if ((epint & USB_OTG_DIEPINT_INEPNE) == USB_OTG_DIEPINT_INEPNE)
 8001f58:	f018 0f40 	tst.w	r8, #64	; 0x40
            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_INEPNE);
 8001f5c:	bf1c      	itt	ne
 8001f5e:	2340      	movne	r3, #64	; 0x40
 8001f60:	f8ca 3008 	strne.w	r3, [sl, #8]
          if ((epint & USB_OTG_DIEPINT_EPDISD) == USB_OTG_DIEPINT_EPDISD)
 8001f64:	f018 0f02 	tst.w	r8, #2
 8001f68:	d012      	beq.n	8001f90 <HAL_PCD_IRQHandler+0x52c>
            (void)USB_FlushTxFifo(USBx, epnum);
 8001f6a:	4649      	mov	r1, r9
 8001f6c:	4630      	mov	r0, r6
 8001f6e:	f001 f955 	bl	800321c <USB_FlushTxFifo>
            if (ep->is_iso_incomplete == 1U)
 8001f72:	f897 303f 	ldrb.w	r3, [r7, #63]	; 0x3f
 8001f76:	2b01      	cmp	r3, #1
 8001f78:	d107      	bne.n	8001f8a <HAL_PCD_IRQHandler+0x526>
              ep->is_iso_incomplete = 0U;
 8001f7a:	f04f 0300 	mov.w	r3, #0
 8001f7e:	f887 303f 	strb.w	r3, [r7, #63]	; 0x3f
              HAL_PCD_ISOINIncompleteCallback(hpcd, (uint8_t)epnum);
 8001f82:	4659      	mov	r1, fp
 8001f84:	4620      	mov	r0, r4
 8001f86:	f7fe fe26 	bl	8000bd6 <HAL_PCD_ISOINIncompleteCallback>
            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_EPDISD);
 8001f8a:	2302      	movs	r3, #2
 8001f8c:	f8ca 3008 	str.w	r3, [sl, #8]
  USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;
 8001f90:	6823      	ldr	r3, [r4, #0]
 8001f92:	9305      	str	r3, [sp, #20]
          if ((epint & USB_OTG_DIEPINT_TXFE) == USB_OTG_DIEPINT_TXFE)
 8001f94:	f018 0f80 	tst.w	r8, #128	; 0x80
 8001f98:	d044      	beq.n	8002024 <HAL_PCD_IRQHandler+0x5c0>
  if (ep->xfer_count > ep->xfer_len)
 8001f9a:	6dfa      	ldr	r2, [r7, #92]	; 0x5c
 8001f9c:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8001f9e:	429a      	cmp	r2, r3
 8001fa0:	d840      	bhi.n	8002024 <HAL_PCD_IRQHandler+0x5c0>
  len = ep->xfer_len - ep->xfer_count;
 8001fa2:	1a9b      	subs	r3, r3, r2
  len32b = (len + 3U) / 4U;
 8001fa4:	6cba      	ldr	r2, [r7, #72]	; 0x48
 8001fa6:	4293      	cmp	r3, r2
 8001fa8:	bf28      	it	cs
 8001faa:	4613      	movcs	r3, r2
 8001fac:	3303      	adds	r3, #3
 8001fae:	089b      	lsrs	r3, r3, #2
 8001fb0:	9306      	str	r3, [sp, #24]
  while (((USBx_INEP(epnum)->DTXFSTS & USB_OTG_DTXFSTS_INEPTFSAV) >= len32b) &&
 8001fb2:	9b05      	ldr	r3, [sp, #20]
 8001fb4:	f503 6310 	add.w	r3, r3, #2304	; 0x900
 8001fb8:	eb03 1349 	add.w	r3, r3, r9, lsl #5
 8001fbc:	9307      	str	r3, [sp, #28]
 8001fbe:	9b07      	ldr	r3, [sp, #28]
         (ep->xfer_count < ep->xfer_len) && (ep->xfer_len != 0U))
 8001fc0:	9806      	ldr	r0, [sp, #24]
  while (((USBx_INEP(epnum)->DTXFSTS & USB_OTG_DTXFSTS_INEPTFSAV) >= len32b) &&
 8001fc2:	6999      	ldr	r1, [r3, #24]
         (ep->xfer_count < ep->xfer_len) && (ep->xfer_len != 0U))
 8001fc4:	6dfa      	ldr	r2, [r7, #92]	; 0x5c
 8001fc6:	6d7b      	ldr	r3, [r7, #84]	; 0x54
  while (((USBx_INEP(epnum)->DTXFSTS & USB_OTG_DTXFSTS_INEPTFSAV) >= len32b) &&
 8001fc8:	b289      	uxth	r1, r1
         (ep->xfer_count < ep->xfer_len) && (ep->xfer_len != 0U))
 8001fca:	4281      	cmp	r1, r0
 8001fcc:	d328      	bcc.n	8002020 <HAL_PCD_IRQHandler+0x5bc>
  while (((USBx_INEP(epnum)->DTXFSTS & USB_OTG_DTXFSTS_INEPTFSAV) >= len32b) &&
 8001fce:	429a      	cmp	r2, r3
 8001fd0:	d30c      	bcc.n	8001fec <HAL_PCD_IRQHandler+0x588>
    USBx_DEVICE->DIEPEMPMSK &= ~fifoemptymsk;
 8001fd2:	9b05      	ldr	r3, [sp, #20]
    fifoemptymsk = (uint32_t)(0x1UL << (epnum & EP_ADDR_MSK));
 8001fd4:	f009 010f 	and.w	r1, r9, #15
    USBx_DEVICE->DIEPEMPMSK &= ~fifoemptymsk;
 8001fd8:	f8d3 2834 	ldr.w	r2, [r3, #2100]	; 0x834
    fifoemptymsk = (uint32_t)(0x1UL << (epnum & EP_ADDR_MSK));
 8001fdc:	2001      	movs	r0, #1
 8001fde:	fa00 f101 	lsl.w	r1, r0, r1
    USBx_DEVICE->DIEPEMPMSK &= ~fifoemptymsk;
 8001fe2:	ea22 0201 	bic.w	r2, r2, r1
 8001fe6:	f8c3 2834 	str.w	r2, [r3, #2100]	; 0x834
 8001fea:	e01b      	b.n	8002024 <HAL_PCD_IRQHandler+0x5c0>
    len = ep->xfer_len - ep->xfer_count;
 8001fec:	eba3 0802 	sub.w	r8, r3, r2
 8001ff0:	6cbb      	ldr	r3, [r7, #72]	; 0x48
    (void)USB_WritePacket(USBx, ep->xfer_buff, (uint8_t)epnum, (uint16_t)len,
 8001ff2:	9805      	ldr	r0, [sp, #20]
 8001ff4:	4598      	cmp	r8, r3
 8001ff6:	bf28      	it	cs
 8001ff8:	4698      	movcs	r8, r3
    len32b = (len + 3U) / 4U;
 8001ffa:	f108 0303 	add.w	r3, r8, #3
 8001ffe:	089b      	lsrs	r3, r3, #2
 8002000:	9306      	str	r3, [sp, #24]
    (void)USB_WritePacket(USBx, ep->xfer_buff, (uint8_t)epnum, (uint16_t)len,
 8002002:	7c23      	ldrb	r3, [r4, #16]
 8002004:	9300      	str	r3, [sp, #0]
 8002006:	6cf9      	ldr	r1, [r7, #76]	; 0x4c
 8002008:	fa1f f388 	uxth.w	r3, r8
 800200c:	465a      	mov	r2, fp
 800200e:	f001 fb6d 	bl	80036ec <USB_WritePacket>
    ep->xfer_buff  += len;
 8002012:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8002014:	4443      	add	r3, r8
 8002016:	64fb      	str	r3, [r7, #76]	; 0x4c
    ep->xfer_count += len;
 8002018:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 800201a:	4443      	add	r3, r8
 800201c:	65fb      	str	r3, [r7, #92]	; 0x5c
 800201e:	e7ce      	b.n	8001fbe <HAL_PCD_IRQHandler+0x55a>
  if (ep->xfer_len <= ep->xfer_count)
 8002020:	429a      	cmp	r2, r3
 8002022:	d2d6      	bcs.n	8001fd2 <HAL_PCD_IRQHandler+0x56e>
        ep_intr >>= 1U;
 8002024:	9b04      	ldr	r3, [sp, #16]
 8002026:	085b      	lsrs	r3, r3, #1
        epnum++;
 8002028:	f109 0901 	add.w	r9, r9, #1
        ep_intr >>= 1U;
 800202c:	9304      	str	r3, [sp, #16]
 800202e:	3724      	adds	r7, #36	; 0x24
 8002030:	f10a 0a20 	add.w	sl, sl, #32
 8002034:	e581      	b.n	8001b3a <HAL_PCD_IRQHandler+0xd6>
        HAL_PCD_ResumeCallback(hpcd);
 8002036:	4620      	mov	r0, r4
 8002038:	f7fe fdc5 	bl	8000bc6 <HAL_PCD_ResumeCallback>
 800203c:	e596      	b.n	8001b6c <HAL_PCD_IRQHandler+0x108>
 800203e:	bf00      	nop
 8002040:	4f54300a 	.word	0x4f54300a
 8002044:	4f54310a 	.word	0x4f54310a
        USBx_INEP(i)->DIEPINT = 0xFB7FU;
 8002048:	6099      	str	r1, [r3, #8]
        USBx_INEP(i)->DIEPCTL &= ~USB_OTG_DIEPCTL_STALL;
 800204a:	681a      	ldr	r2, [r3, #0]
 800204c:	f422 1200 	bic.w	r2, r2, #2097152	; 0x200000
 8002050:	601a      	str	r2, [r3, #0]
        USBx_OUTEP(i)->DOEPINT = 0xFB7FU;
 8002052:	f8c3 1208 	str.w	r1, [r3, #520]	; 0x208
        USBx_OUTEP(i)->DOEPCTL &= ~USB_OTG_DOEPCTL_STALL;
 8002056:	f8d3 2200 	ldr.w	r2, [r3, #512]	; 0x200
 800205a:	f422 1200 	bic.w	r2, r2, #2097152	; 0x200000
 800205e:	f8c3 2200 	str.w	r2, [r3, #512]	; 0x200
        USBx_OUTEP(i)->DOEPCTL |= USB_OTG_DOEPCTL_SNAK;
 8002062:	f8d3 2200 	ldr.w	r2, [r3, #512]	; 0x200
 8002066:	f042 6200 	orr.w	r2, r2, #134217728	; 0x8000000
 800206a:	f8c3 2200 	str.w	r2, [r3, #512]	; 0x200
      for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 800206e:	9a03      	ldr	r2, [sp, #12]
 8002070:	3201      	adds	r2, #1
 8002072:	9203      	str	r2, [sp, #12]
 8002074:	3320      	adds	r3, #32
 8002076:	e59f      	b.n	8001bb8 <HAL_PCD_IRQHandler+0x154>
        USBx_DEVICE->DOEPMSK |= USB_OTG_DOEPMSK_STUPM |
 8002078:	696b      	ldr	r3, [r5, #20]
 800207a:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 800207e:	f043 032b 	orr.w	r3, r3, #43	; 0x2b
 8002082:	616b      	str	r3, [r5, #20]
        USBx_DEVICE->DIEPMSK |= USB_OTG_DIEPMSK_TOM |
 8002084:	692b      	ldr	r3, [r5, #16]
 8002086:	f043 030b 	orr.w	r3, r3, #11
 800208a:	612b      	str	r3, [r5, #16]
 800208c:	e5ab      	b.n	8001be6 <HAL_PCD_IRQHandler+0x182>
      USBx->GINTMSK &= ~USB_OTG_GINTMSK_GONAKEFFM;
 800208e:	69b3      	ldr	r3, [r6, #24]
 8002090:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 8002094:	61b3      	str	r3, [r6, #24]
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 8002096:	2701      	movs	r7, #1
        if (hpcd->OUT_ep[epnum].is_iso_incomplete == 1U)
 8002098:	f204 287f 	addw	r8, r4, #639	; 0x27f
 800209c:	f04f 0924 	mov.w	r9, #36	; 0x24
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 80020a0:	6863      	ldr	r3, [r4, #4]
 80020a2:	42bb      	cmp	r3, r7
 80020a4:	f67f addf 	bls.w	8001c66 <HAL_PCD_IRQHandler+0x202>
        if (hpcd->OUT_ep[epnum].is_iso_incomplete == 1U)
 80020a8:	fb09 f307 	mul.w	r3, r9, r7
 80020ac:	f818 3003 	ldrb.w	r3, [r8, r3]
 80020b0:	2b01      	cmp	r3, #1
 80020b2:	d103      	bne.n	80020bc <HAL_PCD_IRQHandler+0x658>
          (void)HAL_PCD_EP_Abort(hpcd, (uint8_t)epnum);
 80020b4:	b2f9      	uxtb	r1, r7
 80020b6:	4620      	mov	r0, r4
 80020b8:	f7ff fcc3 	bl	8001a42 <HAL_PCD_EP_Abort>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 80020bc:	3701      	adds	r7, #1
 80020be:	e7ef      	b.n	80020a0 <HAL_PCD_IRQHandler+0x63c>
        if ((hpcd->IN_ep[epnum].type == EP_TYPE_ISOC) &&
 80020c0:	f898 3064 	ldrb.w	r3, [r8, #100]	; 0x64
        RegVal = USBx_INEP(epnum)->DIEPCTL;
 80020c4:	f8d9 2000 	ldr.w	r2, [r9]
        if ((hpcd->IN_ep[epnum].type == EP_TYPE_ISOC) &&
 80020c8:	2b01      	cmp	r3, #1
 80020ca:	d109      	bne.n	80020e0 <HAL_PCD_IRQHandler+0x67c>
 80020cc:	2a00      	cmp	r2, #0
 80020ce:	da07      	bge.n	80020e0 <HAL_PCD_IRQHandler+0x67c>
          (void)HAL_PCD_EP_Abort(hpcd, (uint8_t)(epnum | 0x80U));
 80020d0:	f067 017f 	orn	r1, r7, #127	; 0x7f
          hpcd->IN_ep[epnum].is_iso_incomplete = 1U;
 80020d4:	f888 3063 	strb.w	r3, [r8, #99]	; 0x63
          (void)HAL_PCD_EP_Abort(hpcd, (uint8_t)(epnum | 0x80U));
 80020d8:	b2c9      	uxtb	r1, r1
 80020da:	4620      	mov	r0, r4
 80020dc:	f7ff fcb1 	bl	8001a42 <HAL_PCD_EP_Abort>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 80020e0:	3701      	adds	r7, #1
 80020e2:	f108 0824 	add.w	r8, r8, #36	; 0x24
 80020e6:	f109 0920 	add.w	r9, r9, #32
 80020ea:	e5c5      	b.n	8001c78 <HAL_PCD_IRQHandler+0x214>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 80020ec:	3101      	adds	r1, #1
 80020ee:	3324      	adds	r3, #36	; 0x24
 80020f0:	3020      	adds	r0, #32
 80020f2:	e5d5      	b.n	8001ca0 <HAL_PCD_IRQHandler+0x23c>

080020f4 <HAL_PCDEx_SetTxFiFo>:
         --> Txn should be configured with the minimum space of 16 words
     The FIFO is used optimally when used TxFIFOs are allocated in the top
         of the FIFO.Ex: use EP1 and EP2 as IN instead of EP1 and EP3 as IN ones.
     When DMA is used 3n * FIFO locations should be reserved for internal DMA registers */

  Tx_Offset = hpcd->Instance->GRXFSIZ;
 80020f4:	6800      	ldr	r0, [r0, #0]
{
 80020f6:	b570      	push	{r4, r5, r6, lr}

  if (fifo == 0U)
  {
    hpcd->Instance->DIEPTXF0_HNPTXFSIZ = ((uint32_t)size << 16) | Tx_Offset;
 80020f8:	0412      	lsls	r2, r2, #16
  Tx_Offset = hpcd->Instance->GRXFSIZ;
 80020fa:	6a44      	ldr	r4, [r0, #36]	; 0x24
  if (fifo == 0U)
 80020fc:	b919      	cbnz	r1, 8002106 <HAL_PCDEx_SetTxFiFo+0x12>
    hpcd->Instance->DIEPTXF0_HNPTXFSIZ = ((uint32_t)size << 16) | Tx_Offset;
 80020fe:	4322      	orrs	r2, r4
 8002100:	6282      	str	r2, [r0, #40]	; 0x28
    /* Multiply Tx_Size by 2 to get higher performance */
    hpcd->Instance->DIEPTXF[fifo - 1U] = ((uint32_t)size << 16) | Tx_Offset;
  }

  return HAL_OK;
}
 8002102:	2000      	movs	r0, #0
 8002104:	bd70      	pop	{r4, r5, r6, pc}
    Tx_Offset += (hpcd->Instance->DIEPTXF0_HNPTXFSIZ) >> 16;
 8002106:	6a83      	ldr	r3, [r0, #40]	; 0x28
    for (i = 0U; i < (fifo - 1U); i++)
 8002108:	1e4d      	subs	r5, r1, #1
    Tx_Offset += (hpcd->Instance->DIEPTXF0_HNPTXFSIZ) >> 16;
 800210a:	eb04 4413 	add.w	r4, r4, r3, lsr #16
    for (i = 0U; i < (fifo - 1U); i++)
 800210e:	2300      	movs	r3, #0
 8002110:	1c5e      	adds	r6, r3, #1
 8002112:	b2db      	uxtb	r3, r3
 8002114:	429d      	cmp	r5, r3
 8002116:	d805      	bhi.n	8002124 <HAL_PCDEx_SetTxFiFo+0x30>
    hpcd->Instance->DIEPTXF[fifo - 1U] = ((uint32_t)size << 16) | Tx_Offset;
 8002118:	313f      	adds	r1, #63	; 0x3f
 800211a:	eb00 0081 	add.w	r0, r0, r1, lsl #2
 800211e:	4322      	orrs	r2, r4
 8002120:	6042      	str	r2, [r0, #4]
 8002122:	e7ee      	b.n	8002102 <HAL_PCDEx_SetTxFiFo+0xe>
      Tx_Offset += (hpcd->Instance->DIEPTXF[i] >> 16);
 8002124:	3340      	adds	r3, #64	; 0x40
 8002126:	eb00 0383 	add.w	r3, r0, r3, lsl #2
 800212a:	685b      	ldr	r3, [r3, #4]
 800212c:	eb04 4413 	add.w	r4, r4, r3, lsr #16
 8002130:	4633      	mov	r3, r6
 8002132:	e7ed      	b.n	8002110 <HAL_PCDEx_SetTxFiFo+0x1c>

08002134 <HAL_PCDEx_SetRxFiFo>:
  * @param  size Size of Rx fifo
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCDEx_SetRxFiFo(PCD_HandleTypeDef *hpcd, uint16_t size)
{
  hpcd->Instance->GRXFSIZ = size;
 8002134:	6803      	ldr	r3, [r0, #0]

  return HAL_OK;
}
 8002136:	2000      	movs	r0, #0
  hpcd->Instance->GRXFSIZ = size;
 8002138:	6259      	str	r1, [r3, #36]	; 0x24
}
 800213a:	4770      	bx	lr

0800213c <HAL_PCDEx_LPM_Callback>:
  UNUSED(msg);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_PCDEx_LPM_Callback could be implemented in the user file
   */
}
 800213c:	4770      	bx	lr
	...

08002140 <HAL_RCC_OscConfig>:
  *         supported by this API. User should request a transition to HSE Off
  *         first and then HSE On or HSE Bypass.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
 8002140:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
  uint32_t tickstart, pll_config;

  /* Check Null pointer */
  if(RCC_OscInitStruct == NULL)
 8002144:	4604      	mov	r4, r0
 8002146:	b340      	cbz	r0, 800219a <HAL_RCC_OscConfig+0x5a>
  }

  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));
  /*------------------------------- HSE Configuration ------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 8002148:	6803      	ldr	r3, [r0, #0]
 800214a:	07dd      	lsls	r5, r3, #31
 800214c:	d410      	bmi.n	8002170 <HAL_RCC_OscConfig+0x30>
        }
      }
    }
  }
  /*----------------------------- HSI Configuration --------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 800214e:	6823      	ldr	r3, [r4, #0]
 8002150:	0798      	lsls	r0, r3, #30
 8002152:	d45b      	bmi.n	800220c <HAL_RCC_OscConfig+0xcc>
        }
      }
    }
  }
  /*------------------------------ LSI Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 8002154:	6823      	ldr	r3, [r4, #0]
 8002156:	071a      	lsls	r2, r3, #28
 8002158:	f100 809d 	bmi.w	8002296 <HAL_RCC_OscConfig+0x156>
        }
      }
    }
  }
  /*------------------------------ LSE Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 800215c:	6823      	ldr	r3, [r4, #0]
 800215e:	075b      	lsls	r3, r3, #29
 8002160:	f100 80bd 	bmi.w	80022de <HAL_RCC_OscConfig+0x19e>
    }
  }
  /*-------------------------------- PLL Configuration -----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));
  if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
 8002164:	69a0      	ldr	r0, [r4, #24]
 8002166:	2800      	cmp	r0, #0
 8002168:	f040 8124 	bne.w	80023b4 <HAL_RCC_OscConfig+0x274>
          return HAL_ERROR;
        }
      }
    }
  }
  return HAL_OK;
 800216c:	2000      	movs	r0, #0
 800216e:	e02c      	b.n	80021ca <HAL_RCC_OscConfig+0x8a>
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE) ||\
 8002170:	4b8d      	ldr	r3, [pc, #564]	; (80023a8 <HAL_RCC_OscConfig+0x268>)
 8002172:	689a      	ldr	r2, [r3, #8]
 8002174:	f002 020c 	and.w	r2, r2, #12
 8002178:	2a04      	cmp	r2, #4
 800217a:	d007      	beq.n	800218c <HAL_RCC_OscConfig+0x4c>
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)))
 800217c:	689a      	ldr	r2, [r3, #8]
 800217e:	f002 020c 	and.w	r2, r2, #12
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE) ||\
 8002182:	2a08      	cmp	r2, #8
 8002184:	d10b      	bne.n	800219e <HAL_RCC_OscConfig+0x5e>
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)))
 8002186:	685b      	ldr	r3, [r3, #4]
 8002188:	0259      	lsls	r1, r3, #9
 800218a:	d508      	bpl.n	800219e <HAL_RCC_OscConfig+0x5e>
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 800218c:	4b86      	ldr	r3, [pc, #536]	; (80023a8 <HAL_RCC_OscConfig+0x268>)
 800218e:	681b      	ldr	r3, [r3, #0]
 8002190:	039a      	lsls	r2, r3, #14
 8002192:	d5dc      	bpl.n	800214e <HAL_RCC_OscConfig+0xe>
 8002194:	6863      	ldr	r3, [r4, #4]
 8002196:	2b00      	cmp	r3, #0
 8002198:	d1d9      	bne.n	800214e <HAL_RCC_OscConfig+0xe>
          return HAL_ERROR;
 800219a:	2001      	movs	r0, #1
 800219c:	e015      	b.n	80021ca <HAL_RCC_OscConfig+0x8a>
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 800219e:	6863      	ldr	r3, [r4, #4]
 80021a0:	4d81      	ldr	r5, [pc, #516]	; (80023a8 <HAL_RCC_OscConfig+0x268>)
 80021a2:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 80021a6:	d113      	bne.n	80021d0 <HAL_RCC_OscConfig+0x90>
 80021a8:	682b      	ldr	r3, [r5, #0]
 80021aa:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 80021ae:	602b      	str	r3, [r5, #0]
        tickstart = HAL_GetTick();
 80021b0:	f7fe fe88 	bl	8000ec4 <HAL_GetTick>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 80021b4:	4e7c      	ldr	r6, [pc, #496]	; (80023a8 <HAL_RCC_OscConfig+0x268>)
        tickstart = HAL_GetTick();
 80021b6:	4605      	mov	r5, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 80021b8:	6833      	ldr	r3, [r6, #0]
 80021ba:	039b      	lsls	r3, r3, #14
 80021bc:	d4c7      	bmi.n	800214e <HAL_RCC_OscConfig+0xe>
          if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 80021be:	f7fe fe81 	bl	8000ec4 <HAL_GetTick>
 80021c2:	1b40      	subs	r0, r0, r5
 80021c4:	2864      	cmp	r0, #100	; 0x64
 80021c6:	d9f7      	bls.n	80021b8 <HAL_RCC_OscConfig+0x78>
            return HAL_TIMEOUT;
 80021c8:	2003      	movs	r0, #3
}
 80021ca:	b002      	add	sp, #8
 80021cc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 80021d0:	f5b3 2fa0 	cmp.w	r3, #327680	; 0x50000
 80021d4:	d104      	bne.n	80021e0 <HAL_RCC_OscConfig+0xa0>
 80021d6:	682b      	ldr	r3, [r5, #0]
 80021d8:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
 80021dc:	602b      	str	r3, [r5, #0]
 80021de:	e7e3      	b.n	80021a8 <HAL_RCC_OscConfig+0x68>
 80021e0:	682a      	ldr	r2, [r5, #0]
 80021e2:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 80021e6:	602a      	str	r2, [r5, #0]
 80021e8:	682a      	ldr	r2, [r5, #0]
 80021ea:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 80021ee:	602a      	str	r2, [r5, #0]
      if((RCC_OscInitStruct->HSEState) != RCC_HSE_OFF)
 80021f0:	2b00      	cmp	r3, #0
 80021f2:	d1dd      	bne.n	80021b0 <HAL_RCC_OscConfig+0x70>
        tickstart = HAL_GetTick();
 80021f4:	f7fe fe66 	bl	8000ec4 <HAL_GetTick>
 80021f8:	4606      	mov	r6, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 80021fa:	682b      	ldr	r3, [r5, #0]
 80021fc:	039f      	lsls	r7, r3, #14
 80021fe:	d5a6      	bpl.n	800214e <HAL_RCC_OscConfig+0xe>
          if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 8002200:	f7fe fe60 	bl	8000ec4 <HAL_GetTick>
 8002204:	1b80      	subs	r0, r0, r6
 8002206:	2864      	cmp	r0, #100	; 0x64
 8002208:	d9f7      	bls.n	80021fa <HAL_RCC_OscConfig+0xba>
 800220a:	e7dd      	b.n	80021c8 <HAL_RCC_OscConfig+0x88>
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI) ||\
 800220c:	4b66      	ldr	r3, [pc, #408]	; (80023a8 <HAL_RCC_OscConfig+0x268>)
 800220e:	689a      	ldr	r2, [r3, #8]
 8002210:	f012 0f0c 	tst.w	r2, #12
 8002214:	d007      	beq.n	8002226 <HAL_RCC_OscConfig+0xe6>
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)))
 8002216:	689a      	ldr	r2, [r3, #8]
 8002218:	f002 020c 	and.w	r2, r2, #12
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI) ||\
 800221c:	2a08      	cmp	r2, #8
 800221e:	d111      	bne.n	8002244 <HAL_RCC_OscConfig+0x104>
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)))
 8002220:	685b      	ldr	r3, [r3, #4]
 8002222:	025e      	lsls	r6, r3, #9
 8002224:	d40e      	bmi.n	8002244 <HAL_RCC_OscConfig+0x104>
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
 8002226:	4a60      	ldr	r2, [pc, #384]	; (80023a8 <HAL_RCC_OscConfig+0x268>)
 8002228:	6813      	ldr	r3, [r2, #0]
 800222a:	079d      	lsls	r5, r3, #30
 800222c:	d502      	bpl.n	8002234 <HAL_RCC_OscConfig+0xf4>
 800222e:	68e3      	ldr	r3, [r4, #12]
 8002230:	2b01      	cmp	r3, #1
 8002232:	d1b2      	bne.n	800219a <HAL_RCC_OscConfig+0x5a>
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 8002234:	6813      	ldr	r3, [r2, #0]
 8002236:	6921      	ldr	r1, [r4, #16]
 8002238:	f023 03f8 	bic.w	r3, r3, #248	; 0xf8
 800223c:	ea43 03c1 	orr.w	r3, r3, r1, lsl #3
 8002240:	6013      	str	r3, [r2, #0]
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
 8002242:	e787      	b.n	8002154 <HAL_RCC_OscConfig+0x14>
      if((RCC_OscInitStruct->HSIState)!= RCC_HSI_OFF)
 8002244:	68e2      	ldr	r2, [r4, #12]
 8002246:	4b59      	ldr	r3, [pc, #356]	; (80023ac <HAL_RCC_OscConfig+0x26c>)
 8002248:	b1b2      	cbz	r2, 8002278 <HAL_RCC_OscConfig+0x138>
        __HAL_RCC_HSI_ENABLE();
 800224a:	2201      	movs	r2, #1
 800224c:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
 800224e:	f7fe fe39 	bl	8000ec4 <HAL_GetTick>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 8002252:	4d55      	ldr	r5, [pc, #340]	; (80023a8 <HAL_RCC_OscConfig+0x268>)
        tickstart = HAL_GetTick();
 8002254:	4606      	mov	r6, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 8002256:	682b      	ldr	r3, [r5, #0]
 8002258:	0798      	lsls	r0, r3, #30
 800225a:	d507      	bpl.n	800226c <HAL_RCC_OscConfig+0x12c>
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 800225c:	682b      	ldr	r3, [r5, #0]
 800225e:	6922      	ldr	r2, [r4, #16]
 8002260:	f023 03f8 	bic.w	r3, r3, #248	; 0xf8
 8002264:	ea43 03c2 	orr.w	r3, r3, r2, lsl #3
 8002268:	602b      	str	r3, [r5, #0]
 800226a:	e773      	b.n	8002154 <HAL_RCC_OscConfig+0x14>
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 800226c:	f7fe fe2a 	bl	8000ec4 <HAL_GetTick>
 8002270:	1b80      	subs	r0, r0, r6
 8002272:	2802      	cmp	r0, #2
 8002274:	d9ef      	bls.n	8002256 <HAL_RCC_OscConfig+0x116>
 8002276:	e7a7      	b.n	80021c8 <HAL_RCC_OscConfig+0x88>
        __HAL_RCC_HSI_DISABLE();
 8002278:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
 800227a:	f7fe fe23 	bl	8000ec4 <HAL_GetTick>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 800227e:	4e4a      	ldr	r6, [pc, #296]	; (80023a8 <HAL_RCC_OscConfig+0x268>)
        tickstart = HAL_GetTick();
 8002280:	4605      	mov	r5, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 8002282:	6833      	ldr	r3, [r6, #0]
 8002284:	0799      	lsls	r1, r3, #30
 8002286:	f57f af65 	bpl.w	8002154 <HAL_RCC_OscConfig+0x14>
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 800228a:	f7fe fe1b 	bl	8000ec4 <HAL_GetTick>
 800228e:	1b40      	subs	r0, r0, r5
 8002290:	2802      	cmp	r0, #2
 8002292:	d9f6      	bls.n	8002282 <HAL_RCC_OscConfig+0x142>
 8002294:	e798      	b.n	80021c8 <HAL_RCC_OscConfig+0x88>
    if((RCC_OscInitStruct->LSIState)!= RCC_LSI_OFF)
 8002296:	6962      	ldr	r2, [r4, #20]
 8002298:	4b44      	ldr	r3, [pc, #272]	; (80023ac <HAL_RCC_OscConfig+0x26c>)
 800229a:	b182      	cbz	r2, 80022be <HAL_RCC_OscConfig+0x17e>
      __HAL_RCC_LSI_ENABLE();
 800229c:	2201      	movs	r2, #1
 800229e:	f8c3 2e80 	str.w	r2, [r3, #3712]	; 0xe80
      tickstart = HAL_GetTick();
 80022a2:	f7fe fe0f 	bl	8000ec4 <HAL_GetTick>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 80022a6:	4e40      	ldr	r6, [pc, #256]	; (80023a8 <HAL_RCC_OscConfig+0x268>)
      tickstart = HAL_GetTick();
 80022a8:	4605      	mov	r5, r0
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 80022aa:	6f73      	ldr	r3, [r6, #116]	; 0x74
 80022ac:	079f      	lsls	r7, r3, #30
 80022ae:	f53f af55 	bmi.w	800215c <HAL_RCC_OscConfig+0x1c>
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 80022b2:	f7fe fe07 	bl	8000ec4 <HAL_GetTick>
 80022b6:	1b40      	subs	r0, r0, r5
 80022b8:	2802      	cmp	r0, #2
 80022ba:	d9f6      	bls.n	80022aa <HAL_RCC_OscConfig+0x16a>
 80022bc:	e784      	b.n	80021c8 <HAL_RCC_OscConfig+0x88>
      __HAL_RCC_LSI_DISABLE();
 80022be:	f8c3 2e80 	str.w	r2, [r3, #3712]	; 0xe80
      tickstart = HAL_GetTick();
 80022c2:	f7fe fdff 	bl	8000ec4 <HAL_GetTick>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 80022c6:	4e38      	ldr	r6, [pc, #224]	; (80023a8 <HAL_RCC_OscConfig+0x268>)
      tickstart = HAL_GetTick();
 80022c8:	4605      	mov	r5, r0
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 80022ca:	6f73      	ldr	r3, [r6, #116]	; 0x74
 80022cc:	0798      	lsls	r0, r3, #30
 80022ce:	f57f af45 	bpl.w	800215c <HAL_RCC_OscConfig+0x1c>
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 80022d2:	f7fe fdf7 	bl	8000ec4 <HAL_GetTick>
 80022d6:	1b40      	subs	r0, r0, r5
 80022d8:	2802      	cmp	r0, #2
 80022da:	d9f6      	bls.n	80022ca <HAL_RCC_OscConfig+0x18a>
 80022dc:	e774      	b.n	80021c8 <HAL_RCC_OscConfig+0x88>
    if(__HAL_RCC_PWR_IS_CLK_DISABLED())
 80022de:	4b32      	ldr	r3, [pc, #200]	; (80023a8 <HAL_RCC_OscConfig+0x268>)
 80022e0:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 80022e2:	f012 5280 	ands.w	r2, r2, #268435456	; 0x10000000
 80022e6:	d128      	bne.n	800233a <HAL_RCC_OscConfig+0x1fa>
      __HAL_RCC_PWR_CLK_ENABLE();
 80022e8:	9201      	str	r2, [sp, #4]
 80022ea:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 80022ec:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 80022f0:	641a      	str	r2, [r3, #64]	; 0x40
 80022f2:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80022f4:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 80022f8:	9301      	str	r3, [sp, #4]
 80022fa:	9b01      	ldr	r3, [sp, #4]
      pwrclkchanged = SET;
 80022fc:	2701      	movs	r7, #1
    if(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 80022fe:	4d2c      	ldr	r5, [pc, #176]	; (80023b0 <HAL_RCC_OscConfig+0x270>)
 8002300:	682b      	ldr	r3, [r5, #0]
 8002302:	05d9      	lsls	r1, r3, #23
 8002304:	d51b      	bpl.n	800233e <HAL_RCC_OscConfig+0x1fe>
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8002306:	68a3      	ldr	r3, [r4, #8]
 8002308:	4d27      	ldr	r5, [pc, #156]	; (80023a8 <HAL_RCC_OscConfig+0x268>)
 800230a:	2b01      	cmp	r3, #1
 800230c:	d127      	bne.n	800235e <HAL_RCC_OscConfig+0x21e>
 800230e:	6f2b      	ldr	r3, [r5, #112]	; 0x70
 8002310:	f043 0301 	orr.w	r3, r3, #1
 8002314:	672b      	str	r3, [r5, #112]	; 0x70
      tickstart = HAL_GetTick();
 8002316:	f7fe fdd5 	bl	8000ec4 <HAL_GetTick>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 800231a:	4e23      	ldr	r6, [pc, #140]	; (80023a8 <HAL_RCC_OscConfig+0x268>)
      tickstart = HAL_GetTick();
 800231c:	4605      	mov	r5, r0
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 800231e:	f241 3888 	movw	r8, #5000	; 0x1388
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 8002322:	6f33      	ldr	r3, [r6, #112]	; 0x70
 8002324:	079b      	lsls	r3, r3, #30
 8002326:	d539      	bpl.n	800239c <HAL_RCC_OscConfig+0x25c>
    if(pwrclkchanged == SET)
 8002328:	2f00      	cmp	r7, #0
 800232a:	f43f af1b 	beq.w	8002164 <HAL_RCC_OscConfig+0x24>
      __HAL_RCC_PWR_CLK_DISABLE();
 800232e:	4a1e      	ldr	r2, [pc, #120]	; (80023a8 <HAL_RCC_OscConfig+0x268>)
 8002330:	6c13      	ldr	r3, [r2, #64]	; 0x40
 8002332:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 8002336:	6413      	str	r3, [r2, #64]	; 0x40
 8002338:	e714      	b.n	8002164 <HAL_RCC_OscConfig+0x24>
    FlagStatus       pwrclkchanged = RESET;
 800233a:	2700      	movs	r7, #0
 800233c:	e7df      	b.n	80022fe <HAL_RCC_OscConfig+0x1be>
      SET_BIT(PWR->CR, PWR_CR_DBP);
 800233e:	682b      	ldr	r3, [r5, #0]
 8002340:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8002344:	602b      	str	r3, [r5, #0]
      tickstart = HAL_GetTick();
 8002346:	f7fe fdbd 	bl	8000ec4 <HAL_GetTick>
 800234a:	4606      	mov	r6, r0
      while(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 800234c:	682b      	ldr	r3, [r5, #0]
 800234e:	05da      	lsls	r2, r3, #23
 8002350:	d4d9      	bmi.n	8002306 <HAL_RCC_OscConfig+0x1c6>
        if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 8002352:	f7fe fdb7 	bl	8000ec4 <HAL_GetTick>
 8002356:	1b80      	subs	r0, r0, r6
 8002358:	2802      	cmp	r0, #2
 800235a:	d9f7      	bls.n	800234c <HAL_RCC_OscConfig+0x20c>
 800235c:	e734      	b.n	80021c8 <HAL_RCC_OscConfig+0x88>
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 800235e:	2b05      	cmp	r3, #5
 8002360:	d104      	bne.n	800236c <HAL_RCC_OscConfig+0x22c>
 8002362:	6f2b      	ldr	r3, [r5, #112]	; 0x70
 8002364:	f043 0304 	orr.w	r3, r3, #4
 8002368:	672b      	str	r3, [r5, #112]	; 0x70
 800236a:	e7d0      	b.n	800230e <HAL_RCC_OscConfig+0x1ce>
 800236c:	6f2a      	ldr	r2, [r5, #112]	; 0x70
 800236e:	f022 0201 	bic.w	r2, r2, #1
 8002372:	672a      	str	r2, [r5, #112]	; 0x70
 8002374:	6f2a      	ldr	r2, [r5, #112]	; 0x70
 8002376:	f022 0204 	bic.w	r2, r2, #4
 800237a:	672a      	str	r2, [r5, #112]	; 0x70
    if((RCC_OscInitStruct->LSEState) != RCC_LSE_OFF)
 800237c:	2b00      	cmp	r3, #0
 800237e:	d1ca      	bne.n	8002316 <HAL_RCC_OscConfig+0x1d6>
      tickstart = HAL_GetTick();
 8002380:	f7fe fda0 	bl	8000ec4 <HAL_GetTick>
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8002384:	f241 3888 	movw	r8, #5000	; 0x1388
      tickstart = HAL_GetTick();
 8002388:	4606      	mov	r6, r0
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 800238a:	6f2b      	ldr	r3, [r5, #112]	; 0x70
 800238c:	0798      	lsls	r0, r3, #30
 800238e:	d5cb      	bpl.n	8002328 <HAL_RCC_OscConfig+0x1e8>
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8002390:	f7fe fd98 	bl	8000ec4 <HAL_GetTick>
 8002394:	1b80      	subs	r0, r0, r6
 8002396:	4540      	cmp	r0, r8
 8002398:	d9f7      	bls.n	800238a <HAL_RCC_OscConfig+0x24a>
 800239a:	e715      	b.n	80021c8 <HAL_RCC_OscConfig+0x88>
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 800239c:	f7fe fd92 	bl	8000ec4 <HAL_GetTick>
 80023a0:	1b40      	subs	r0, r0, r5
 80023a2:	4540      	cmp	r0, r8
 80023a4:	d9bd      	bls.n	8002322 <HAL_RCC_OscConfig+0x1e2>
 80023a6:	e70f      	b.n	80021c8 <HAL_RCC_OscConfig+0x88>
 80023a8:	40023800 	.word	0x40023800
 80023ac:	42470000 	.word	0x42470000
 80023b0:	40007000 	.word	0x40007000
    if(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL)
 80023b4:	4d36      	ldr	r5, [pc, #216]	; (8002490 <HAL_RCC_OscConfig+0x350>)
 80023b6:	68ab      	ldr	r3, [r5, #8]
 80023b8:	f003 030c 	and.w	r3, r3, #12
 80023bc:	2b08      	cmp	r3, #8
 80023be:	d03d      	beq.n	800243c <HAL_RCC_OscConfig+0x2fc>
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
 80023c0:	4b34      	ldr	r3, [pc, #208]	; (8002494 <HAL_RCC_OscConfig+0x354>)
 80023c2:	2200      	movs	r2, #0
 80023c4:	2802      	cmp	r0, #2
        __HAL_RCC_PLL_DISABLE();
 80023c6:	661a      	str	r2, [r3, #96]	; 0x60
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
 80023c8:	d12b      	bne.n	8002422 <HAL_RCC_OscConfig+0x2e2>
        tickstart = HAL_GetTick();
 80023ca:	f7fe fd7b 	bl	8000ec4 <HAL_GetTick>
 80023ce:	4606      	mov	r6, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 80023d0:	682b      	ldr	r3, [r5, #0]
 80023d2:	0199      	lsls	r1, r3, #6
 80023d4:	d41f      	bmi.n	8002416 <HAL_RCC_OscConfig+0x2d6>
        WRITE_REG(RCC->PLLCFGR, (RCC_OscInitStruct->PLL.PLLSource                                            | \
 80023d6:	e9d4 3207 	ldrd	r3, r2, [r4, #28]
 80023da:	4313      	orrs	r3, r2
 80023dc:	6a62      	ldr	r2, [r4, #36]	; 0x24
 80023de:	ea43 1382 	orr.w	r3, r3, r2, lsl #6
 80023e2:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 80023e4:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 80023e8:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 80023ea:	0852      	lsrs	r2, r2, #1
 80023ec:	3a01      	subs	r2, #1
 80023ee:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
 80023f2:	606b      	str	r3, [r5, #4]
        __HAL_RCC_PLL_ENABLE();
 80023f4:	4b27      	ldr	r3, [pc, #156]	; (8002494 <HAL_RCC_OscConfig+0x354>)
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 80023f6:	4d26      	ldr	r5, [pc, #152]	; (8002490 <HAL_RCC_OscConfig+0x350>)
        __HAL_RCC_PLL_ENABLE();
 80023f8:	2201      	movs	r2, #1
 80023fa:	661a      	str	r2, [r3, #96]	; 0x60
        tickstart = HAL_GetTick();
 80023fc:	f7fe fd62 	bl	8000ec4 <HAL_GetTick>
 8002400:	4604      	mov	r4, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 8002402:	682b      	ldr	r3, [r5, #0]
 8002404:	019a      	lsls	r2, r3, #6
 8002406:	f53f aeb1 	bmi.w	800216c <HAL_RCC_OscConfig+0x2c>
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 800240a:	f7fe fd5b 	bl	8000ec4 <HAL_GetTick>
 800240e:	1b00      	subs	r0, r0, r4
 8002410:	2802      	cmp	r0, #2
 8002412:	d9f6      	bls.n	8002402 <HAL_RCC_OscConfig+0x2c2>
 8002414:	e6d8      	b.n	80021c8 <HAL_RCC_OscConfig+0x88>
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 8002416:	f7fe fd55 	bl	8000ec4 <HAL_GetTick>
 800241a:	1b80      	subs	r0, r0, r6
 800241c:	2802      	cmp	r0, #2
 800241e:	d9d7      	bls.n	80023d0 <HAL_RCC_OscConfig+0x290>
 8002420:	e6d2      	b.n	80021c8 <HAL_RCC_OscConfig+0x88>
        tickstart = HAL_GetTick();
 8002422:	f7fe fd4f 	bl	8000ec4 <HAL_GetTick>
 8002426:	4604      	mov	r4, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 8002428:	682b      	ldr	r3, [r5, #0]
 800242a:	019b      	lsls	r3, r3, #6
 800242c:	f57f ae9e 	bpl.w	800216c <HAL_RCC_OscConfig+0x2c>
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 8002430:	f7fe fd48 	bl	8000ec4 <HAL_GetTick>
 8002434:	1b00      	subs	r0, r0, r4
 8002436:	2802      	cmp	r0, #2
 8002438:	d9f6      	bls.n	8002428 <HAL_RCC_OscConfig+0x2e8>
 800243a:	e6c5      	b.n	80021c8 <HAL_RCC_OscConfig+0x88>
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF)
 800243c:	2801      	cmp	r0, #1
 800243e:	f43f aec4 	beq.w	80021ca <HAL_RCC_OscConfig+0x8a>
        pll_config = RCC->PLLCFGR;
 8002442:	686b      	ldr	r3, [r5, #4]
        if (((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF) ||
 8002444:	69e2      	ldr	r2, [r4, #28]
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||
 8002446:	f403 0180 	and.w	r1, r3, #4194304	; 0x400000
        if (((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF) ||
 800244a:	4291      	cmp	r1, r2
 800244c:	f47f aea5 	bne.w	800219a <HAL_RCC_OscConfig+0x5a>
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||
 8002450:	6a21      	ldr	r1, [r4, #32]
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLM) != (RCC_OscInitStruct->PLL.PLLM) << RCC_PLLCFGR_PLLM_Pos) ||
 8002452:	f003 023f 	and.w	r2, r3, #63	; 0x3f
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||
 8002456:	428a      	cmp	r2, r1
 8002458:	f47f ae9f 	bne.w	800219a <HAL_RCC_OscConfig+0x5a>
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLN) != (RCC_OscInitStruct->PLL.PLLN) << RCC_PLLCFGR_PLLN_Pos) ||
 800245c:	6a61      	ldr	r1, [r4, #36]	; 0x24
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLM) != (RCC_OscInitStruct->PLL.PLLM) << RCC_PLLCFGR_PLLM_Pos) ||
 800245e:	f647 72c0 	movw	r2, #32704	; 0x7fc0
 8002462:	401a      	ands	r2, r3
 8002464:	ebb2 1f81 	cmp.w	r2, r1, lsl #6
 8002468:	f47f ae97 	bne.w	800219a <HAL_RCC_OscConfig+0x5a>
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLP) != (((RCC_OscInitStruct->PLL.PLLP >> 1U) - 1U)) << RCC_PLLCFGR_PLLP_Pos) ||
 800246c:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 800246e:	0852      	lsrs	r2, r2, #1
 8002470:	f403 3140 	and.w	r1, r3, #196608	; 0x30000
 8002474:	3a01      	subs	r2, #1
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLN) != (RCC_OscInitStruct->PLL.PLLN) << RCC_PLLCFGR_PLLN_Pos) ||
 8002476:	ebb1 4f02 	cmp.w	r1, r2, lsl #16
 800247a:	f47f ae8e 	bne.w	800219a <HAL_RCC_OscConfig+0x5a>
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLQ) != (RCC_OscInitStruct->PLL.PLLQ << RCC_PLLCFGR_PLLQ_Pos)))
 800247e:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8002480:	f003 6370 	and.w	r3, r3, #251658240	; 0xf000000
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLP) != (((RCC_OscInitStruct->PLL.PLLP >> 1U) - 1U)) << RCC_PLLCFGR_PLLP_Pos) ||
 8002484:	ebb3 6f02 	cmp.w	r3, r2, lsl #24
 8002488:	f43f ae70 	beq.w	800216c <HAL_RCC_OscConfig+0x2c>
 800248c:	e685      	b.n	800219a <HAL_RCC_OscConfig+0x5a>
 800248e:	bf00      	nop
 8002490:	40023800 	.word	0x40023800
 8002494:	42470000 	.word	0x42470000

08002498 <HAL_RCC_GetSysClockFreq>:
{
  uint32_t pllm = 0U, pllvco = 0U, pllp = 0U;
  uint32_t sysclockfreq = 0U;

  /* Get SYSCLK source -------------------------------------------------------*/
  switch (RCC->CFGR & RCC_CFGR_SWS)
 8002498:	4913      	ldr	r1, [pc, #76]	; (80024e8 <HAL_RCC_GetSysClockFreq+0x50>)
{
 800249a:	b508      	push	{r3, lr}
  switch (RCC->CFGR & RCC_CFGR_SWS)
 800249c:	688b      	ldr	r3, [r1, #8]
 800249e:	f003 030c 	and.w	r3, r3, #12
 80024a2:	2b04      	cmp	r3, #4
 80024a4:	d01c      	beq.n	80024e0 <HAL_RCC_GetSysClockFreq+0x48>
 80024a6:	2b08      	cmp	r3, #8
 80024a8:	d11c      	bne.n	80024e4 <HAL_RCC_GetSysClockFreq+0x4c>
    }
    case RCC_CFGR_SWS_PLL:  /* PLL used as system clock  source */
    {
      /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLLM) * PLLN
      SYSCLK = PLL_VCO / PLLP */
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 80024aa:	684a      	ldr	r2, [r1, #4]
      if(__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLSOURCE_HSI)
 80024ac:	684b      	ldr	r3, [r1, #4]
      {
        /* HSE used as PLL clock source */
        pllvco = (uint32_t) ((((uint64_t) HSE_VALUE * ((uint64_t) ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
 80024ae:	6849      	ldr	r1, [r1, #4]
      if(__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLSOURCE_HSI)
 80024b0:	f413 0380 	ands.w	r3, r3, #4194304	; 0x400000
        pllvco = (uint32_t) ((((uint64_t) HSE_VALUE * ((uint64_t) ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
 80024b4:	bf14      	ite	ne
 80024b6:	480d      	ldrne	r0, [pc, #52]	; (80024ec <HAL_RCC_GetSysClockFreq+0x54>)
      }
      else
      {
        /* HSI used as PLL clock source */
        pllvco = (uint32_t) ((((uint64_t) HSI_VALUE * ((uint64_t) ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
 80024b8:	480d      	ldreq	r0, [pc, #52]	; (80024f0 <HAL_RCC_GetSysClockFreq+0x58>)
        pllvco = (uint32_t) ((((uint64_t) HSE_VALUE * ((uint64_t) ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
 80024ba:	f3c1 1188 	ubfx	r1, r1, #6, #9
 80024be:	bf18      	it	ne
 80024c0:	2300      	movne	r3, #0
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 80024c2:	f002 023f 	and.w	r2, r2, #63	; 0x3f
        pllvco = (uint32_t) ((((uint64_t) HSI_VALUE * ((uint64_t) ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
 80024c6:	fba1 0100 	umull	r0, r1, r1, r0
 80024ca:	f7fd fe7d 	bl	80001c8 <__aeabi_uldivmod>
      }
      pllp = ((((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >> RCC_PLLCFGR_PLLP_Pos) + 1U) *2U);
 80024ce:	4b06      	ldr	r3, [pc, #24]	; (80024e8 <HAL_RCC_GetSysClockFreq+0x50>)
 80024d0:	685b      	ldr	r3, [r3, #4]
 80024d2:	f3c3 4301 	ubfx	r3, r3, #16, #2
 80024d6:	3301      	adds	r3, #1
 80024d8:	005b      	lsls	r3, r3, #1

      sysclockfreq = pllvco/pllp;
 80024da:	fbb0 f0f3 	udiv	r0, r0, r3
      sysclockfreq = HSI_VALUE;
      break;
    }
  }
  return sysclockfreq;
}
 80024de:	bd08      	pop	{r3, pc}
  switch (RCC->CFGR & RCC_CFGR_SWS)
 80024e0:	4802      	ldr	r0, [pc, #8]	; (80024ec <HAL_RCC_GetSysClockFreq+0x54>)
 80024e2:	e7fc      	b.n	80024de <HAL_RCC_GetSysClockFreq+0x46>
      sysclockfreq = HSI_VALUE;
 80024e4:	4802      	ldr	r0, [pc, #8]	; (80024f0 <HAL_RCC_GetSysClockFreq+0x58>)
  return sysclockfreq;
 80024e6:	e7fa      	b.n	80024de <HAL_RCC_GetSysClockFreq+0x46>
 80024e8:	40023800 	.word	0x40023800
 80024ec:	017d7840 	.word	0x017d7840
 80024f0:	00f42400 	.word	0x00f42400

080024f4 <HAL_RCC_ClockConfig>:
{
 80024f4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80024f8:	460d      	mov	r5, r1
  if(RCC_ClkInitStruct == NULL)
 80024fa:	4604      	mov	r4, r0
 80024fc:	b910      	cbnz	r0, 8002504 <HAL_RCC_ClockConfig+0x10>
    return HAL_ERROR;
 80024fe:	2001      	movs	r0, #1
}
 8002500:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  if(FLatency > __HAL_FLASH_GET_LATENCY())
 8002504:	4b43      	ldr	r3, [pc, #268]	; (8002614 <HAL_RCC_ClockConfig+0x120>)
 8002506:	681a      	ldr	r2, [r3, #0]
 8002508:	f002 0207 	and.w	r2, r2, #7
 800250c:	428a      	cmp	r2, r1
 800250e:	d328      	bcc.n	8002562 <HAL_RCC_ClockConfig+0x6e>
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 8002510:	6821      	ldr	r1, [r4, #0]
 8002512:	078f      	lsls	r7, r1, #30
 8002514:	d42d      	bmi.n	8002572 <HAL_RCC_ClockConfig+0x7e>
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 8002516:	07c8      	lsls	r0, r1, #31
 8002518:	d440      	bmi.n	800259c <HAL_RCC_ClockConfig+0xa8>
  if(FLatency < __HAL_FLASH_GET_LATENCY())
 800251a:	4b3e      	ldr	r3, [pc, #248]	; (8002614 <HAL_RCC_ClockConfig+0x120>)
 800251c:	681a      	ldr	r2, [r3, #0]
 800251e:	f002 0207 	and.w	r2, r2, #7
 8002522:	42aa      	cmp	r2, r5
 8002524:	d865      	bhi.n	80025f2 <HAL_RCC_ClockConfig+0xfe>
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 8002526:	6822      	ldr	r2, [r4, #0]
 8002528:	0751      	lsls	r1, r2, #29
 800252a:	d46b      	bmi.n	8002604 <HAL_RCC_ClockConfig+0x110>
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 800252c:	0713      	lsls	r3, r2, #28
 800252e:	d507      	bpl.n	8002540 <HAL_RCC_ClockConfig+0x4c>
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, ((RCC_ClkInitStruct->APB2CLKDivider) << 3U));
 8002530:	4a39      	ldr	r2, [pc, #228]	; (8002618 <HAL_RCC_ClockConfig+0x124>)
 8002532:	6921      	ldr	r1, [r4, #16]
 8002534:	6893      	ldr	r3, [r2, #8]
 8002536:	f423 4360 	bic.w	r3, r3, #57344	; 0xe000
 800253a:	ea43 03c1 	orr.w	r3, r3, r1, lsl #3
 800253e:	6093      	str	r3, [r2, #8]
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE)>> RCC_CFGR_HPRE_Pos];
 8002540:	f7ff ffaa 	bl	8002498 <HAL_RCC_GetSysClockFreq>
 8002544:	4b34      	ldr	r3, [pc, #208]	; (8002618 <HAL_RCC_ClockConfig+0x124>)
 8002546:	4a35      	ldr	r2, [pc, #212]	; (800261c <HAL_RCC_ClockConfig+0x128>)
 8002548:	689b      	ldr	r3, [r3, #8]
 800254a:	f3c3 1303 	ubfx	r3, r3, #4, #4
 800254e:	5cd3      	ldrb	r3, [r2, r3]
 8002550:	40d8      	lsrs	r0, r3
 8002552:	4b33      	ldr	r3, [pc, #204]	; (8002620 <HAL_RCC_ClockConfig+0x12c>)
 8002554:	6018      	str	r0, [r3, #0]
  HAL_InitTick (uwTickPrio);
 8002556:	4b33      	ldr	r3, [pc, #204]	; (8002624 <HAL_RCC_ClockConfig+0x130>)
 8002558:	6818      	ldr	r0, [r3, #0]
 800255a:	f7fe fc6f 	bl	8000e3c <HAL_InitTick>
  return HAL_OK;
 800255e:	2000      	movs	r0, #0
 8002560:	e7ce      	b.n	8002500 <HAL_RCC_ClockConfig+0xc>
    __HAL_FLASH_SET_LATENCY(FLatency);
 8002562:	b2ca      	uxtb	r2, r1
 8002564:	701a      	strb	r2, [r3, #0]
    if(__HAL_FLASH_GET_LATENCY() != FLatency)
 8002566:	681b      	ldr	r3, [r3, #0]
 8002568:	f003 0307 	and.w	r3, r3, #7
 800256c:	428b      	cmp	r3, r1
 800256e:	d1c6      	bne.n	80024fe <HAL_RCC_ClockConfig+0xa>
 8002570:	e7ce      	b.n	8002510 <HAL_RCC_ClockConfig+0x1c>
    if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 8002572:	4b29      	ldr	r3, [pc, #164]	; (8002618 <HAL_RCC_ClockConfig+0x124>)
 8002574:	f011 0f04 	tst.w	r1, #4
      MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_HCLK_DIV16);
 8002578:	bf1e      	ittt	ne
 800257a:	689a      	ldrne	r2, [r3, #8]
 800257c:	f442 52e0 	orrne.w	r2, r2, #7168	; 0x1c00
 8002580:	609a      	strne	r2, [r3, #8]
    if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 8002582:	070e      	lsls	r6, r1, #28
      MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, (RCC_HCLK_DIV16 << 3));
 8002584:	bf42      	ittt	mi
 8002586:	689a      	ldrmi	r2, [r3, #8]
 8002588:	f442 4260 	orrmi.w	r2, r2, #57344	; 0xe000
 800258c:	609a      	strmi	r2, [r3, #8]
    MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 800258e:	689a      	ldr	r2, [r3, #8]
 8002590:	68a0      	ldr	r0, [r4, #8]
 8002592:	f022 02f0 	bic.w	r2, r2, #240	; 0xf0
 8002596:	4302      	orrs	r2, r0
 8002598:	609a      	str	r2, [r3, #8]
 800259a:	e7bc      	b.n	8002516 <HAL_RCC_ClockConfig+0x22>
    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 800259c:	6862      	ldr	r2, [r4, #4]
 800259e:	4b1e      	ldr	r3, [pc, #120]	; (8002618 <HAL_RCC_ClockConfig+0x124>)
 80025a0:	2a01      	cmp	r2, #1
 80025a2:	d11c      	bne.n	80025de <HAL_RCC_ClockConfig+0xea>
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 80025a4:	681b      	ldr	r3, [r3, #0]
 80025a6:	f413 3f00 	tst.w	r3, #131072	; 0x20000
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 80025aa:	d0a8      	beq.n	80024fe <HAL_RCC_ClockConfig+0xa>
    __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
 80025ac:	4e1a      	ldr	r6, [pc, #104]	; (8002618 <HAL_RCC_ClockConfig+0x124>)
 80025ae:	68b3      	ldr	r3, [r6, #8]
 80025b0:	f023 0303 	bic.w	r3, r3, #3
 80025b4:	4313      	orrs	r3, r2
 80025b6:	60b3      	str	r3, [r6, #8]
    tickstart = HAL_GetTick();
 80025b8:	f7fe fc84 	bl	8000ec4 <HAL_GetTick>
      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 80025bc:	f241 3888 	movw	r8, #5000	; 0x1388
    tickstart = HAL_GetTick();
 80025c0:	4607      	mov	r7, r0
    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 80025c2:	68b3      	ldr	r3, [r6, #8]
 80025c4:	6862      	ldr	r2, [r4, #4]
 80025c6:	f003 030c 	and.w	r3, r3, #12
 80025ca:	ebb3 0f82 	cmp.w	r3, r2, lsl #2
 80025ce:	d0a4      	beq.n	800251a <HAL_RCC_ClockConfig+0x26>
      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 80025d0:	f7fe fc78 	bl	8000ec4 <HAL_GetTick>
 80025d4:	1bc0      	subs	r0, r0, r7
 80025d6:	4540      	cmp	r0, r8
 80025d8:	d9f3      	bls.n	80025c2 <HAL_RCC_ClockConfig+0xce>
        return HAL_TIMEOUT;
 80025da:	2003      	movs	r0, #3
 80025dc:	e790      	b.n	8002500 <HAL_RCC_ClockConfig+0xc>
    else if((RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)   ||
 80025de:	1e91      	subs	r1, r2, #2
 80025e0:	2901      	cmp	r1, #1
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 80025e2:	681b      	ldr	r3, [r3, #0]
    else if((RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)   ||
 80025e4:	d802      	bhi.n	80025ec <HAL_RCC_ClockConfig+0xf8>
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 80025e6:	f013 7f00 	tst.w	r3, #33554432	; 0x2000000
 80025ea:	e7de      	b.n	80025aa <HAL_RCC_ClockConfig+0xb6>
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 80025ec:	f013 0f02 	tst.w	r3, #2
 80025f0:	e7db      	b.n	80025aa <HAL_RCC_ClockConfig+0xb6>
    __HAL_FLASH_SET_LATENCY(FLatency);
 80025f2:	b2ea      	uxtb	r2, r5
 80025f4:	701a      	strb	r2, [r3, #0]
    if(__HAL_FLASH_GET_LATENCY() != FLatency)
 80025f6:	681b      	ldr	r3, [r3, #0]
 80025f8:	f003 0307 	and.w	r3, r3, #7
 80025fc:	42ab      	cmp	r3, r5
 80025fe:	f47f af7e 	bne.w	80024fe <HAL_RCC_ClockConfig+0xa>
 8002602:	e790      	b.n	8002526 <HAL_RCC_ClockConfig+0x32>
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_ClkInitStruct->APB1CLKDivider);
 8002604:	4904      	ldr	r1, [pc, #16]	; (8002618 <HAL_RCC_ClockConfig+0x124>)
 8002606:	68e0      	ldr	r0, [r4, #12]
 8002608:	688b      	ldr	r3, [r1, #8]
 800260a:	f423 53e0 	bic.w	r3, r3, #7168	; 0x1c00
 800260e:	4303      	orrs	r3, r0
 8002610:	608b      	str	r3, [r1, #8]
 8002612:	e78b      	b.n	800252c <HAL_RCC_ClockConfig+0x38>
 8002614:	40023c00 	.word	0x40023c00
 8002618:	40023800 	.word	0x40023800
 800261c:	08004a8c 	.word	0x08004a8c
 8002620:	2000006c 	.word	0x2000006c
 8002624:	20000074 	.word	0x20000074

08002628 <HAL_RCC_GetHCLKFreq>:
  * @retval HCLK frequency
  */
uint32_t HAL_RCC_GetHCLKFreq(void)
{
  return SystemCoreClock;
}
 8002628:	4b01      	ldr	r3, [pc, #4]	; (8002630 <HAL_RCC_GetHCLKFreq+0x8>)
 800262a:	6818      	ldr	r0, [r3, #0]
 800262c:	4770      	bx	lr
 800262e:	bf00      	nop
 8002630:	2000006c 	.word	0x2000006c

08002634 <HAL_RCC_GetPCLK1Freq>:
  * @retval PCLK1 frequency
  */
uint32_t HAL_RCC_GetPCLK1Freq(void)
{
  /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE1)>> RCC_CFGR_PPRE1_Pos]);
 8002634:	4b04      	ldr	r3, [pc, #16]	; (8002648 <HAL_RCC_GetPCLK1Freq+0x14>)
 8002636:	4a05      	ldr	r2, [pc, #20]	; (800264c <HAL_RCC_GetPCLK1Freq+0x18>)
 8002638:	689b      	ldr	r3, [r3, #8]
 800263a:	f3c3 2382 	ubfx	r3, r3, #10, #3
 800263e:	5cd3      	ldrb	r3, [r2, r3]
 8002640:	4a03      	ldr	r2, [pc, #12]	; (8002650 <HAL_RCC_GetPCLK1Freq+0x1c>)
 8002642:	6810      	ldr	r0, [r2, #0]
}
 8002644:	40d8      	lsrs	r0, r3
 8002646:	4770      	bx	lr
 8002648:	40023800 	.word	0x40023800
 800264c:	08004a9c 	.word	0x08004a9c
 8002650:	2000006c 	.word	0x2000006c

08002654 <HAL_RCC_GetPCLK2Freq>:
  * @retval PCLK2 frequency
  */
uint32_t HAL_RCC_GetPCLK2Freq(void)
{
  /* Get HCLK source and Compute PCLK2 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq()>> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE2)>> RCC_CFGR_PPRE2_Pos]);
 8002654:	4b04      	ldr	r3, [pc, #16]	; (8002668 <HAL_RCC_GetPCLK2Freq+0x14>)
 8002656:	4a05      	ldr	r2, [pc, #20]	; (800266c <HAL_RCC_GetPCLK2Freq+0x18>)
 8002658:	689b      	ldr	r3, [r3, #8]
 800265a:	f3c3 3342 	ubfx	r3, r3, #13, #3
 800265e:	5cd3      	ldrb	r3, [r2, r3]
 8002660:	4a03      	ldr	r2, [pc, #12]	; (8002670 <HAL_RCC_GetPCLK2Freq+0x1c>)
 8002662:	6810      	ldr	r0, [r2, #0]
}
 8002664:	40d8      	lsrs	r0, r3
 8002666:	4770      	bx	lr
 8002668:	40023800 	.word	0x40023800
 800266c:	08004a9c 	.word	0x08004a9c
 8002670:	2000006c 	.word	0x2000006c

08002674 <HAL_TIM_Base_MspInit>:
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_Base_MspInit could be implemented in the user file
   */
}
 8002674:	4770      	bx	lr
	...

08002678 <HAL_TIM_Base_Start_IT>:

  /* Check the parameters */
  assert_param(IS_TIM_INSTANCE(htim->Instance));

  /* Check the TIM state */
  if (htim->State != HAL_TIM_STATE_READY)
 8002678:	f890 303d 	ldrb.w	r3, [r0, #61]	; 0x3d
 800267c:	2b01      	cmp	r3, #1
 800267e:	d130      	bne.n	80026e2 <HAL_TIM_Base_Start_IT+0x6a>
  {
    return HAL_ERROR;
  }

  /* Set the TIM state */
  htim->State = HAL_TIM_STATE_BUSY;
 8002680:	2302      	movs	r3, #2
 8002682:	f880 303d 	strb.w	r3, [r0, #61]	; 0x3d

  /* Enable the TIM Update interrupt */
  __HAL_TIM_ENABLE_IT(htim, TIM_IT_UPDATE);
 8002686:	6803      	ldr	r3, [r0, #0]
 8002688:	68da      	ldr	r2, [r3, #12]
 800268a:	f042 0201 	orr.w	r2, r2, #1
 800268e:	60da      	str	r2, [r3, #12]

  /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
 8002690:	4a15      	ldr	r2, [pc, #84]	; (80026e8 <HAL_TIM_Base_Start_IT+0x70>)
 8002692:	4293      	cmp	r3, r2
 8002694:	d01a      	beq.n	80026cc <HAL_TIM_Base_Start_IT+0x54>
 8002696:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 800269a:	d017      	beq.n	80026cc <HAL_TIM_Base_Start_IT+0x54>
 800269c:	f5a2 427c 	sub.w	r2, r2, #64512	; 0xfc00
 80026a0:	4293      	cmp	r3, r2
 80026a2:	d013      	beq.n	80026cc <HAL_TIM_Base_Start_IT+0x54>
 80026a4:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 80026a8:	4293      	cmp	r3, r2
 80026aa:	d00f      	beq.n	80026cc <HAL_TIM_Base_Start_IT+0x54>
 80026ac:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 80026b0:	4293      	cmp	r3, r2
 80026b2:	d00b      	beq.n	80026cc <HAL_TIM_Base_Start_IT+0x54>
 80026b4:	f502 4278 	add.w	r2, r2, #63488	; 0xf800
 80026b8:	4293      	cmp	r3, r2
 80026ba:	d007      	beq.n	80026cc <HAL_TIM_Base_Start_IT+0x54>
 80026bc:	f502 5270 	add.w	r2, r2, #15360	; 0x3c00
 80026c0:	4293      	cmp	r3, r2
 80026c2:	d003      	beq.n	80026cc <HAL_TIM_Base_Start_IT+0x54>
 80026c4:	f5a2 3294 	sub.w	r2, r2, #75776	; 0x12800
 80026c8:	4293      	cmp	r3, r2
 80026ca:	d104      	bne.n	80026d6 <HAL_TIM_Base_Start_IT+0x5e>
  {
    tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
 80026cc:	689a      	ldr	r2, [r3, #8]
 80026ce:	f002 0207 	and.w	r2, r2, #7
    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
 80026d2:	2a06      	cmp	r2, #6
 80026d4:	d003      	beq.n	80026de <HAL_TIM_Base_Start_IT+0x66>
      __HAL_TIM_ENABLE(htim);
    }
  }
  else
  {
    __HAL_TIM_ENABLE(htim);
 80026d6:	681a      	ldr	r2, [r3, #0]
 80026d8:	f042 0201 	orr.w	r2, r2, #1
 80026dc:	601a      	str	r2, [r3, #0]
  }

  /* Return function status */
  return HAL_OK;
 80026de:	2000      	movs	r0, #0
}
 80026e0:	4770      	bx	lr
    return HAL_ERROR;
 80026e2:	2001      	movs	r0, #1
 80026e4:	4770      	bx	lr
 80026e6:	bf00      	nop
 80026e8:	40010000 	.word	0x40010000

080026ec <HAL_TIM_OC_DelayElapsedCallback>:
 80026ec:	4770      	bx	lr

080026ee <HAL_TIM_IC_CaptureCallback>:
 80026ee:	4770      	bx	lr

080026f0 <HAL_TIM_PWM_PulseFinishedCallback>:
 80026f0:	4770      	bx	lr

080026f2 <HAL_TIM_TriggerCallback>:
 80026f2:	4770      	bx	lr

080026f4 <HAL_TIM_IRQHandler>:
  * @retval None
  */
void HAL_TIM_IRQHandler(TIM_HandleTypeDef *htim)
{
  /* Capture compare 1 event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC1) != RESET)
 80026f4:	6803      	ldr	r3, [r0, #0]
 80026f6:	691a      	ldr	r2, [r3, #16]
 80026f8:	0791      	lsls	r1, r2, #30
{
 80026fa:	b510      	push	{r4, lr}
 80026fc:	4604      	mov	r4, r0
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC1) != RESET)
 80026fe:	d50e      	bpl.n	800271e <HAL_TIM_IRQHandler+0x2a>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC1) != RESET)
 8002700:	68da      	ldr	r2, [r3, #12]
 8002702:	0792      	lsls	r2, r2, #30
 8002704:	d50b      	bpl.n	800271e <HAL_TIM_IRQHandler+0x2a>
    {
      {
        __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC1);
 8002706:	f06f 0202 	mvn.w	r2, #2
 800270a:	611a      	str	r2, [r3, #16]
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
 800270c:	2201      	movs	r2, #1
 800270e:	7702      	strb	r2, [r0, #28]

        /* Input capture event */
        if ((htim->Instance->CCMR1 & TIM_CCMR1_CC1S) != 0x00U)
 8002710:	699b      	ldr	r3, [r3, #24]
 8002712:	079b      	lsls	r3, r3, #30
 8002714:	d077      	beq.n	8002806 <HAL_TIM_IRQHandler+0x112>
        {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
          htim->IC_CaptureCallback(htim);
#else
          HAL_TIM_IC_CaptureCallback(htim);
 8002716:	f7ff ffea 	bl	80026ee <HAL_TIM_IC_CaptureCallback>
#else
          HAL_TIM_OC_DelayElapsedCallback(htim);
          HAL_TIM_PWM_PulseFinishedCallback(htim);
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
        }
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 800271a:	2300      	movs	r3, #0
 800271c:	7723      	strb	r3, [r4, #28]
      }
    }
  }
  /* Capture compare 2 event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC2) != RESET)
 800271e:	6823      	ldr	r3, [r4, #0]
 8002720:	691a      	ldr	r2, [r3, #16]
 8002722:	0750      	lsls	r0, r2, #29
 8002724:	d510      	bpl.n	8002748 <HAL_TIM_IRQHandler+0x54>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC2) != RESET)
 8002726:	68da      	ldr	r2, [r3, #12]
 8002728:	0751      	lsls	r1, r2, #29
 800272a:	d50d      	bpl.n	8002748 <HAL_TIM_IRQHandler+0x54>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC2);
 800272c:	f06f 0204 	mvn.w	r2, #4
 8002730:	611a      	str	r2, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
 8002732:	2202      	movs	r2, #2
 8002734:	7722      	strb	r2, [r4, #28]
      /* Input capture event */
      if ((htim->Instance->CCMR1 & TIM_CCMR1_CC2S) != 0x00U)
 8002736:	699b      	ldr	r3, [r3, #24]
 8002738:	f413 7f40 	tst.w	r3, #768	; 0x300
      {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
        htim->IC_CaptureCallback(htim);
#else
        HAL_TIM_IC_CaptureCallback(htim);
 800273c:	4620      	mov	r0, r4
      if ((htim->Instance->CCMR1 & TIM_CCMR1_CC2S) != 0x00U)
 800273e:	d068      	beq.n	8002812 <HAL_TIM_IRQHandler+0x11e>
        HAL_TIM_IC_CaptureCallback(htim);
 8002740:	f7ff ffd5 	bl	80026ee <HAL_TIM_IC_CaptureCallback>
#else
        HAL_TIM_OC_DelayElapsedCallback(htim);
        HAL_TIM_PWM_PulseFinishedCallback(htim);
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
      }
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 8002744:	2300      	movs	r3, #0
 8002746:	7723      	strb	r3, [r4, #28]
    }
  }
  /* Capture compare 3 event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC3) != RESET)
 8002748:	6823      	ldr	r3, [r4, #0]
 800274a:	691a      	ldr	r2, [r3, #16]
 800274c:	0712      	lsls	r2, r2, #28
 800274e:	d50f      	bpl.n	8002770 <HAL_TIM_IRQHandler+0x7c>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC3) != RESET)
 8002750:	68da      	ldr	r2, [r3, #12]
 8002752:	0710      	lsls	r0, r2, #28
 8002754:	d50c      	bpl.n	8002770 <HAL_TIM_IRQHandler+0x7c>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC3);
 8002756:	f06f 0208 	mvn.w	r2, #8
 800275a:	611a      	str	r2, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
 800275c:	2204      	movs	r2, #4
 800275e:	7722      	strb	r2, [r4, #28]
      /* Input capture event */
      if ((htim->Instance->CCMR2 & TIM_CCMR2_CC3S) != 0x00U)
 8002760:	69db      	ldr	r3, [r3, #28]
 8002762:	0799      	lsls	r1, r3, #30
      {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
        htim->IC_CaptureCallback(htim);
#else
        HAL_TIM_IC_CaptureCallback(htim);
 8002764:	4620      	mov	r0, r4
      if ((htim->Instance->CCMR2 & TIM_CCMR2_CC3S) != 0x00U)
 8002766:	d05a      	beq.n	800281e <HAL_TIM_IRQHandler+0x12a>
        HAL_TIM_IC_CaptureCallback(htim);
 8002768:	f7ff ffc1 	bl	80026ee <HAL_TIM_IC_CaptureCallback>
#else
        HAL_TIM_OC_DelayElapsedCallback(htim);
        HAL_TIM_PWM_PulseFinishedCallback(htim);
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
      }
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 800276c:	2300      	movs	r3, #0
 800276e:	7723      	strb	r3, [r4, #28]
    }
  }
  /* Capture compare 4 event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC4) != RESET)
 8002770:	6823      	ldr	r3, [r4, #0]
 8002772:	691a      	ldr	r2, [r3, #16]
 8002774:	06d2      	lsls	r2, r2, #27
 8002776:	d510      	bpl.n	800279a <HAL_TIM_IRQHandler+0xa6>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC4) != RESET)
 8002778:	68da      	ldr	r2, [r3, #12]
 800277a:	06d0      	lsls	r0, r2, #27
 800277c:	d50d      	bpl.n	800279a <HAL_TIM_IRQHandler+0xa6>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC4);
 800277e:	f06f 0210 	mvn.w	r2, #16
 8002782:	611a      	str	r2, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
 8002784:	2208      	movs	r2, #8
 8002786:	7722      	strb	r2, [r4, #28]
      /* Input capture event */
      if ((htim->Instance->CCMR2 & TIM_CCMR2_CC4S) != 0x00U)
 8002788:	69db      	ldr	r3, [r3, #28]
 800278a:	f413 7f40 	tst.w	r3, #768	; 0x300
      {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
        htim->IC_CaptureCallback(htim);
#else
        HAL_TIM_IC_CaptureCallback(htim);
 800278e:	4620      	mov	r0, r4
      if ((htim->Instance->CCMR2 & TIM_CCMR2_CC4S) != 0x00U)
 8002790:	d04b      	beq.n	800282a <HAL_TIM_IRQHandler+0x136>
        HAL_TIM_IC_CaptureCallback(htim);
 8002792:	f7ff ffac 	bl	80026ee <HAL_TIM_IC_CaptureCallback>
#else
        HAL_TIM_OC_DelayElapsedCallback(htim);
        HAL_TIM_PWM_PulseFinishedCallback(htim);
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
      }
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 8002796:	2300      	movs	r3, #0
 8002798:	7723      	strb	r3, [r4, #28]
    }
  }
  /* TIM Update event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_UPDATE) != RESET)
 800279a:	6823      	ldr	r3, [r4, #0]
 800279c:	691a      	ldr	r2, [r3, #16]
 800279e:	07d1      	lsls	r1, r2, #31
 80027a0:	d508      	bpl.n	80027b4 <HAL_TIM_IRQHandler+0xc0>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_UPDATE) != RESET)
 80027a2:	68da      	ldr	r2, [r3, #12]
 80027a4:	07d2      	lsls	r2, r2, #31
 80027a6:	d505      	bpl.n	80027b4 <HAL_TIM_IRQHandler+0xc0>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_UPDATE);
 80027a8:	f06f 0201 	mvn.w	r2, #1
 80027ac:	611a      	str	r2, [r3, #16]
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
      htim->PeriodElapsedCallback(htim);
#else
      HAL_TIM_PeriodElapsedCallback(htim);
 80027ae:	4620      	mov	r0, r4
 80027b0:	f7fe f8a4 	bl	80008fc <HAL_TIM_PeriodElapsedCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    }
  }
  /* TIM Break input event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_BREAK) != RESET)
 80027b4:	6823      	ldr	r3, [r4, #0]
 80027b6:	691a      	ldr	r2, [r3, #16]
 80027b8:	0610      	lsls	r0, r2, #24
 80027ba:	d508      	bpl.n	80027ce <HAL_TIM_IRQHandler+0xda>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_BREAK) != RESET)
 80027bc:	68da      	ldr	r2, [r3, #12]
 80027be:	0611      	lsls	r1, r2, #24
 80027c0:	d505      	bpl.n	80027ce <HAL_TIM_IRQHandler+0xda>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_BREAK);
 80027c2:	f06f 0280 	mvn.w	r2, #128	; 0x80
 80027c6:	611a      	str	r2, [r3, #16]
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
      htim->BreakCallback(htim);
#else
      HAL_TIMEx_BreakCallback(htim);
 80027c8:	4620      	mov	r0, r4
 80027ca:	f000 f8c8 	bl	800295e <HAL_TIMEx_BreakCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    }
  }
  /* TIM Trigger detection event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_TRIGGER) != RESET)
 80027ce:	6823      	ldr	r3, [r4, #0]
 80027d0:	691a      	ldr	r2, [r3, #16]
 80027d2:	0652      	lsls	r2, r2, #25
 80027d4:	d508      	bpl.n	80027e8 <HAL_TIM_IRQHandler+0xf4>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_TRIGGER) != RESET)
 80027d6:	68da      	ldr	r2, [r3, #12]
 80027d8:	0650      	lsls	r0, r2, #25
 80027da:	d505      	bpl.n	80027e8 <HAL_TIM_IRQHandler+0xf4>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_TRIGGER);
 80027dc:	f06f 0240 	mvn.w	r2, #64	; 0x40
 80027e0:	611a      	str	r2, [r3, #16]
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
      htim->TriggerCallback(htim);
#else
      HAL_TIM_TriggerCallback(htim);
 80027e2:	4620      	mov	r0, r4
 80027e4:	f7ff ff85 	bl	80026f2 <HAL_TIM_TriggerCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    }
  }
  /* TIM commutation event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_COM) != RESET)
 80027e8:	6823      	ldr	r3, [r4, #0]
 80027ea:	691a      	ldr	r2, [r3, #16]
 80027ec:	0691      	lsls	r1, r2, #26
 80027ee:	d522      	bpl.n	8002836 <HAL_TIM_IRQHandler+0x142>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_COM) != RESET)
 80027f0:	68da      	ldr	r2, [r3, #12]
 80027f2:	0692      	lsls	r2, r2, #26
 80027f4:	d51f      	bpl.n	8002836 <HAL_TIM_IRQHandler+0x142>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_FLAG_COM);
 80027f6:	f06f 0220 	mvn.w	r2, #32
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
      htim->CommutationCallback(htim);
#else
      HAL_TIMEx_CommutCallback(htim);
 80027fa:	4620      	mov	r0, r4
      __HAL_TIM_CLEAR_IT(htim, TIM_FLAG_COM);
 80027fc:	611a      	str	r2, [r3, #16]
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    }
  }
}
 80027fe:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      HAL_TIMEx_CommutCallback(htim);
 8002802:	f000 b8ab 	b.w	800295c <HAL_TIMEx_CommutCallback>
          HAL_TIM_OC_DelayElapsedCallback(htim);
 8002806:	f7ff ff71 	bl	80026ec <HAL_TIM_OC_DelayElapsedCallback>
          HAL_TIM_PWM_PulseFinishedCallback(htim);
 800280a:	4620      	mov	r0, r4
 800280c:	f7ff ff70 	bl	80026f0 <HAL_TIM_PWM_PulseFinishedCallback>
 8002810:	e783      	b.n	800271a <HAL_TIM_IRQHandler+0x26>
        HAL_TIM_OC_DelayElapsedCallback(htim);
 8002812:	f7ff ff6b 	bl	80026ec <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 8002816:	4620      	mov	r0, r4
 8002818:	f7ff ff6a 	bl	80026f0 <HAL_TIM_PWM_PulseFinishedCallback>
 800281c:	e792      	b.n	8002744 <HAL_TIM_IRQHandler+0x50>
        HAL_TIM_OC_DelayElapsedCallback(htim);
 800281e:	f7ff ff65 	bl	80026ec <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 8002822:	4620      	mov	r0, r4
 8002824:	f7ff ff64 	bl	80026f0 <HAL_TIM_PWM_PulseFinishedCallback>
 8002828:	e7a0      	b.n	800276c <HAL_TIM_IRQHandler+0x78>
        HAL_TIM_OC_DelayElapsedCallback(htim);
 800282a:	f7ff ff5f 	bl	80026ec <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 800282e:	4620      	mov	r0, r4
 8002830:	f7ff ff5e 	bl	80026f0 <HAL_TIM_PWM_PulseFinishedCallback>
 8002834:	e7af      	b.n	8002796 <HAL_TIM_IRQHandler+0xa2>
}
 8002836:	bd10      	pop	{r4, pc}

08002838 <TIM_Base_SetConfig>:
{
  uint32_t tmpcr1;
  tmpcr1 = TIMx->CR1;

  /* Set TIM Time Base Unit parameters ---------------------------------------*/
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 8002838:	4a30      	ldr	r2, [pc, #192]	; (80028fc <TIM_Base_SetConfig+0xc4>)
  tmpcr1 = TIMx->CR1;
 800283a:	6803      	ldr	r3, [r0, #0]
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 800283c:	4290      	cmp	r0, r2
 800283e:	d012      	beq.n	8002866 <TIM_Base_SetConfig+0x2e>
 8002840:	f1b0 4f80 	cmp.w	r0, #1073741824	; 0x40000000
 8002844:	d00f      	beq.n	8002866 <TIM_Base_SetConfig+0x2e>
 8002846:	f5a2 427c 	sub.w	r2, r2, #64512	; 0xfc00
 800284a:	4290      	cmp	r0, r2
 800284c:	d00b      	beq.n	8002866 <TIM_Base_SetConfig+0x2e>
 800284e:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8002852:	4290      	cmp	r0, r2
 8002854:	d007      	beq.n	8002866 <TIM_Base_SetConfig+0x2e>
 8002856:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 800285a:	4290      	cmp	r0, r2
 800285c:	d003      	beq.n	8002866 <TIM_Base_SetConfig+0x2e>
 800285e:	f502 4278 	add.w	r2, r2, #63488	; 0xf800
 8002862:	4290      	cmp	r0, r2
 8002864:	d119      	bne.n	800289a <TIM_Base_SetConfig+0x62>
  {
    /* Select the Counter Mode */
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
    tmpcr1 |= Structure->CounterMode;
 8002866:	684a      	ldr	r2, [r1, #4]
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
 8002868:	f023 0370 	bic.w	r3, r3, #112	; 0x70
    tmpcr1 |= Structure->CounterMode;
 800286c:	4313      	orrs	r3, r2
  }

  if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
 800286e:	4a23      	ldr	r2, [pc, #140]	; (80028fc <TIM_Base_SetConfig+0xc4>)
 8002870:	4290      	cmp	r0, r2
 8002872:	d029      	beq.n	80028c8 <TIM_Base_SetConfig+0x90>
 8002874:	f1b0 4f80 	cmp.w	r0, #1073741824	; 0x40000000
 8002878:	d026      	beq.n	80028c8 <TIM_Base_SetConfig+0x90>
 800287a:	f5a2 427c 	sub.w	r2, r2, #64512	; 0xfc00
 800287e:	4290      	cmp	r0, r2
 8002880:	d022      	beq.n	80028c8 <TIM_Base_SetConfig+0x90>
 8002882:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8002886:	4290      	cmp	r0, r2
 8002888:	d01e      	beq.n	80028c8 <TIM_Base_SetConfig+0x90>
 800288a:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 800288e:	4290      	cmp	r0, r2
 8002890:	d01a      	beq.n	80028c8 <TIM_Base_SetConfig+0x90>
 8002892:	f502 4278 	add.w	r2, r2, #63488	; 0xf800
 8002896:	4290      	cmp	r0, r2
 8002898:	d016      	beq.n	80028c8 <TIM_Base_SetConfig+0x90>
 800289a:	4a19      	ldr	r2, [pc, #100]	; (8002900 <TIM_Base_SetConfig+0xc8>)
 800289c:	4290      	cmp	r0, r2
 800289e:	d013      	beq.n	80028c8 <TIM_Base_SetConfig+0x90>
 80028a0:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 80028a4:	4290      	cmp	r0, r2
 80028a6:	d00f      	beq.n	80028c8 <TIM_Base_SetConfig+0x90>
 80028a8:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 80028ac:	4290      	cmp	r0, r2
 80028ae:	d00b      	beq.n	80028c8 <TIM_Base_SetConfig+0x90>
 80028b0:	f5a2 3298 	sub.w	r2, r2, #77824	; 0x13000
 80028b4:	4290      	cmp	r0, r2
 80028b6:	d007      	beq.n	80028c8 <TIM_Base_SetConfig+0x90>
 80028b8:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 80028bc:	4290      	cmp	r0, r2
 80028be:	d003      	beq.n	80028c8 <TIM_Base_SetConfig+0x90>
 80028c0:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 80028c4:	4290      	cmp	r0, r2
 80028c6:	d103      	bne.n	80028d0 <TIM_Base_SetConfig+0x98>
  {
    /* Set the clock division */
    tmpcr1 &= ~TIM_CR1_CKD;
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 80028c8:	68ca      	ldr	r2, [r1, #12]
    tmpcr1 &= ~TIM_CR1_CKD;
 80028ca:	f423 7340 	bic.w	r3, r3, #768	; 0x300
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 80028ce:	4313      	orrs	r3, r2
  }

  /* Set the auto-reload preload */
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 80028d0:	694a      	ldr	r2, [r1, #20]
 80028d2:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 80028d6:	4313      	orrs	r3, r2

  TIMx->CR1 = tmpcr1;
 80028d8:	6003      	str	r3, [r0, #0]

  /* Set the Autoreload value */
  TIMx->ARR = (uint32_t)Structure->Period ;
 80028da:	688b      	ldr	r3, [r1, #8]
 80028dc:	62c3      	str	r3, [r0, #44]	; 0x2c

  /* Set the Prescaler value */
  TIMx->PSC = Structure->Prescaler;
 80028de:	680b      	ldr	r3, [r1, #0]
 80028e0:	6283      	str	r3, [r0, #40]	; 0x28

  if (IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx))
 80028e2:	4b06      	ldr	r3, [pc, #24]	; (80028fc <TIM_Base_SetConfig+0xc4>)
 80028e4:	4298      	cmp	r0, r3
 80028e6:	d003      	beq.n	80028f0 <TIM_Base_SetConfig+0xb8>
 80028e8:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 80028ec:	4298      	cmp	r0, r3
 80028ee:	d101      	bne.n	80028f4 <TIM_Base_SetConfig+0xbc>
  {
    /* Set the Repetition Counter value */
    TIMx->RCR = Structure->RepetitionCounter;
 80028f0:	690b      	ldr	r3, [r1, #16]
 80028f2:	6303      	str	r3, [r0, #48]	; 0x30
  }

  /* Generate an update event to reload the Prescaler
     and the repetition counter (only for advanced timer) value immediately */
  TIMx->EGR = TIM_EGR_UG;
 80028f4:	2301      	movs	r3, #1
 80028f6:	6143      	str	r3, [r0, #20]
}
 80028f8:	4770      	bx	lr
 80028fa:	bf00      	nop
 80028fc:	40010000 	.word	0x40010000
 8002900:	40014000 	.word	0x40014000

08002904 <HAL_TIM_Base_Init>:
{
 8002904:	b510      	push	{r4, lr}
  if (htim == NULL)
 8002906:	4604      	mov	r4, r0
 8002908:	b330      	cbz	r0, 8002958 <HAL_TIM_Base_Init+0x54>
  if (htim->State == HAL_TIM_STATE_RESET)
 800290a:	f890 303d 	ldrb.w	r3, [r0, #61]	; 0x3d
 800290e:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 8002912:	b91b      	cbnz	r3, 800291c <HAL_TIM_Base_Init+0x18>
    htim->Lock = HAL_UNLOCKED;
 8002914:	f880 203c 	strb.w	r2, [r0, #60]	; 0x3c
    HAL_TIM_Base_MspInit(htim);
 8002918:	f7ff feac 	bl	8002674 <HAL_TIM_Base_MspInit>
  htim->State = HAL_TIM_STATE_BUSY;
 800291c:	2302      	movs	r3, #2
  TIM_Base_SetConfig(htim->Instance, &htim->Init);
 800291e:	6820      	ldr	r0, [r4, #0]
  htim->State = HAL_TIM_STATE_BUSY;
 8002920:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
  TIM_Base_SetConfig(htim->Instance, &htim->Init);
 8002924:	1d21      	adds	r1, r4, #4
 8002926:	f7ff ff87 	bl	8002838 <TIM_Base_SetConfig>
  htim->DMABurstState = HAL_DMA_BURST_STATE_READY;
 800292a:	2301      	movs	r3, #1
 800292c:	f884 3046 	strb.w	r3, [r4, #70]	; 0x46
  return HAL_OK;
 8002930:	2000      	movs	r0, #0
  TIM_CHANNEL_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
 8002932:	f884 303e 	strb.w	r3, [r4, #62]	; 0x3e
 8002936:	f884 303f 	strb.w	r3, [r4, #63]	; 0x3f
 800293a:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
 800293e:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
  TIM_CHANNEL_N_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
 8002942:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
 8002946:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
 800294a:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
 800294e:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
  htim->State = HAL_TIM_STATE_READY;
 8002952:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
}
 8002956:	bd10      	pop	{r4, pc}
    return HAL_ERROR;
 8002958:	2001      	movs	r0, #1
 800295a:	e7fc      	b.n	8002956 <HAL_TIM_Base_Init+0x52>

0800295c <HAL_TIMEx_CommutCallback>:
 800295c:	4770      	bx	lr

0800295e <HAL_TIMEx_BreakCallback>:
 800295e:	4770      	bx	lr

08002960 <UART_EndRxTransfer>:
  * @retval None
  */
static void UART_EndRxTransfer(UART_HandleTypeDef *huart)
{
  /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
  ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
 8002960:	6802      	ldr	r2, [r0, #0]
 */
__STATIC_FORCEINLINE uint32_t __LDREXW(volatile uint32_t *addr)
{
    uint32_t result;

   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8002962:	f102 030c 	add.w	r3, r2, #12
 8002966:	e853 3f00 	ldrex	r3, [r3]
 800296a:	f423 7390 	bic.w	r3, r3, #288	; 0x120
 */
__STATIC_FORCEINLINE uint32_t __STREXW(uint32_t value, volatile uint32_t *addr)
{
   uint32_t result;

   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 800296e:	320c      	adds	r2, #12
 8002970:	e842 3100 	strex	r1, r3, [r2]
   return(result);
 8002974:	6802      	ldr	r2, [r0, #0]
 8002976:	2900      	cmp	r1, #0
 8002978:	d1f2      	bne.n	8002960 <UART_EndRxTransfer>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 800297a:	f102 0314 	add.w	r3, r2, #20
 800297e:	e853 3f00 	ldrex	r3, [r3]
  ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 8002982:	f023 0301 	bic.w	r3, r3, #1
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8002986:	f102 0c14 	add.w	ip, r2, #20
 800298a:	e84c 3100 	strex	r1, r3, [ip]
 800298e:	2900      	cmp	r1, #0
 8002990:	d1f3      	bne.n	800297a <UART_EndRxTransfer+0x1a>

  /* In case of reception waiting for IDLE event, disable also the IDLE IE interrupt source */
  if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 8002992:	6b03      	ldr	r3, [r0, #48]	; 0x30
 8002994:	2b01      	cmp	r3, #1
 8002996:	d10b      	bne.n	80029b0 <UART_EndRxTransfer+0x50>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8002998:	f102 030c 	add.w	r3, r2, #12
 800299c:	e853 3f00 	ldrex	r3, [r3]
  {
    ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 80029a0:	f023 0310 	bic.w	r3, r3, #16
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 80029a4:	f102 0c0c 	add.w	ip, r2, #12
 80029a8:	e84c 3100 	strex	r1, r3, [ip]
 80029ac:	2900      	cmp	r1, #0
 80029ae:	d1f3      	bne.n	8002998 <UART_EndRxTransfer+0x38>
  }

  /* At end of Rx process, restore huart->RxState to Ready */
  huart->RxState = HAL_UART_STATE_READY;
 80029b0:	2320      	movs	r3, #32
 80029b2:	f880 303e 	strb.w	r3, [r0, #62]	; 0x3e
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 80029b6:	2300      	movs	r3, #0
 80029b8:	6303      	str	r3, [r0, #48]	; 0x30
}
 80029ba:	4770      	bx	lr

080029bc <UART_SetConfig>:
  assert_param(IS_UART_MODE(huart->Init.Mode));

  /*-------------------------- USART CR2 Configuration -----------------------*/
  /* Configure the UART Stop Bits: Set STOP[13:12] bits
     according to huart->Init.StopBits value */
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
 80029bc:	6802      	ldr	r2, [r0, #0]
 80029be:	68c1      	ldr	r1, [r0, #12]
 80029c0:	6913      	ldr	r3, [r2, #16]
 80029c2:	f423 5340 	bic.w	r3, r3, #12288	; 0x3000
 80029c6:	430b      	orrs	r3, r1
{
 80029c8:	b570      	push	{r4, r5, r6, lr}
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
 80029ca:	6113      	str	r3, [r2, #16]
{
 80029cc:	4605      	mov	r5, r0
     Set the M bits according to huart->Init.WordLength value
     Set PCE and PS bits according to huart->Init.Parity value
     Set TE and RE bits according to huart->Init.Mode value
     Set OVER8 bit according to huart->Init.OverSampling value */

  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling;
 80029ce:	6883      	ldr	r3, [r0, #8]
 80029d0:	6900      	ldr	r0, [r0, #16]
  MODIFY_REG(huart->Instance->CR1,
 80029d2:	68d1      	ldr	r1, [r2, #12]
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling;
 80029d4:	4303      	orrs	r3, r0
 80029d6:	6968      	ldr	r0, [r5, #20]
 80029d8:	4303      	orrs	r3, r0
 80029da:	69e8      	ldr	r0, [r5, #28]
  MODIFY_REG(huart->Instance->CR1,
 80029dc:	f421 4116 	bic.w	r1, r1, #38400	; 0x9600
 80029e0:	f021 010c 	bic.w	r1, r1, #12
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling;
 80029e4:	4303      	orrs	r3, r0
  MODIFY_REG(huart->Instance->CR1,
 80029e6:	430b      	orrs	r3, r1
 80029e8:	60d3      	str	r3, [r2, #12]
             (uint32_t)(USART_CR1_M | USART_CR1_PCE | USART_CR1_PS | USART_CR1_TE | USART_CR1_RE | USART_CR1_OVER8),
             tmpreg);

  /*-------------------------- USART CR3 Configuration -----------------------*/
  /* Configure the UART HFC: Set CTSE and RTSE bits according to huart->Init.HwFlowCtl value */
  MODIFY_REG(huart->Instance->CR3, (USART_CR3_RTSE | USART_CR3_CTSE), huart->Init.HwFlowCtl);
 80029ea:	6953      	ldr	r3, [r2, #20]
 80029ec:	69a9      	ldr	r1, [r5, #24]
 80029ee:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 80029f2:	430b      	orrs	r3, r1
 80029f4:	6153      	str	r3, [r2, #20]
    if ((huart->Instance == USART1) || (huart->Instance == USART6) || (huart->Instance == UART9) || (huart->Instance == UART10))
    {
      pclk = HAL_RCC_GetPCLK2Freq();
    }
#elif defined(USART6)
    if ((huart->Instance == USART1) || (huart->Instance == USART6))
 80029f6:	4b1f      	ldr	r3, [pc, #124]	; (8002a74 <UART_SetConfig+0xb8>)
 80029f8:	429a      	cmp	r2, r3
 80029fa:	d003      	beq.n	8002a04 <UART_SetConfig+0x48>
 80029fc:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8002a00:	429a      	cmp	r2, r3
 8002a02:	d123      	bne.n	8002a4c <UART_SetConfig+0x90>
    {
      pclk = HAL_RCC_GetPCLK2Freq();
 8002a04:	f7ff fe26 	bl	8002654 <HAL_RCC_GetPCLK2Freq>
    else
    {
      pclk = HAL_RCC_GetPCLK1Freq();
    }
  /*-------------------------- USART BRR Configuration ---------------------*/
  if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 8002a08:	69eb      	ldr	r3, [r5, #28]
  {
    huart->Instance->BRR = UART_BRR_SAMPLING8(pclk, huart->Init.BaudRate);
 8002a0a:	2119      	movs	r1, #25
  if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 8002a0c:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
    huart->Instance->BRR = UART_BRR_SAMPLING8(pclk, huart->Init.BaudRate);
 8002a10:	e9d5 4600 	ldrd	r4, r6, [r5]
 8002a14:	fba0 0101 	umull	r0, r1, r0, r1
  if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 8002a18:	d11b      	bne.n	8002a52 <UART_SetConfig+0x96>
    huart->Instance->BRR = UART_BRR_SAMPLING8(pclk, huart->Init.BaudRate);
 8002a1a:	19b2      	adds	r2, r6, r6
 8002a1c:	f04f 0300 	mov.w	r3, #0
 8002a20:	415b      	adcs	r3, r3
 8002a22:	f7fd fbd1 	bl	80001c8 <__aeabi_uldivmod>
 8002a26:	2264      	movs	r2, #100	; 0x64
 8002a28:	fbb0 f1f2 	udiv	r1, r0, r2
 8002a2c:	fb02 0311 	mls	r3, r2, r1, r0
 8002a30:	00db      	lsls	r3, r3, #3
 8002a32:	3332      	adds	r3, #50	; 0x32
 8002a34:	fbb3 f3f2 	udiv	r3, r3, r2
 8002a38:	f003 0207 	and.w	r2, r3, #7
 8002a3c:	005b      	lsls	r3, r3, #1
 8002a3e:	eb02 1201 	add.w	r2, r2, r1, lsl #4
 8002a42:	f403 73f8 	and.w	r3, r3, #496	; 0x1f0
 8002a46:	4413      	add	r3, r2
  }
  else
  {
    huart->Instance->BRR = UART_BRR_SAMPLING16(pclk, huart->Init.BaudRate);
 8002a48:	60a3      	str	r3, [r4, #8]
  }
}
 8002a4a:	bd70      	pop	{r4, r5, r6, pc}
      pclk = HAL_RCC_GetPCLK1Freq();
 8002a4c:	f7ff fdf2 	bl	8002634 <HAL_RCC_GetPCLK1Freq>
 8002a50:	e7da      	b.n	8002a08 <UART_SetConfig+0x4c>
    huart->Instance->BRR = UART_BRR_SAMPLING16(pclk, huart->Init.BaudRate);
 8002a52:	00b2      	lsls	r2, r6, #2
 8002a54:	0fb3      	lsrs	r3, r6, #30
 8002a56:	f7fd fbb7 	bl	80001c8 <__aeabi_uldivmod>
 8002a5a:	2264      	movs	r2, #100	; 0x64
 8002a5c:	fbb0 f1f2 	udiv	r1, r0, r2
 8002a60:	fb02 0311 	mls	r3, r2, r1, r0
 8002a64:	011b      	lsls	r3, r3, #4
 8002a66:	3332      	adds	r3, #50	; 0x32
 8002a68:	fbb3 f3f2 	udiv	r3, r3, r2
 8002a6c:	eb03 1301 	add.w	r3, r3, r1, lsl #4
 8002a70:	e7ea      	b.n	8002a48 <UART_SetConfig+0x8c>
 8002a72:	bf00      	nop
 8002a74:	40011000 	.word	0x40011000

08002a78 <HAL_UART_Init>:
{
 8002a78:	b510      	push	{r4, lr}
  if (huart == NULL)
 8002a7a:	4604      	mov	r4, r0
 8002a7c:	b340      	cbz	r0, 8002ad0 <HAL_UART_Init+0x58>
  if (huart->gState == HAL_UART_STATE_RESET)
 8002a7e:	f890 303d 	ldrb.w	r3, [r0, #61]	; 0x3d
 8002a82:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 8002a86:	b91b      	cbnz	r3, 8002a90 <HAL_UART_Init+0x18>
    huart->Lock = HAL_UNLOCKED;
 8002a88:	f880 203c 	strb.w	r2, [r0, #60]	; 0x3c
    HAL_UART_MspInit(huart);
 8002a8c:	f7fd fdae 	bl	80005ec <HAL_UART_MspInit>
  __HAL_UART_DISABLE(huart);
 8002a90:	6822      	ldr	r2, [r4, #0]
  huart->gState = HAL_UART_STATE_BUSY;
 8002a92:	2324      	movs	r3, #36	; 0x24
 8002a94:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
  __HAL_UART_DISABLE(huart);
 8002a98:	68d3      	ldr	r3, [r2, #12]
 8002a9a:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 8002a9e:	60d3      	str	r3, [r2, #12]
  UART_SetConfig(huart);
 8002aa0:	4620      	mov	r0, r4
 8002aa2:	f7ff ff8b 	bl	80029bc <UART_SetConfig>
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
 8002aa6:	6823      	ldr	r3, [r4, #0]
 8002aa8:	691a      	ldr	r2, [r3, #16]
 8002aaa:	f422 4290 	bic.w	r2, r2, #18432	; 0x4800
 8002aae:	611a      	str	r2, [r3, #16]
  CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
 8002ab0:	695a      	ldr	r2, [r3, #20]
 8002ab2:	f022 022a 	bic.w	r2, r2, #42	; 0x2a
 8002ab6:	615a      	str	r2, [r3, #20]
  __HAL_UART_ENABLE(huart);
 8002ab8:	68da      	ldr	r2, [r3, #12]
 8002aba:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
 8002abe:	60da      	str	r2, [r3, #12]
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 8002ac0:	2000      	movs	r0, #0
  huart->gState = HAL_UART_STATE_READY;
 8002ac2:	2320      	movs	r3, #32
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 8002ac4:	6420      	str	r0, [r4, #64]	; 0x40
  huart->gState = HAL_UART_STATE_READY;
 8002ac6:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
  huart->RxState = HAL_UART_STATE_READY;
 8002aca:	f884 303e 	strb.w	r3, [r4, #62]	; 0x3e
}
 8002ace:	bd10      	pop	{r4, pc}
    return HAL_ERROR;
 8002ad0:	2001      	movs	r0, #1
 8002ad2:	e7fc      	b.n	8002ace <HAL_UART_Init+0x56>

08002ad4 <HAL_UART_DeInit>:
{
 8002ad4:	b510      	push	{r4, lr}
  if (huart == NULL)
 8002ad6:	4604      	mov	r4, r0
 8002ad8:	b198      	cbz	r0, 8002b02 <HAL_UART_DeInit+0x2e>
  __HAL_UART_DISABLE(huart);
 8002ada:	6802      	ldr	r2, [r0, #0]
  huart->gState = HAL_UART_STATE_BUSY;
 8002adc:	2324      	movs	r3, #36	; 0x24
 8002ade:	f880 303d 	strb.w	r3, [r0, #61]	; 0x3d
  __HAL_UART_DISABLE(huart);
 8002ae2:	68d3      	ldr	r3, [r2, #12]
 8002ae4:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 8002ae8:	60d3      	str	r3, [r2, #12]
  HAL_UART_MspDeInit(huart);
 8002aea:	f7fd fe0d 	bl	8000708 <HAL_UART_MspDeInit>
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 8002aee:	2000      	movs	r0, #0
 8002af0:	6420      	str	r0, [r4, #64]	; 0x40
  __HAL_UNLOCK(huart);
 8002af2:	f884 003c 	strb.w	r0, [r4, #60]	; 0x3c
  huart->gState = HAL_UART_STATE_RESET;
 8002af6:	f884 003d 	strb.w	r0, [r4, #61]	; 0x3d
  huart->RxState = HAL_UART_STATE_RESET;
 8002afa:	f884 003e 	strb.w	r0, [r4, #62]	; 0x3e
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 8002afe:	6320      	str	r0, [r4, #48]	; 0x30
}
 8002b00:	bd10      	pop	{r4, pc}
    return HAL_ERROR;
 8002b02:	2001      	movs	r0, #1
 8002b04:	e7fc      	b.n	8002b00 <HAL_UART_DeInit+0x2c>
	...

08002b08 <HAL_UART_Transmit_DMA>:
{
 8002b08:	b538      	push	{r3, r4, r5, lr}
 8002b0a:	4604      	mov	r4, r0
 8002b0c:	4613      	mov	r3, r2
  if (huart->gState == HAL_UART_STATE_READY)
 8002b0e:	f894 203d 	ldrb.w	r2, [r4, #61]	; 0x3d
 8002b12:	2a20      	cmp	r2, #32
 8002b14:	d132      	bne.n	8002b7c <HAL_UART_Transmit_DMA+0x74>
    if ((pData == NULL) || (Size == 0U))
 8002b16:	b379      	cbz	r1, 8002b78 <HAL_UART_Transmit_DMA+0x70>
 8002b18:	b373      	cbz	r3, 8002b78 <HAL_UART_Transmit_DMA+0x70>
    __HAL_LOCK(huart);
 8002b1a:	f894 203c 	ldrb.w	r2, [r4, #60]	; 0x3c
 8002b1e:	2a01      	cmp	r2, #1
 8002b20:	d02c      	beq.n	8002b7c <HAL_UART_Transmit_DMA+0x74>
 8002b22:	2201      	movs	r2, #1
 8002b24:	f884 203c 	strb.w	r2, [r4, #60]	; 0x3c
    huart->hdmatx->XferCpltCallback = UART_DMATransmitCplt;
 8002b28:	6b60      	ldr	r0, [r4, #52]	; 0x34
    huart->TxXferCount = Size;
 8002b2a:	84e3      	strh	r3, [r4, #38]	; 0x26
    huart->ErrorCode = HAL_UART_ERROR_NONE;
 8002b2c:	2500      	movs	r5, #0
    huart->gState = HAL_UART_STATE_BUSY_TX;
 8002b2e:	2221      	movs	r2, #33	; 0x21
    huart->ErrorCode = HAL_UART_ERROR_NONE;
 8002b30:	6425      	str	r5, [r4, #64]	; 0x40
    huart->gState = HAL_UART_STATE_BUSY_TX;
 8002b32:	f884 203d 	strb.w	r2, [r4, #61]	; 0x3d
    huart->hdmatx->XferCpltCallback = UART_DMATransmitCplt;
 8002b36:	4a12      	ldr	r2, [pc, #72]	; (8002b80 <HAL_UART_Transmit_DMA+0x78>)
    huart->TxXferSize = Size;
 8002b38:	84a3      	strh	r3, [r4, #36]	; 0x24
    huart->pTxBuffPtr = pData;
 8002b3a:	6221      	str	r1, [r4, #32]
    huart->hdmatx->XferCpltCallback = UART_DMATransmitCplt;
 8002b3c:	63c2      	str	r2, [r0, #60]	; 0x3c
    huart->hdmatx->XferHalfCpltCallback = UART_DMATxHalfCplt;
 8002b3e:	4a11      	ldr	r2, [pc, #68]	; (8002b84 <HAL_UART_Transmit_DMA+0x7c>)
 8002b40:	6402      	str	r2, [r0, #64]	; 0x40
    huart->hdmatx->XferErrorCallback = UART_DMAError;
 8002b42:	4a11      	ldr	r2, [pc, #68]	; (8002b88 <HAL_UART_Transmit_DMA+0x80>)
    huart->hdmatx->XferAbortCallback = NULL;
 8002b44:	e9c0 2513 	strd	r2, r5, [r0, #76]	; 0x4c
    HAL_DMA_Start_IT(huart->hdmatx, *(const uint32_t *)tmp, (uint32_t)&huart->Instance->DR, Size);
 8002b48:	6822      	ldr	r2, [r4, #0]
 8002b4a:	3204      	adds	r2, #4
 8002b4c:	f7fe fae6 	bl	800111c <HAL_DMA_Start_IT>
    __HAL_UART_CLEAR_FLAG(huart, UART_FLAG_TC);
 8002b50:	6823      	ldr	r3, [r4, #0]
 8002b52:	f06f 0240 	mvn.w	r2, #64	; 0x40
 8002b56:	601a      	str	r2, [r3, #0]
    __HAL_UNLOCK(huart);
 8002b58:	6822      	ldr	r2, [r4, #0]
 8002b5a:	f884 503c 	strb.w	r5, [r4, #60]	; 0x3c
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8002b5e:	f102 0314 	add.w	r3, r2, #20
 8002b62:	e853 3f00 	ldrex	r3, [r3]
    ATOMIC_SET_BIT(huart->Instance->CR3, USART_CR3_DMAT);
 8002b66:	f043 0380 	orr.w	r3, r3, #128	; 0x80
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8002b6a:	f102 0114 	add.w	r1, r2, #20
 8002b6e:	e841 3000 	strex	r0, r3, [r1]
 8002b72:	2800      	cmp	r0, #0
 8002b74:	d1f3      	bne.n	8002b5e <HAL_UART_Transmit_DMA+0x56>
}
 8002b76:	bd38      	pop	{r3, r4, r5, pc}
      return HAL_ERROR;
 8002b78:	2001      	movs	r0, #1
 8002b7a:	e7fc      	b.n	8002b76 <HAL_UART_Transmit_DMA+0x6e>
    return HAL_BUSY;
 8002b7c:	2002      	movs	r0, #2
 8002b7e:	e7fa      	b.n	8002b76 <HAL_UART_Transmit_DMA+0x6e>
 8002b80:	08002b8d 	.word	0x08002b8d
 8002b84:	08002bdb 	.word	0x08002bdb
 8002b88:	08002be5 	.word	0x08002be5

08002b8c <UART_DMATransmitCplt>:
  if ((hdma->Instance->CR & DMA_SxCR_CIRC) == 0U)
 8002b8c:	6802      	ldr	r2, [r0, #0]
 8002b8e:	6812      	ldr	r2, [r2, #0]
 8002b90:	f412 7280 	ands.w	r2, r2, #256	; 0x100
{
 8002b94:	b508      	push	{r3, lr}
  UART_HandleTypeDef *huart = (UART_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
 8002b96:	6b83      	ldr	r3, [r0, #56]	; 0x38
  if ((hdma->Instance->CR & DMA_SxCR_CIRC) == 0U)
 8002b98:	d11a      	bne.n	8002bd0 <UART_DMATransmitCplt+0x44>
    huart->TxXferCount = 0x00U;
 8002b9a:	84da      	strh	r2, [r3, #38]	; 0x26
    ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
 8002b9c:	6819      	ldr	r1, [r3, #0]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8002b9e:	f101 0214 	add.w	r2, r1, #20
 8002ba2:	e852 2f00 	ldrex	r2, [r2]
 8002ba6:	f022 0280 	bic.w	r2, r2, #128	; 0x80
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8002baa:	3114      	adds	r1, #20
 8002bac:	e841 2000 	strex	r0, r2, [r1]
   return(result);
 8002bb0:	681a      	ldr	r2, [r3, #0]
 8002bb2:	2800      	cmp	r0, #0
 8002bb4:	d1f2      	bne.n	8002b9c <UART_DMATransmitCplt+0x10>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8002bb6:	f102 030c 	add.w	r3, r2, #12
 8002bba:	e853 3f00 	ldrex	r3, [r3]
    ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_TCIE);
 8002bbe:	f043 0340 	orr.w	r3, r3, #64	; 0x40
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8002bc2:	f102 000c 	add.w	r0, r2, #12
 8002bc6:	e840 3100 	strex	r1, r3, [r0]
 8002bca:	2900      	cmp	r1, #0
 8002bcc:	d1f3      	bne.n	8002bb6 <UART_DMATransmitCplt+0x2a>
}
 8002bce:	bd08      	pop	{r3, pc}
    HAL_UART_TxCpltCallback(huart);
 8002bd0:	4618      	mov	r0, r3
 8002bd2:	f7fd fed3 	bl	800097c <HAL_UART_TxCpltCallback>
}
 8002bd6:	e7fa      	b.n	8002bce <UART_DMATransmitCplt+0x42>

08002bd8 <HAL_UART_TxHalfCpltCallback>:
 8002bd8:	4770      	bx	lr

08002bda <UART_DMATxHalfCplt>:
{
 8002bda:	b508      	push	{r3, lr}
  HAL_UART_TxHalfCpltCallback(huart);
 8002bdc:	6b80      	ldr	r0, [r0, #56]	; 0x38
 8002bde:	f7ff fffb 	bl	8002bd8 <HAL_UART_TxHalfCpltCallback>
}
 8002be2:	bd08      	pop	{r3, pc}

08002be4 <UART_DMAError>:
{
 8002be4:	b508      	push	{r3, lr}
  UART_HandleTypeDef *huart = (UART_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
 8002be6:	6b80      	ldr	r0, [r0, #56]	; 0x38
  dmarequest = HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT);
 8002be8:	6803      	ldr	r3, [r0, #0]
 8002bea:	695a      	ldr	r2, [r3, #20]
  if ((huart->gState == HAL_UART_STATE_BUSY_TX) && dmarequest)
 8002bec:	f890 103d 	ldrb.w	r1, [r0, #61]	; 0x3d
 8002bf0:	2921      	cmp	r1, #33	; 0x21
 8002bf2:	d112      	bne.n	8002c1a <UART_DMAError+0x36>
 8002bf4:	0612      	lsls	r2, r2, #24
 8002bf6:	d510      	bpl.n	8002c1a <UART_DMAError+0x36>
    huart->TxXferCount = 0x00U;
 8002bf8:	2200      	movs	r2, #0
 8002bfa:	84c2      	strh	r2, [r0, #38]	; 0x26
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8002bfc:	f103 020c 	add.w	r2, r3, #12
 8002c00:	e852 2f00 	ldrex	r2, [r2]
  ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TXEIE | USART_CR1_TCIE));
 8002c04:	f022 02c0 	bic.w	r2, r2, #192	; 0xc0
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8002c08:	f103 0c0c 	add.w	ip, r3, #12
 8002c0c:	e84c 2100 	strex	r1, r2, [ip]
 8002c10:	2900      	cmp	r1, #0
 8002c12:	d1f3      	bne.n	8002bfc <UART_DMAError+0x18>
  huart->gState = HAL_UART_STATE_READY;
 8002c14:	2220      	movs	r2, #32
 8002c16:	f880 203d 	strb.w	r2, [r0, #61]	; 0x3d
  dmarequest = HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR);
 8002c1a:	695b      	ldr	r3, [r3, #20]
  if ((huart->RxState == HAL_UART_STATE_BUSY_RX) && dmarequest)
 8002c1c:	f890 203e 	ldrb.w	r2, [r0, #62]	; 0x3e
 8002c20:	2a22      	cmp	r2, #34	; 0x22
 8002c22:	d105      	bne.n	8002c30 <UART_DMAError+0x4c>
 8002c24:	065b      	lsls	r3, r3, #25
 8002c26:	d503      	bpl.n	8002c30 <UART_DMAError+0x4c>
    huart->RxXferCount = 0x00U;
 8002c28:	2300      	movs	r3, #0
 8002c2a:	85c3      	strh	r3, [r0, #46]	; 0x2e
    UART_EndRxTransfer(huart);
 8002c2c:	f7ff fe98 	bl	8002960 <UART_EndRxTransfer>
  huart->ErrorCode |= HAL_UART_ERROR_DMA;
 8002c30:	6c03      	ldr	r3, [r0, #64]	; 0x40
 8002c32:	f043 0310 	orr.w	r3, r3, #16
 8002c36:	6403      	str	r3, [r0, #64]	; 0x40
  HAL_UART_ErrorCallback(huart);
 8002c38:	f7fd fea6 	bl	8000988 <HAL_UART_ErrorCallback>
}
 8002c3c:	bd08      	pop	{r3, pc}

08002c3e <UART_DMAAbortOnError>:
{
 8002c3e:	b508      	push	{r3, lr}
  UART_HandleTypeDef *huart = (UART_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
 8002c40:	6b80      	ldr	r0, [r0, #56]	; 0x38
  huart->RxXferCount = 0x00U;
 8002c42:	2300      	movs	r3, #0
 8002c44:	85c3      	strh	r3, [r0, #46]	; 0x2e
  huart->TxXferCount = 0x00U;
 8002c46:	84c3      	strh	r3, [r0, #38]	; 0x26
  HAL_UART_ErrorCallback(huart);
 8002c48:	f7fd fe9e 	bl	8000988 <HAL_UART_ErrorCallback>
}
 8002c4c:	bd08      	pop	{r3, pc}

08002c4e <HAL_UARTEx_RxEventCallback>:
}
 8002c4e:	4770      	bx	lr

08002c50 <UART_Receive_IT.isra.0>:
  if (huart->RxState == HAL_UART_STATE_BUSY_RX)
 8002c50:	f890 303e 	ldrb.w	r3, [r0, #62]	; 0x3e
 8002c54:	2b22      	cmp	r3, #34	; 0x22
static HAL_StatusTypeDef UART_Receive_IT(UART_HandleTypeDef *huart)
 8002c56:	b507      	push	{r0, r1, r2, lr}
  if (huart->RxState == HAL_UART_STATE_BUSY_RX)
 8002c58:	d141      	bne.n	8002cde <UART_Receive_IT.isra.0+0x8e>
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 8002c5a:	6881      	ldr	r1, [r0, #8]
      pdata16bits = (uint16_t *) huart->pRxBuffPtr;
 8002c5c:	6a83      	ldr	r3, [r0, #40]	; 0x28
      *pdata16bits = (uint16_t)(huart->Instance->DR & (uint16_t)0x01FF);
 8002c5e:	6802      	ldr	r2, [r0, #0]
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 8002c60:	f5b1 5f80 	cmp.w	r1, #4096	; 0x1000
 8002c64:	d13e      	bne.n	8002ce4 <UART_Receive_IT.isra.0+0x94>
 8002c66:	6901      	ldr	r1, [r0, #16]
 8002c68:	2900      	cmp	r1, #0
 8002c6a:	d13e      	bne.n	8002cea <UART_Receive_IT.isra.0+0x9a>
      *pdata16bits = (uint16_t)(huart->Instance->DR & (uint16_t)0x01FF);
 8002c6c:	6852      	ldr	r2, [r2, #4]
 8002c6e:	f3c2 0208 	ubfx	r2, r2, #0, #9
 8002c72:	f823 2b02 	strh.w	r2, [r3], #2
      huart->pRxBuffPtr += 2U;
 8002c76:	6283      	str	r3, [r0, #40]	; 0x28
    if (--huart->RxXferCount == 0U)
 8002c78:	8dc3      	ldrh	r3, [r0, #46]	; 0x2e
 8002c7a:	3b01      	subs	r3, #1
 8002c7c:	b29b      	uxth	r3, r3
 8002c7e:	85c3      	strh	r3, [r0, #46]	; 0x2e
 8002c80:	2b00      	cmp	r3, #0
 8002c82:	d12c      	bne.n	8002cde <UART_Receive_IT.isra.0+0x8e>
      __HAL_UART_DISABLE_IT(huart, UART_IT_RXNE);
 8002c84:	6802      	ldr	r2, [r0, #0]
 8002c86:	68d1      	ldr	r1, [r2, #12]
 8002c88:	f021 0120 	bic.w	r1, r1, #32
 8002c8c:	60d1      	str	r1, [r2, #12]
      __HAL_UART_DISABLE_IT(huart, UART_IT_PE);
 8002c8e:	68d1      	ldr	r1, [r2, #12]
 8002c90:	f421 7180 	bic.w	r1, r1, #256	; 0x100
 8002c94:	60d1      	str	r1, [r2, #12]
      __HAL_UART_DISABLE_IT(huart, UART_IT_ERR);
 8002c96:	6951      	ldr	r1, [r2, #20]
 8002c98:	f021 0101 	bic.w	r1, r1, #1
 8002c9c:	6151      	str	r1, [r2, #20]
      huart->RxState = HAL_UART_STATE_READY;
 8002c9e:	2220      	movs	r2, #32
 8002ca0:	f880 203e 	strb.w	r2, [r0, #62]	; 0x3e
      if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 8002ca4:	6b02      	ldr	r2, [r0, #48]	; 0x30
 8002ca6:	2a01      	cmp	r2, #1
 8002ca8:	6802      	ldr	r2, [r0, #0]
 8002caa:	d128      	bne.n	8002cfe <UART_Receive_IT.isra.0+0xae>
        huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 8002cac:	6303      	str	r3, [r0, #48]	; 0x30
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8002cae:	f102 030c 	add.w	r3, r2, #12
 8002cb2:	e853 3f00 	ldrex	r3, [r3]
        ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 8002cb6:	f023 0310 	bic.w	r3, r3, #16
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8002cba:	f102 0c0c 	add.w	ip, r2, #12
 8002cbe:	e84c 3100 	strex	r1, r3, [ip]
 8002cc2:	2900      	cmp	r1, #0
 8002cc4:	d1f3      	bne.n	8002cae <UART_Receive_IT.isra.0+0x5e>
        if (__HAL_UART_GET_FLAG(huart, UART_FLAG_IDLE))
 8002cc6:	6813      	ldr	r3, [r2, #0]
 8002cc8:	06db      	lsls	r3, r3, #27
 8002cca:	d505      	bpl.n	8002cd8 <UART_Receive_IT.isra.0+0x88>
          __HAL_UART_CLEAR_IDLEFLAG(huart);
 8002ccc:	9101      	str	r1, [sp, #4]
 8002cce:	6813      	ldr	r3, [r2, #0]
 8002cd0:	9301      	str	r3, [sp, #4]
 8002cd2:	6853      	ldr	r3, [r2, #4]
 8002cd4:	9301      	str	r3, [sp, #4]
 8002cd6:	9b01      	ldr	r3, [sp, #4]
        HAL_UARTEx_RxEventCallback(huart, huart->RxXferSize);
 8002cd8:	8d81      	ldrh	r1, [r0, #44]	; 0x2c
 8002cda:	f7ff ffb8 	bl	8002c4e <HAL_UARTEx_RxEventCallback>
}
 8002cde:	b003      	add	sp, #12
 8002ce0:	f85d fb04 	ldr.w	pc, [sp], #4
      if ((huart->Init.WordLength == UART_WORDLENGTH_9B) || ((huart->Init.WordLength == UART_WORDLENGTH_8B) && (huart->Init.Parity == UART_PARITY_NONE)))
 8002ce4:	b939      	cbnz	r1, 8002cf6 <UART_Receive_IT.isra.0+0xa6>
 8002ce6:	6901      	ldr	r1, [r0, #16]
 8002ce8:	b929      	cbnz	r1, 8002cf6 <UART_Receive_IT.isra.0+0xa6>
        *pdata8bits = (uint8_t)(huart->Instance->DR & (uint8_t)0x00FF);
 8002cea:	6852      	ldr	r2, [r2, #4]
 8002cec:	b2d2      	uxtb	r2, r2
 8002cee:	701a      	strb	r2, [r3, #0]
      huart->pRxBuffPtr += 1U;
 8002cf0:	6a83      	ldr	r3, [r0, #40]	; 0x28
 8002cf2:	3301      	adds	r3, #1
 8002cf4:	e7bf      	b.n	8002c76 <UART_Receive_IT.isra.0+0x26>
        *pdata8bits = (uint8_t)(huart->Instance->DR & (uint8_t)0x007F);
 8002cf6:	6852      	ldr	r2, [r2, #4]
 8002cf8:	f002 027f 	and.w	r2, r2, #127	; 0x7f
 8002cfc:	e7f7      	b.n	8002cee <UART_Receive_IT.isra.0+0x9e>
        HAL_UART_RxCpltCallback(huart);
 8002cfe:	f7fd fe27 	bl	8000950 <HAL_UART_RxCpltCallback>
 8002d02:	e7ec      	b.n	8002cde <UART_Receive_IT.isra.0+0x8e>

08002d04 <HAL_UART_IRQHandler>:
  uint32_t isrflags   = READ_REG(huart->Instance->SR);
 8002d04:	6803      	ldr	r3, [r0, #0]
 8002d06:	681a      	ldr	r2, [r3, #0]
{
 8002d08:	b573      	push	{r0, r1, r4, r5, r6, lr}
  if (errorflags == RESET)
 8002d0a:	0716      	lsls	r6, r2, #28
  uint32_t cr1its     = READ_REG(huart->Instance->CR1);
 8002d0c:	68d9      	ldr	r1, [r3, #12]
  uint32_t cr3its     = READ_REG(huart->Instance->CR3);
 8002d0e:	695d      	ldr	r5, [r3, #20]
{
 8002d10:	4604      	mov	r4, r0
  if (errorflags == RESET)
 8002d12:	d108      	bne.n	8002d26 <HAL_UART_IRQHandler+0x22>
    if (((isrflags & USART_SR_RXNE) != RESET) && ((cr1its & USART_CR1_RXNEIE) != RESET))
 8002d14:	0696      	lsls	r6, r2, #26
 8002d16:	d568      	bpl.n	8002dea <HAL_UART_IRQHandler+0xe6>
 8002d18:	068d      	lsls	r5, r1, #26
 8002d1a:	d566      	bpl.n	8002dea <HAL_UART_IRQHandler+0xe6>
}
 8002d1c:	b002      	add	sp, #8
 8002d1e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
      UART_Receive_IT(huart);
 8002d22:	f7ff bf95 	b.w	8002c50 <UART_Receive_IT.isra.0>
  if ((errorflags != RESET) && (((cr3its & USART_CR3_EIE) != RESET)
 8002d26:	f005 0001 	and.w	r0, r5, #1
                                || ((cr1its & (USART_CR1_RXNEIE | USART_CR1_PEIE)) != RESET)))
 8002d2a:	f401 7590 	and.w	r5, r1, #288	; 0x120
 8002d2e:	4305      	orrs	r5, r0
 8002d30:	d05b      	beq.n	8002dea <HAL_UART_IRQHandler+0xe6>
    if (((isrflags & USART_SR_PE) != RESET) && ((cr1its & USART_CR1_PEIE) != RESET))
 8002d32:	07d6      	lsls	r6, r2, #31
 8002d34:	d505      	bpl.n	8002d42 <HAL_UART_IRQHandler+0x3e>
 8002d36:	05cd      	lsls	r5, r1, #23
      huart->ErrorCode |= HAL_UART_ERROR_PE;
 8002d38:	bf42      	ittt	mi
 8002d3a:	6c23      	ldrmi	r3, [r4, #64]	; 0x40
 8002d3c:	f043 0301 	orrmi.w	r3, r3, #1
 8002d40:	6423      	strmi	r3, [r4, #64]	; 0x40
    if (((isrflags & USART_SR_NE) != RESET) && ((cr3its & USART_CR3_EIE) != RESET))
 8002d42:	0753      	lsls	r3, r2, #29
 8002d44:	d504      	bpl.n	8002d50 <HAL_UART_IRQHandler+0x4c>
 8002d46:	b118      	cbz	r0, 8002d50 <HAL_UART_IRQHandler+0x4c>
      huart->ErrorCode |= HAL_UART_ERROR_NE;
 8002d48:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8002d4a:	f043 0302 	orr.w	r3, r3, #2
 8002d4e:	6423      	str	r3, [r4, #64]	; 0x40
    if (((isrflags & USART_SR_FE) != RESET) && ((cr3its & USART_CR3_EIE) != RESET))
 8002d50:	0796      	lsls	r6, r2, #30
 8002d52:	d504      	bpl.n	8002d5e <HAL_UART_IRQHandler+0x5a>
 8002d54:	b118      	cbz	r0, 8002d5e <HAL_UART_IRQHandler+0x5a>
      huart->ErrorCode |= HAL_UART_ERROR_FE;
 8002d56:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8002d58:	f043 0304 	orr.w	r3, r3, #4
 8002d5c:	6423      	str	r3, [r4, #64]	; 0x40
    if (((isrflags & USART_SR_ORE) != RESET) && (((cr1its & USART_CR1_RXNEIE) != RESET)
 8002d5e:	0715      	lsls	r5, r2, #28
 8002d60:	d507      	bpl.n	8002d72 <HAL_UART_IRQHandler+0x6e>
 8002d62:	f001 0320 	and.w	r3, r1, #32
 8002d66:	4303      	orrs	r3, r0
      huart->ErrorCode |= HAL_UART_ERROR_ORE;
 8002d68:	bf1e      	ittt	ne
 8002d6a:	6c23      	ldrne	r3, [r4, #64]	; 0x40
 8002d6c:	f043 0308 	orrne.w	r3, r3, #8
 8002d70:	6423      	strne	r3, [r4, #64]	; 0x40
    if (huart->ErrorCode != HAL_UART_ERROR_NONE)
 8002d72:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8002d74:	2b00      	cmp	r3, #0
 8002d76:	d032      	beq.n	8002dde <HAL_UART_IRQHandler+0xda>
      if (((isrflags & USART_SR_RXNE) != RESET) && ((cr1its & USART_CR1_RXNEIE) != RESET))
 8002d78:	0692      	lsls	r2, r2, #26
 8002d7a:	d504      	bpl.n	8002d86 <HAL_UART_IRQHandler+0x82>
 8002d7c:	068b      	lsls	r3, r1, #26
 8002d7e:	d502      	bpl.n	8002d86 <HAL_UART_IRQHandler+0x82>
        UART_Receive_IT(huart);
 8002d80:	4620      	mov	r0, r4
 8002d82:	f7ff ff65 	bl	8002c50 <UART_Receive_IT.isra.0>
      dmarequest = HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR);
 8002d86:	6826      	ldr	r6, [r4, #0]
 8002d88:	6973      	ldr	r3, [r6, #20]
      if (((huart->ErrorCode & HAL_UART_ERROR_ORE) != RESET) || dmarequest)
 8002d8a:	6c22      	ldr	r2, [r4, #64]	; 0x40
      dmarequest = HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR);
 8002d8c:	f003 0340 	and.w	r3, r3, #64	; 0x40
      if (((huart->ErrorCode & HAL_UART_ERROR_ORE) != RESET) || dmarequest)
 8002d90:	f002 0208 	and.w	r2, r2, #8
 8002d94:	ea53 0502 	orrs.w	r5, r3, r2
        UART_EndRxTransfer(huart);
 8002d98:	4620      	mov	r0, r4
      if (((huart->ErrorCode & HAL_UART_ERROR_ORE) != RESET) || dmarequest)
 8002d9a:	d022      	beq.n	8002de2 <HAL_UART_IRQHandler+0xde>
        UART_EndRxTransfer(huart);
 8002d9c:	f7ff fde0 	bl	8002960 <UART_EndRxTransfer>
        if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
 8002da0:	6973      	ldr	r3, [r6, #20]
 8002da2:	065e      	lsls	r6, r3, #25
 8002da4:	d518      	bpl.n	8002dd8 <HAL_UART_IRQHandler+0xd4>
          ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
 8002da6:	6822      	ldr	r2, [r4, #0]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8002da8:	f102 0314 	add.w	r3, r2, #20
 8002dac:	e853 3f00 	ldrex	r3, [r3]
 8002db0:	f023 0340 	bic.w	r3, r3, #64	; 0x40
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8002db4:	3214      	adds	r2, #20
 8002db6:	e842 3100 	strex	r1, r3, [r2]
 8002dba:	2900      	cmp	r1, #0
 8002dbc:	d1f3      	bne.n	8002da6 <HAL_UART_IRQHandler+0xa2>
          if (huart->hdmarx != NULL)
 8002dbe:	6ba0      	ldr	r0, [r4, #56]	; 0x38
 8002dc0:	b150      	cbz	r0, 8002dd8 <HAL_UART_IRQHandler+0xd4>
            huart->hdmarx->XferAbortCallback = UART_DMAAbortOnError;
 8002dc2:	4b72      	ldr	r3, [pc, #456]	; (8002f8c <HAL_UART_IRQHandler+0x288>)
 8002dc4:	6503      	str	r3, [r0, #80]	; 0x50
            if (HAL_DMA_Abort_IT(huart->hdmarx) != HAL_OK)
 8002dc6:	f7fe fa22 	bl	800120e <HAL_DMA_Abort_IT>
 8002dca:	b140      	cbz	r0, 8002dde <HAL_UART_IRQHandler+0xda>
              huart->hdmarx->XferAbortCallback(huart->hdmarx);
 8002dcc:	6ba0      	ldr	r0, [r4, #56]	; 0x38
 8002dce:	6d03      	ldr	r3, [r0, #80]	; 0x50
}
 8002dd0:	b002      	add	sp, #8
 8002dd2:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
              huart->hdmarx->XferAbortCallback(huart->hdmarx);
 8002dd6:	4718      	bx	r3
            HAL_UART_ErrorCallback(huart);
 8002dd8:	4620      	mov	r0, r4
 8002dda:	f7fd fdd5 	bl	8000988 <HAL_UART_ErrorCallback>
}
 8002dde:	b002      	add	sp, #8
 8002de0:	bd70      	pop	{r4, r5, r6, pc}
        HAL_UART_ErrorCallback(huart);
 8002de2:	f7fd fdd1 	bl	8000988 <HAL_UART_ErrorCallback>
        huart->ErrorCode = HAL_UART_ERROR_NONE;
 8002de6:	6425      	str	r5, [r4, #64]	; 0x40
 8002de8:	e7f9      	b.n	8002dde <HAL_UART_IRQHandler+0xda>
  if ((huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 8002dea:	6b20      	ldr	r0, [r4, #48]	; 0x30
 8002dec:	2801      	cmp	r0, #1
 8002dee:	f040 8091 	bne.w	8002f14 <HAL_UART_IRQHandler+0x210>
      && ((isrflags & USART_SR_IDLE) != 0U)
 8002df2:	06d5      	lsls	r5, r2, #27
 8002df4:	f140 808e 	bpl.w	8002f14 <HAL_UART_IRQHandler+0x210>
      && ((cr1its & USART_SR_IDLE) != 0U))
 8002df8:	06c8      	lsls	r0, r1, #27
 8002dfa:	f140 808b 	bpl.w	8002f14 <HAL_UART_IRQHandler+0x210>
    __HAL_UART_CLEAR_IDLEFLAG(huart);
 8002dfe:	2200      	movs	r2, #0
 8002e00:	9201      	str	r2, [sp, #4]
 8002e02:	681a      	ldr	r2, [r3, #0]
 8002e04:	9201      	str	r2, [sp, #4]
 8002e06:	685a      	ldr	r2, [r3, #4]
 8002e08:	9201      	str	r2, [sp, #4]
 8002e0a:	9a01      	ldr	r2, [sp, #4]
    if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
 8002e0c:	695a      	ldr	r2, [r3, #20]
 8002e0e:	0652      	lsls	r2, r2, #25
 8002e10:	d54c      	bpl.n	8002eac <HAL_UART_IRQHandler+0x1a8>
      uint16_t nb_remaining_rx_data = (uint16_t) __HAL_DMA_GET_COUNTER(huart->hdmarx);
 8002e12:	6ba1      	ldr	r1, [r4, #56]	; 0x38
 8002e14:	680a      	ldr	r2, [r1, #0]
 8002e16:	6852      	ldr	r2, [r2, #4]
 8002e18:	b292      	uxth	r2, r2
      if ((nb_remaining_rx_data > 0U)
 8002e1a:	2a00      	cmp	r2, #0
 8002e1c:	d0df      	beq.n	8002dde <HAL_UART_IRQHandler+0xda>
          && (nb_remaining_rx_data < huart->RxXferSize))
 8002e1e:	8da0      	ldrh	r0, [r4, #44]	; 0x2c
 8002e20:	4290      	cmp	r0, r2
 8002e22:	d9dc      	bls.n	8002dde <HAL_UART_IRQHandler+0xda>
        huart->RxXferCount = nb_remaining_rx_data;
 8002e24:	85e2      	strh	r2, [r4, #46]	; 0x2e
        if (huart->hdmarx->Init.Mode != DMA_CIRCULAR)
 8002e26:	69ca      	ldr	r2, [r1, #28]
 8002e28:	f5b2 7f80 	cmp.w	r2, #256	; 0x100
 8002e2c:	d036      	beq.n	8002e9c <HAL_UART_IRQHandler+0x198>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8002e2e:	f103 020c 	add.w	r2, r3, #12
 8002e32:	e852 2f00 	ldrex	r2, [r2]
          ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_PEIE);
 8002e36:	f422 7280 	bic.w	r2, r2, #256	; 0x100
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8002e3a:	f103 000c 	add.w	r0, r3, #12
 8002e3e:	e840 2100 	strex	r1, r2, [r0]
 8002e42:	2900      	cmp	r1, #0
 8002e44:	d1f3      	bne.n	8002e2e <HAL_UART_IRQHandler+0x12a>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8002e46:	f103 0214 	add.w	r2, r3, #20
 8002e4a:	e852 2f00 	ldrex	r2, [r2]
          ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 8002e4e:	f022 0201 	bic.w	r2, r2, #1
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8002e52:	f103 0014 	add.w	r0, r3, #20
 8002e56:	e840 2100 	strex	r1, r2, [r0]
 8002e5a:	2900      	cmp	r1, #0
 8002e5c:	d1f3      	bne.n	8002e46 <HAL_UART_IRQHandler+0x142>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8002e5e:	f103 0214 	add.w	r2, r3, #20
 8002e62:	e852 2f00 	ldrex	r2, [r2]
          ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
 8002e66:	f022 0240 	bic.w	r2, r2, #64	; 0x40
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8002e6a:	f103 0014 	add.w	r0, r3, #20
 8002e6e:	e840 2100 	strex	r1, r2, [r0]
 8002e72:	2900      	cmp	r1, #0
 8002e74:	d1f3      	bne.n	8002e5e <HAL_UART_IRQHandler+0x15a>
          huart->RxState = HAL_UART_STATE_READY;
 8002e76:	2220      	movs	r2, #32
 8002e78:	f884 203e 	strb.w	r2, [r4, #62]	; 0x3e
          huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 8002e7c:	6321      	str	r1, [r4, #48]	; 0x30
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8002e7e:	f103 020c 	add.w	r2, r3, #12
 8002e82:	e852 2f00 	ldrex	r2, [r2]
          ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 8002e86:	f022 0210 	bic.w	r2, r2, #16
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8002e8a:	f103 000c 	add.w	r0, r3, #12
 8002e8e:	e840 2100 	strex	r1, r2, [r0]
 8002e92:	2900      	cmp	r1, #0
 8002e94:	d1f3      	bne.n	8002e7e <HAL_UART_IRQHandler+0x17a>
          (void)HAL_DMA_Abort(huart->hdmarx);
 8002e96:	6ba0      	ldr	r0, [r4, #56]	; 0x38
 8002e98:	f7fe f97a 	bl	8001190 <HAL_DMA_Abort>
        HAL_UARTEx_RxEventCallback(huart, (huart->RxXferSize - huart->RxXferCount));
 8002e9c:	8de3      	ldrh	r3, [r4, #46]	; 0x2e
 8002e9e:	8da1      	ldrh	r1, [r4, #44]	; 0x2c
 8002ea0:	1ac9      	subs	r1, r1, r3
 8002ea2:	b289      	uxth	r1, r1
        HAL_UARTEx_RxEventCallback(huart, nb_rx_data);
 8002ea4:	4620      	mov	r0, r4
 8002ea6:	f7ff fed2 	bl	8002c4e <HAL_UARTEx_RxEventCallback>
 8002eaa:	e798      	b.n	8002dde <HAL_UART_IRQHandler+0xda>
      uint16_t nb_rx_data = huart->RxXferSize - huart->RxXferCount;
 8002eac:	8de2      	ldrh	r2, [r4, #46]	; 0x2e
      if ((huart->RxXferCount > 0U)
 8002eae:	8de0      	ldrh	r0, [r4, #46]	; 0x2e
      uint16_t nb_rx_data = huart->RxXferSize - huart->RxXferCount;
 8002eb0:	8da1      	ldrh	r1, [r4, #44]	; 0x2c
      if ((huart->RxXferCount > 0U)
 8002eb2:	b280      	uxth	r0, r0
      uint16_t nb_rx_data = huart->RxXferSize - huart->RxXferCount;
 8002eb4:	b292      	uxth	r2, r2
      if ((huart->RxXferCount > 0U)
 8002eb6:	2800      	cmp	r0, #0
 8002eb8:	d091      	beq.n	8002dde <HAL_UART_IRQHandler+0xda>
      uint16_t nb_rx_data = huart->RxXferSize - huart->RxXferCount;
 8002eba:	1a89      	subs	r1, r1, r2
 8002ebc:	b289      	uxth	r1, r1
          && (nb_rx_data > 0U))
 8002ebe:	2900      	cmp	r1, #0
 8002ec0:	d08d      	beq.n	8002dde <HAL_UART_IRQHandler+0xda>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8002ec2:	f103 020c 	add.w	r2, r3, #12
 8002ec6:	e852 2f00 	ldrex	r2, [r2]
        ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
 8002eca:	f422 7290 	bic.w	r2, r2, #288	; 0x120
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8002ece:	f103 050c 	add.w	r5, r3, #12
 8002ed2:	e845 2000 	strex	r0, r2, [r5]
 8002ed6:	2800      	cmp	r0, #0
 8002ed8:	d1f3      	bne.n	8002ec2 <HAL_UART_IRQHandler+0x1be>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8002eda:	f103 0214 	add.w	r2, r3, #20
 8002ede:	e852 2f00 	ldrex	r2, [r2]
        ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 8002ee2:	f022 0201 	bic.w	r2, r2, #1
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8002ee6:	f103 0514 	add.w	r5, r3, #20
 8002eea:	e845 2000 	strex	r0, r2, [r5]
 8002eee:	2800      	cmp	r0, #0
 8002ef0:	d1f3      	bne.n	8002eda <HAL_UART_IRQHandler+0x1d6>
        huart->RxState = HAL_UART_STATE_READY;
 8002ef2:	2220      	movs	r2, #32
 8002ef4:	f884 203e 	strb.w	r2, [r4, #62]	; 0x3e
        huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 8002ef8:	6320      	str	r0, [r4, #48]	; 0x30
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8002efa:	f103 020c 	add.w	r2, r3, #12
 8002efe:	e852 2f00 	ldrex	r2, [r2]
        ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 8002f02:	f022 0210 	bic.w	r2, r2, #16
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8002f06:	f103 050c 	add.w	r5, r3, #12
 8002f0a:	e845 2000 	strex	r0, r2, [r5]
 8002f0e:	2800      	cmp	r0, #0
 8002f10:	d1f3      	bne.n	8002efa <HAL_UART_IRQHandler+0x1f6>
 8002f12:	e7c7      	b.n	8002ea4 <HAL_UART_IRQHandler+0x1a0>
  if (((isrflags & USART_SR_TXE) != RESET) && ((cr1its & USART_CR1_TXEIE) != RESET))
 8002f14:	0616      	lsls	r6, r2, #24
 8002f16:	d528      	bpl.n	8002f6a <HAL_UART_IRQHandler+0x266>
 8002f18:	060d      	lsls	r5, r1, #24
 8002f1a:	d526      	bpl.n	8002f6a <HAL_UART_IRQHandler+0x266>
  if (huart->gState == HAL_UART_STATE_BUSY_TX)
 8002f1c:	f894 203d 	ldrb.w	r2, [r4, #61]	; 0x3d
 8002f20:	2a21      	cmp	r2, #33	; 0x21
 8002f22:	f47f af5c 	bne.w	8002dde <HAL_UART_IRQHandler+0xda>
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 8002f26:	68a1      	ldr	r1, [r4, #8]
      tmp = (const uint16_t *) huart->pTxBuffPtr;
 8002f28:	6a22      	ldr	r2, [r4, #32]
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 8002f2a:	f5b1 5f80 	cmp.w	r1, #4096	; 0x1000
 8002f2e:	d117      	bne.n	8002f60 <HAL_UART_IRQHandler+0x25c>
 8002f30:	6921      	ldr	r1, [r4, #16]
 8002f32:	b9a9      	cbnz	r1, 8002f60 <HAL_UART_IRQHandler+0x25c>
      huart->Instance->DR = (uint16_t)(*tmp & (uint16_t)0x01FF);
 8002f34:	f832 1b02 	ldrh.w	r1, [r2], #2
 8002f38:	f3c1 0108 	ubfx	r1, r1, #0, #9
 8002f3c:	6059      	str	r1, [r3, #4]
      huart->pTxBuffPtr += 2U;
 8002f3e:	6222      	str	r2, [r4, #32]
    if (--huart->TxXferCount == 0U)
 8002f40:	8ce2      	ldrh	r2, [r4, #38]	; 0x26
 8002f42:	3a01      	subs	r2, #1
 8002f44:	b292      	uxth	r2, r2
 8002f46:	84e2      	strh	r2, [r4, #38]	; 0x26
 8002f48:	2a00      	cmp	r2, #0
 8002f4a:	f47f af48 	bne.w	8002dde <HAL_UART_IRQHandler+0xda>
      __HAL_UART_DISABLE_IT(huart, UART_IT_TXE);
 8002f4e:	68da      	ldr	r2, [r3, #12]
 8002f50:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 8002f54:	60da      	str	r2, [r3, #12]
      __HAL_UART_ENABLE_IT(huart, UART_IT_TC);
 8002f56:	68da      	ldr	r2, [r3, #12]
 8002f58:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 8002f5c:	60da      	str	r2, [r3, #12]
 8002f5e:	e73e      	b.n	8002dde <HAL_UART_IRQHandler+0xda>
      huart->Instance->DR = (uint8_t)(*huart->pTxBuffPtr++ & (uint8_t)0x00FF);
 8002f60:	1c51      	adds	r1, r2, #1
 8002f62:	6221      	str	r1, [r4, #32]
 8002f64:	7812      	ldrb	r2, [r2, #0]
 8002f66:	605a      	str	r2, [r3, #4]
 8002f68:	e7ea      	b.n	8002f40 <HAL_UART_IRQHandler+0x23c>
  if (((isrflags & USART_SR_TC) != RESET) && ((cr1its & USART_CR1_TCIE) != RESET))
 8002f6a:	0650      	lsls	r0, r2, #25
 8002f6c:	f57f af37 	bpl.w	8002dde <HAL_UART_IRQHandler+0xda>
 8002f70:	064a      	lsls	r2, r1, #25
 8002f72:	f57f af34 	bpl.w	8002dde <HAL_UART_IRQHandler+0xda>
  __HAL_UART_DISABLE_IT(huart, UART_IT_TC);
 8002f76:	68da      	ldr	r2, [r3, #12]
 8002f78:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 8002f7c:	60da      	str	r2, [r3, #12]
  huart->gState = HAL_UART_STATE_READY;
 8002f7e:	2320      	movs	r3, #32
 8002f80:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
  HAL_UART_TxCpltCallback(huart);
 8002f84:	4620      	mov	r0, r4
 8002f86:	f7fd fcf9 	bl	800097c <HAL_UART_TxCpltCallback>
  return HAL_OK;
 8002f8a:	e728      	b.n	8002dde <HAL_UART_IRQHandler+0xda>
 8002f8c:	08002c3f 	.word	0x08002c3f

08002f90 <UART_Start_Receive_IT>:
  huart->RxXferCount = Size;
 8002f90:	85c2      	strh	r2, [r0, #46]	; 0x2e
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 8002f92:	2300      	movs	r3, #0
  huart->RxXferSize = Size;
 8002f94:	8582      	strh	r2, [r0, #44]	; 0x2c
  huart->RxState = HAL_UART_STATE_BUSY_RX;
 8002f96:	2222      	movs	r2, #34	; 0x22
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 8002f98:	6403      	str	r3, [r0, #64]	; 0x40
  huart->RxState = HAL_UART_STATE_BUSY_RX;
 8002f9a:	f880 203e 	strb.w	r2, [r0, #62]	; 0x3e
  if (huart->Init.Parity != UART_PARITY_NONE)
 8002f9e:	6902      	ldr	r2, [r0, #16]
  __HAL_UNLOCK(huart);
 8002fa0:	f880 303c 	strb.w	r3, [r0, #60]	; 0x3c
  huart->pRxBuffPtr = pData;
 8002fa4:	6281      	str	r1, [r0, #40]	; 0x28
    __HAL_UART_ENABLE_IT(huart, UART_IT_PE);
 8002fa6:	6803      	ldr	r3, [r0, #0]
  if (huart->Init.Parity != UART_PARITY_NONE)
 8002fa8:	b11a      	cbz	r2, 8002fb2 <UART_Start_Receive_IT+0x22>
    __HAL_UART_ENABLE_IT(huart, UART_IT_PE);
 8002faa:	68da      	ldr	r2, [r3, #12]
 8002fac:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 8002fb0:	60da      	str	r2, [r3, #12]
  __HAL_UART_ENABLE_IT(huart, UART_IT_ERR);
 8002fb2:	695a      	ldr	r2, [r3, #20]
 8002fb4:	f042 0201 	orr.w	r2, r2, #1
 8002fb8:	615a      	str	r2, [r3, #20]
  __HAL_UART_ENABLE_IT(huart, UART_IT_RXNE);
 8002fba:	68da      	ldr	r2, [r3, #12]
 8002fbc:	f042 0220 	orr.w	r2, r2, #32
 8002fc0:	60da      	str	r2, [r3, #12]
}
 8002fc2:	2000      	movs	r0, #0
 8002fc4:	4770      	bx	lr

08002fc6 <HAL_UART_Receive_IT>:
{
 8002fc6:	b470      	push	{r4, r5, r6}
  if (huart->RxState == HAL_UART_STATE_READY)
 8002fc8:	f890 603e 	ldrb.w	r6, [r0, #62]	; 0x3e
 8002fcc:	2e20      	cmp	r6, #32
 8002fce:	d110      	bne.n	8002ff2 <HAL_UART_Receive_IT+0x2c>
    if ((pData == NULL) || (Size == 0U))
 8002fd0:	b161      	cbz	r1, 8002fec <HAL_UART_Receive_IT+0x26>
 8002fd2:	b15a      	cbz	r2, 8002fec <HAL_UART_Receive_IT+0x26>
    __HAL_LOCK(huart);
 8002fd4:	f890 403c 	ldrb.w	r4, [r0, #60]	; 0x3c
 8002fd8:	2c01      	cmp	r4, #1
 8002fda:	d00a      	beq.n	8002ff2 <HAL_UART_Receive_IT+0x2c>
 8002fdc:	2401      	movs	r4, #1
 8002fde:	f880 403c 	strb.w	r4, [r0, #60]	; 0x3c
    huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 8002fe2:	2400      	movs	r4, #0
 8002fe4:	6304      	str	r4, [r0, #48]	; 0x30
}
 8002fe6:	bc70      	pop	{r4, r5, r6}
    return (UART_Start_Receive_IT(huart, pData, Size));
 8002fe8:	f7ff bfd2 	b.w	8002f90 <UART_Start_Receive_IT>
      return HAL_ERROR;
 8002fec:	2001      	movs	r0, #1
}
 8002fee:	bc70      	pop	{r4, r5, r6}
 8002ff0:	4770      	bx	lr
    return HAL_BUSY;
 8002ff2:	2002      	movs	r0, #2
 8002ff4:	e7fb      	b.n	8002fee <HAL_UART_Receive_IT+0x28>
	...

08002ff8 <USB_CoreReset>:
  * @brief  Reset the USB Core (needed after USB clock settings change)
  * @param  USBx  Selected device
  * @retval HAL status
  */
static HAL_StatusTypeDef USB_CoreReset(USB_OTG_GlobalTypeDef *USBx)
{
 8002ff8:	b082      	sub	sp, #8
  __IO uint32_t count = 0U;
 8002ffa:	2300      	movs	r3, #0
  /* Wait for AHB master IDLE state. */
  do
  {
    count++;

    if (count > 200000U)
 8002ffc:	4a10      	ldr	r2, [pc, #64]	; (8003040 <USB_CoreReset+0x48>)
  __IO uint32_t count = 0U;
 8002ffe:	9301      	str	r3, [sp, #4]
    count++;
 8003000:	9b01      	ldr	r3, [sp, #4]
 8003002:	3301      	adds	r3, #1
 8003004:	9301      	str	r3, [sp, #4]
    if (count > 200000U)
 8003006:	9b01      	ldr	r3, [sp, #4]
 8003008:	4293      	cmp	r3, r2
 800300a:	d816      	bhi.n	800303a <USB_CoreReset+0x42>
    {
      return HAL_TIMEOUT;
    }
  } while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_AHBIDL) == 0U);
 800300c:	6903      	ldr	r3, [r0, #16]
 800300e:	2b00      	cmp	r3, #0
 8003010:	daf6      	bge.n	8003000 <USB_CoreReset+0x8>

  /* Core Soft Reset */
  count = 0U;
 8003012:	2300      	movs	r3, #0
 8003014:	9301      	str	r3, [sp, #4]
  USBx->GRSTCTL |= USB_OTG_GRSTCTL_CSRST;
 8003016:	6903      	ldr	r3, [r0, #16]

  do
  {
    count++;

    if (count > 200000U)
 8003018:	4a09      	ldr	r2, [pc, #36]	; (8003040 <USB_CoreReset+0x48>)
  USBx->GRSTCTL |= USB_OTG_GRSTCTL_CSRST;
 800301a:	f043 0301 	orr.w	r3, r3, #1
 800301e:	6103      	str	r3, [r0, #16]
    count++;
 8003020:	9b01      	ldr	r3, [sp, #4]
 8003022:	3301      	adds	r3, #1
 8003024:	9301      	str	r3, [sp, #4]
    if (count > 200000U)
 8003026:	9b01      	ldr	r3, [sp, #4]
 8003028:	4293      	cmp	r3, r2
 800302a:	d806      	bhi.n	800303a <USB_CoreReset+0x42>
    {
      return HAL_TIMEOUT;
    }
  } while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_CSRST) == USB_OTG_GRSTCTL_CSRST);
 800302c:	6903      	ldr	r3, [r0, #16]
 800302e:	f013 0301 	ands.w	r3, r3, #1
 8003032:	d1f5      	bne.n	8003020 <USB_CoreReset+0x28>

  return HAL_OK;
 8003034:	4618      	mov	r0, r3
}
 8003036:	b002      	add	sp, #8
 8003038:	4770      	bx	lr
      return HAL_TIMEOUT;
 800303a:	2003      	movs	r0, #3
 800303c:	e7fb      	b.n	8003036 <USB_CoreReset+0x3e>
 800303e:	bf00      	nop
 8003040:	00030d40 	.word	0x00030d40

08003044 <USB_CoreInit>:
{
 8003044:	b084      	sub	sp, #16
 8003046:	b538      	push	{r3, r4, r5, lr}
 8003048:	ad05      	add	r5, sp, #20
 800304a:	e885 000e 	stmia.w	r5, {r1, r2, r3}
  if (cfg.phy_itface == USB_OTG_ULPI_PHY)
 800304e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8003050:	2b01      	cmp	r3, #1
{
 8003052:	4604      	mov	r4, r0
  if (cfg.phy_itface == USB_OTG_ULPI_PHY)
 8003054:	d125      	bne.n	80030a2 <USB_CoreInit+0x5e>
    USBx->GCCFG &= ~(USB_OTG_GCCFG_PWRDWN);
 8003056:	6b83      	ldr	r3, [r0, #56]	; 0x38
 8003058:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 800305c:	6383      	str	r3, [r0, #56]	; 0x38
    USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_TSDPS | USB_OTG_GUSBCFG_ULPIFSLS | USB_OTG_GUSBCFG_PHYSEL);
 800305e:	68c3      	ldr	r3, [r0, #12]
 8003060:	f423 0384 	bic.w	r3, r3, #4325376	; 0x420000
 8003064:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8003068:	60c3      	str	r3, [r0, #12]
    USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_ULPIEVBUSD | USB_OTG_GUSBCFG_ULPIEVBUSI);
 800306a:	68c3      	ldr	r3, [r0, #12]
 800306c:	f423 1340 	bic.w	r3, r3, #3145728	; 0x300000
 8003070:	60c3      	str	r3, [r0, #12]
    if (cfg.use_external_vbus == 1U)
 8003072:	9b11      	ldr	r3, [sp, #68]	; 0x44
 8003074:	2b01      	cmp	r3, #1
      USBx->GUSBCFG |= USB_OTG_GUSBCFG_ULPIEVBUSD;
 8003076:	bf02      	ittt	eq
 8003078:	68c3      	ldreq	r3, [r0, #12]
 800307a:	f443 1380 	orreq.w	r3, r3, #1048576	; 0x100000
 800307e:	60c3      	streq	r3, [r0, #12]
    ret = USB_CoreReset(USBx);
 8003080:	f7ff ffba 	bl	8002ff8 <USB_CoreReset>
  if (cfg.dma_enable == 1U)
 8003084:	9b08      	ldr	r3, [sp, #32]
 8003086:	2b01      	cmp	r3, #1
 8003088:	d107      	bne.n	800309a <USB_CoreInit+0x56>
    USBx->GAHBCFG |= USB_OTG_GAHBCFG_HBSTLEN_2;
 800308a:	68a3      	ldr	r3, [r4, #8]
 800308c:	f043 0306 	orr.w	r3, r3, #6
 8003090:	60a3      	str	r3, [r4, #8]
    USBx->GAHBCFG |= USB_OTG_GAHBCFG_DMAEN;
 8003092:	68a3      	ldr	r3, [r4, #8]
 8003094:	f043 0320 	orr.w	r3, r3, #32
 8003098:	60a3      	str	r3, [r4, #8]
}
 800309a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 800309e:	b004      	add	sp, #16
 80030a0:	4770      	bx	lr
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_PHYSEL;
 80030a2:	68c3      	ldr	r3, [r0, #12]
 80030a4:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 80030a8:	60c3      	str	r3, [r0, #12]
    ret = USB_CoreReset(USBx);
 80030aa:	f7ff ffa5 	bl	8002ff8 <USB_CoreReset>
    if (cfg.battery_charging_enable == 0U)
 80030ae:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 80030b0:	b923      	cbnz	r3, 80030bc <USB_CoreInit+0x78>
      USBx->GCCFG |= USB_OTG_GCCFG_PWRDWN;
 80030b2:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 80030b4:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
      USBx->GCCFG &= ~(USB_OTG_GCCFG_PWRDWN);
 80030b8:	63a3      	str	r3, [r4, #56]	; 0x38
 80030ba:	e7e3      	b.n	8003084 <USB_CoreInit+0x40>
 80030bc:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 80030be:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 80030c2:	e7f9      	b.n	80030b8 <USB_CoreInit+0x74>

080030c4 <USB_SetTurnaroundTime>:
  if (speed == USBD_FS_SPEED)
 80030c4:	2a02      	cmp	r2, #2
 80030c6:	d14a      	bne.n	800315e <USB_SetTurnaroundTime+0x9a>
    if ((hclk >= 14200000U) && (hclk < 15000000U))
 80030c8:	4b27      	ldr	r3, [pc, #156]	; (8003168 <USB_SetTurnaroundTime+0xa4>)
 80030ca:	4a28      	ldr	r2, [pc, #160]	; (800316c <USB_SetTurnaroundTime+0xa8>)
 80030cc:	440b      	add	r3, r1
 80030ce:	4293      	cmp	r3, r2
 80030d0:	d939      	bls.n	8003146 <USB_SetTurnaroundTime+0x82>
    else if ((hclk >= 15000000U) && (hclk < 16000000U))
 80030d2:	4b27      	ldr	r3, [pc, #156]	; (8003170 <USB_SetTurnaroundTime+0xac>)
 80030d4:	4a27      	ldr	r2, [pc, #156]	; (8003174 <USB_SetTurnaroundTime+0xb0>)
 80030d6:	440b      	add	r3, r1
 80030d8:	4293      	cmp	r3, r2
 80030da:	d936      	bls.n	800314a <USB_SetTurnaroundTime+0x86>
    else if ((hclk >= 16000000U) && (hclk < 17200000U))
 80030dc:	4a26      	ldr	r2, [pc, #152]	; (8003178 <USB_SetTurnaroundTime+0xb4>)
 80030de:	f5a1 0374 	sub.w	r3, r1, #15990784	; 0xf40000
 80030e2:	f5a3 5310 	sub.w	r3, r3, #9216	; 0x2400
 80030e6:	4293      	cmp	r3, r2
 80030e8:	d931      	bls.n	800314e <USB_SetTurnaroundTime+0x8a>
    else if ((hclk >= 17200000U) && (hclk < 18500000U))
 80030ea:	4a24      	ldr	r2, [pc, #144]	; (800317c <USB_SetTurnaroundTime+0xb8>)
 80030ec:	f1a1 7383 	sub.w	r3, r1, #17170432	; 0x1060000
 80030f0:	f5a3 43e7 	sub.w	r3, r3, #29568	; 0x7380
 80030f4:	4293      	cmp	r3, r2
 80030f6:	d32c      	bcc.n	8003152 <USB_SetTurnaroundTime+0x8e>
    else if ((hclk >= 18500000U) && (hclk < 20000000U))
 80030f8:	4b21      	ldr	r3, [pc, #132]	; (8003180 <USB_SetTurnaroundTime+0xbc>)
 80030fa:	4a22      	ldr	r2, [pc, #136]	; (8003184 <USB_SetTurnaroundTime+0xc0>)
 80030fc:	440b      	add	r3, r1
 80030fe:	4293      	cmp	r3, r2
 8003100:	d929      	bls.n	8003156 <USB_SetTurnaroundTime+0x92>
    else if ((hclk >= 20000000U) && (hclk < 21800000U))
 8003102:	4b21      	ldr	r3, [pc, #132]	; (8003188 <USB_SetTurnaroundTime+0xc4>)
 8003104:	4a21      	ldr	r2, [pc, #132]	; (800318c <USB_SetTurnaroundTime+0xc8>)
 8003106:	440b      	add	r3, r1
 8003108:	4293      	cmp	r3, r2
 800310a:	d326      	bcc.n	800315a <USB_SetTurnaroundTime+0x96>
    else if ((hclk >= 21800000U) && (hclk < 24000000U))
 800310c:	4b20      	ldr	r3, [pc, #128]	; (8003190 <USB_SetTurnaroundTime+0xcc>)
 800310e:	4a21      	ldr	r2, [pc, #132]	; (8003194 <USB_SetTurnaroundTime+0xd0>)
 8003110:	440b      	add	r3, r1
 8003112:	4293      	cmp	r3, r2
 8003114:	d323      	bcc.n	800315e <USB_SetTurnaroundTime+0x9a>
    else if ((hclk >= 24000000U) && (hclk < 27700000U))
 8003116:	4a20      	ldr	r2, [pc, #128]	; (8003198 <USB_SetTurnaroundTime+0xd4>)
 8003118:	f1a1 73b7 	sub.w	r3, r1, #23986176	; 0x16e0000
 800311c:	f5a3 5358 	sub.w	r3, r3, #13824	; 0x3600
 8003120:	4293      	cmp	r3, r2
 8003122:	d31e      	bcc.n	8003162 <USB_SetTurnaroundTime+0x9e>
    else if ((hclk >= 27700000U) && (hclk < 32000000U))
 8003124:	4b1d      	ldr	r3, [pc, #116]	; (800319c <USB_SetTurnaroundTime+0xd8>)
      UsbTrd = 0x6U;
 8003126:	4a1e      	ldr	r2, [pc, #120]	; (80031a0 <USB_SetTurnaroundTime+0xdc>)
    else if ((hclk >= 27700000U) && (hclk < 32000000U))
 8003128:	440b      	add	r3, r1
      UsbTrd = 0x6U;
 800312a:	4293      	cmp	r3, r2
 800312c:	bf34      	ite	cc
 800312e:	2307      	movcc	r3, #7
 8003130:	2306      	movcs	r3, #6
  USBx->GUSBCFG &= ~USB_OTG_GUSBCFG_TRDT;
 8003132:	68c2      	ldr	r2, [r0, #12]
 8003134:	f422 5270 	bic.w	r2, r2, #15360	; 0x3c00
 8003138:	60c2      	str	r2, [r0, #12]
  USBx->GUSBCFG |= (uint32_t)((UsbTrd << 10) & USB_OTG_GUSBCFG_TRDT);
 800313a:	68c2      	ldr	r2, [r0, #12]
 800313c:	ea42 2383 	orr.w	r3, r2, r3, lsl #10
 8003140:	60c3      	str	r3, [r0, #12]
}
 8003142:	2000      	movs	r0, #0
 8003144:	4770      	bx	lr
      UsbTrd = 0xFU;
 8003146:	230f      	movs	r3, #15
 8003148:	e7f3      	b.n	8003132 <USB_SetTurnaroundTime+0x6e>
      UsbTrd = 0xEU;
 800314a:	230e      	movs	r3, #14
 800314c:	e7f1      	b.n	8003132 <USB_SetTurnaroundTime+0x6e>
      UsbTrd = 0xDU;
 800314e:	230d      	movs	r3, #13
 8003150:	e7ef      	b.n	8003132 <USB_SetTurnaroundTime+0x6e>
      UsbTrd = 0xCU;
 8003152:	230c      	movs	r3, #12
 8003154:	e7ed      	b.n	8003132 <USB_SetTurnaroundTime+0x6e>
      UsbTrd = 0xBU;
 8003156:	230b      	movs	r3, #11
 8003158:	e7eb      	b.n	8003132 <USB_SetTurnaroundTime+0x6e>
      UsbTrd = 0xAU;
 800315a:	230a      	movs	r3, #10
 800315c:	e7e9      	b.n	8003132 <USB_SetTurnaroundTime+0x6e>
    UsbTrd = USBD_HS_TRDT_VALUE;
 800315e:	2309      	movs	r3, #9
 8003160:	e7e7      	b.n	8003132 <USB_SetTurnaroundTime+0x6e>
      UsbTrd = 0x8U;
 8003162:	2308      	movs	r3, #8
 8003164:	e7e5      	b.n	8003132 <USB_SetTurnaroundTime+0x6e>
 8003166:	bf00      	nop
 8003168:	ff275340 	.word	0xff275340
 800316c:	000c34ff 	.word	0x000c34ff
 8003170:	ff1b1e40 	.word	0xff1b1e40
 8003174:	000f423f 	.word	0x000f423f
 8003178:	00124f7f 	.word	0x00124f7f
 800317c:	0013d620 	.word	0x0013d620
 8003180:	fee5b660 	.word	0xfee5b660
 8003184:	0016e35f 	.word	0x0016e35f
 8003188:	feced300 	.word	0xfeced300
 800318c:	001b7740 	.word	0x001b7740
 8003190:	feb35bc0 	.word	0xfeb35bc0
 8003194:	002191c0 	.word	0x002191c0
 8003198:	00387520 	.word	0x00387520
 800319c:	fe5954e0 	.word	0xfe5954e0
 80031a0:	00419ce0 	.word	0x00419ce0

080031a4 <USB_EnableGlobalInt>:
  USBx->GAHBCFG |= USB_OTG_GAHBCFG_GINT;
 80031a4:	6883      	ldr	r3, [r0, #8]
 80031a6:	f043 0301 	orr.w	r3, r3, #1
 80031aa:	6083      	str	r3, [r0, #8]
}
 80031ac:	2000      	movs	r0, #0
 80031ae:	4770      	bx	lr

080031b0 <USB_DisableGlobalInt>:
  USBx->GAHBCFG &= ~USB_OTG_GAHBCFG_GINT;
 80031b0:	6883      	ldr	r3, [r0, #8]
 80031b2:	f023 0301 	bic.w	r3, r3, #1
 80031b6:	6083      	str	r3, [r0, #8]
}
 80031b8:	2000      	movs	r0, #0
 80031ba:	4770      	bx	lr

080031bc <USB_SetCurrentMode>:
{
 80031bc:	b538      	push	{r3, r4, r5, lr}
  USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_FHMOD | USB_OTG_GUSBCFG_FDMOD);
 80031be:	68c3      	ldr	r3, [r0, #12]
  if (mode == USB_HOST_MODE)
 80031c0:	2901      	cmp	r1, #1
  USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_FHMOD | USB_OTG_GUSBCFG_FDMOD);
 80031c2:	f023 43c0 	bic.w	r3, r3, #1610612736	; 0x60000000
{
 80031c6:	4605      	mov	r5, r0
  USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_FHMOD | USB_OTG_GUSBCFG_FDMOD);
 80031c8:	60c3      	str	r3, [r0, #12]
  if (mode == USB_HOST_MODE)
 80031ca:	d110      	bne.n	80031ee <USB_SetCurrentMode+0x32>
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_FHMOD;
 80031cc:	68c3      	ldr	r3, [r0, #12]
 80031ce:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
 80031d2:	60c3      	str	r3, [r0, #12]
  uint32_t ms = 0U;
 80031d4:	2400      	movs	r4, #0
      HAL_Delay(1U);
 80031d6:	2001      	movs	r0, #1
 80031d8:	f7fd fe7a 	bl	8000ed0 <HAL_Delay>
  return ((USBx->GINTSTS) & 0x1U);
 80031dc:	696b      	ldr	r3, [r5, #20]
    } while ((USB_GetMode(USBx) != (uint32_t)USB_HOST_MODE) && (ms < 50U));
 80031de:	07d9      	lsls	r1, r3, #31
      ms++;
 80031e0:	f104 0401 	add.w	r4, r4, #1
    } while ((USB_GetMode(USBx) != (uint32_t)USB_HOST_MODE) && (ms < 50U));
 80031e4:	d415      	bmi.n	8003212 <USB_SetCurrentMode+0x56>
 80031e6:	2c32      	cmp	r4, #50	; 0x32
 80031e8:	d1f5      	bne.n	80031d6 <USB_SetCurrentMode+0x1a>
    return HAL_ERROR;
 80031ea:	2001      	movs	r0, #1
}
 80031ec:	bd38      	pop	{r3, r4, r5, pc}
  else if (mode == USB_DEVICE_MODE)
 80031ee:	2900      	cmp	r1, #0
 80031f0:	d1fb      	bne.n	80031ea <USB_SetCurrentMode+0x2e>
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_FDMOD;
 80031f2:	68c3      	ldr	r3, [r0, #12]
 80031f4:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
 80031f8:	60c3      	str	r3, [r0, #12]
  uint32_t ms = 0U;
 80031fa:	460c      	mov	r4, r1
      HAL_Delay(1U);
 80031fc:	2001      	movs	r0, #1
 80031fe:	f7fd fe67 	bl	8000ed0 <HAL_Delay>
  return ((USBx->GINTSTS) & 0x1U);
 8003202:	696b      	ldr	r3, [r5, #20]
    } while ((USB_GetMode(USBx) != (uint32_t)USB_DEVICE_MODE) && (ms < 50U));
 8003204:	07da      	lsls	r2, r3, #31
      ms++;
 8003206:	f104 0401 	add.w	r4, r4, #1
    } while ((USB_GetMode(USBx) != (uint32_t)USB_DEVICE_MODE) && (ms < 50U));
 800320a:	d502      	bpl.n	8003212 <USB_SetCurrentMode+0x56>
 800320c:	2c32      	cmp	r4, #50	; 0x32
 800320e:	d1f5      	bne.n	80031fc <USB_SetCurrentMode+0x40>
 8003210:	e7eb      	b.n	80031ea <USB_SetCurrentMode+0x2e>
    return HAL_ERROR;
 8003212:	f1a4 0332 	sub.w	r3, r4, #50	; 0x32
 8003216:	4258      	negs	r0, r3
 8003218:	4158      	adcs	r0, r3
 800321a:	e7e7      	b.n	80031ec <USB_SetCurrentMode+0x30>

0800321c <USB_FlushTxFifo>:
{
 800321c:	b082      	sub	sp, #8
  __IO uint32_t count = 0U;
 800321e:	2300      	movs	r3, #0
    if (count > 200000U)
 8003220:	4a10      	ldr	r2, [pc, #64]	; (8003264 <USB_FlushTxFifo+0x48>)
  __IO uint32_t count = 0U;
 8003222:	9301      	str	r3, [sp, #4]
    count++;
 8003224:	9b01      	ldr	r3, [sp, #4]
 8003226:	3301      	adds	r3, #1
 8003228:	9301      	str	r3, [sp, #4]
    if (count > 200000U)
 800322a:	9b01      	ldr	r3, [sp, #4]
 800322c:	4293      	cmp	r3, r2
 800322e:	d816      	bhi.n	800325e <USB_FlushTxFifo+0x42>
  } while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_AHBIDL) == 0U);
 8003230:	6903      	ldr	r3, [r0, #16]
 8003232:	2b00      	cmp	r3, #0
 8003234:	daf6      	bge.n	8003224 <USB_FlushTxFifo+0x8>
  USBx->GRSTCTL = (USB_OTG_GRSTCTL_TXFFLSH | (num << 6));
 8003236:	0189      	lsls	r1, r1, #6
  count = 0U;
 8003238:	2300      	movs	r3, #0
  USBx->GRSTCTL = (USB_OTG_GRSTCTL_TXFFLSH | (num << 6));
 800323a:	f041 0120 	orr.w	r1, r1, #32
    if (count > 200000U)
 800323e:	4a09      	ldr	r2, [pc, #36]	; (8003264 <USB_FlushTxFifo+0x48>)
  count = 0U;
 8003240:	9301      	str	r3, [sp, #4]
  USBx->GRSTCTL = (USB_OTG_GRSTCTL_TXFFLSH | (num << 6));
 8003242:	6101      	str	r1, [r0, #16]
    count++;
 8003244:	9b01      	ldr	r3, [sp, #4]
 8003246:	3301      	adds	r3, #1
 8003248:	9301      	str	r3, [sp, #4]
    if (count > 200000U)
 800324a:	9b01      	ldr	r3, [sp, #4]
 800324c:	4293      	cmp	r3, r2
 800324e:	d806      	bhi.n	800325e <USB_FlushTxFifo+0x42>
  } while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_TXFFLSH) == USB_OTG_GRSTCTL_TXFFLSH);
 8003250:	6903      	ldr	r3, [r0, #16]
 8003252:	f013 0320 	ands.w	r3, r3, #32
 8003256:	d1f5      	bne.n	8003244 <USB_FlushTxFifo+0x28>
  return HAL_OK;
 8003258:	4618      	mov	r0, r3
}
 800325a:	b002      	add	sp, #8
 800325c:	4770      	bx	lr
      return HAL_TIMEOUT;
 800325e:	2003      	movs	r0, #3
 8003260:	e7fb      	b.n	800325a <USB_FlushTxFifo+0x3e>
 8003262:	bf00      	nop
 8003264:	00030d40 	.word	0x00030d40

08003268 <USB_FlushRxFifo>:
{
 8003268:	b082      	sub	sp, #8
  __IO uint32_t count = 0U;
 800326a:	2300      	movs	r3, #0
    if (count > 200000U)
 800326c:	4a0f      	ldr	r2, [pc, #60]	; (80032ac <USB_FlushRxFifo+0x44>)
  __IO uint32_t count = 0U;
 800326e:	9301      	str	r3, [sp, #4]
    count++;
 8003270:	9b01      	ldr	r3, [sp, #4]
 8003272:	3301      	adds	r3, #1
 8003274:	9301      	str	r3, [sp, #4]
    if (count > 200000U)
 8003276:	9b01      	ldr	r3, [sp, #4]
 8003278:	4293      	cmp	r3, r2
 800327a:	d814      	bhi.n	80032a6 <USB_FlushRxFifo+0x3e>
  } while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_AHBIDL) == 0U);
 800327c:	6903      	ldr	r3, [r0, #16]
 800327e:	2b00      	cmp	r3, #0
 8003280:	daf6      	bge.n	8003270 <USB_FlushRxFifo+0x8>
  count = 0U;
 8003282:	2300      	movs	r3, #0
 8003284:	9301      	str	r3, [sp, #4]
    if (count > 200000U)
 8003286:	4a09      	ldr	r2, [pc, #36]	; (80032ac <USB_FlushRxFifo+0x44>)
  USBx->GRSTCTL = USB_OTG_GRSTCTL_RXFFLSH;
 8003288:	2310      	movs	r3, #16
 800328a:	6103      	str	r3, [r0, #16]
    count++;
 800328c:	9b01      	ldr	r3, [sp, #4]
 800328e:	3301      	adds	r3, #1
 8003290:	9301      	str	r3, [sp, #4]
    if (count > 200000U)
 8003292:	9b01      	ldr	r3, [sp, #4]
 8003294:	4293      	cmp	r3, r2
 8003296:	d806      	bhi.n	80032a6 <USB_FlushRxFifo+0x3e>
  } while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_RXFFLSH) == USB_OTG_GRSTCTL_RXFFLSH);
 8003298:	6903      	ldr	r3, [r0, #16]
 800329a:	f013 0310 	ands.w	r3, r3, #16
 800329e:	d1f5      	bne.n	800328c <USB_FlushRxFifo+0x24>
  return HAL_OK;
 80032a0:	4618      	mov	r0, r3
}
 80032a2:	b002      	add	sp, #8
 80032a4:	4770      	bx	lr
      return HAL_TIMEOUT;
 80032a6:	2003      	movs	r0, #3
 80032a8:	e7fb      	b.n	80032a2 <USB_FlushRxFifo+0x3a>
 80032aa:	bf00      	nop
 80032ac:	00030d40 	.word	0x00030d40

080032b0 <USB_SetDevSpeed>:
  USBx_DEVICE->DCFG |= speed;
 80032b0:	f8d0 3800 	ldr.w	r3, [r0, #2048]	; 0x800
 80032b4:	4319      	orrs	r1, r3
 80032b6:	f8c0 1800 	str.w	r1, [r0, #2048]	; 0x800
}
 80032ba:	2000      	movs	r0, #0
 80032bc:	4770      	bx	lr
	...

080032c0 <USB_DevInit>:
{
 80032c0:	b084      	sub	sp, #16
 80032c2:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 80032c6:	4604      	mov	r4, r0
 80032c8:	a809      	add	r0, sp, #36	; 0x24
 80032ca:	e880 000e 	stmia.w	r0, {r1, r2, r3}
 80032ce:	9d13      	ldr	r5, [sp, #76]	; 0x4c
  for (i = 0U; i < 15U; i++)
 80032d0:	2300      	movs	r3, #0
 80032d2:	460e      	mov	r6, r1
    USBx->DIEPTXF[i] = 0U;
 80032d4:	4619      	mov	r1, r3
 80032d6:	f103 0240 	add.w	r2, r3, #64	; 0x40
 80032da:	eb04 0282 	add.w	r2, r4, r2, lsl #2
  for (i = 0U; i < 15U; i++)
 80032de:	3301      	adds	r3, #1
 80032e0:	2b0f      	cmp	r3, #15
    USBx->DIEPTXF[i] = 0U;
 80032e2:	6051      	str	r1, [r2, #4]
  for (i = 0U; i < 15U; i++)
 80032e4:	d1f7      	bne.n	80032d6 <USB_DevInit+0x16>
    USBx_DEVICE->DCTL |= USB_OTG_DCTL_SDIS;
 80032e6:	f504 6700 	add.w	r7, r4, #2048	; 0x800
  if (cfg.vbus_sensing_enable == 0U)
 80032ea:	2d00      	cmp	r5, #0
 80032ec:	d16c      	bne.n	80033c8 <USB_DevInit+0x108>
    USBx_DEVICE->DCTL |= USB_OTG_DCTL_SDIS;
 80032ee:	687b      	ldr	r3, [r7, #4]
 80032f0:	f043 0302 	orr.w	r3, r3, #2
 80032f4:	607b      	str	r3, [r7, #4]
    USBx->GCCFG |= USB_OTG_GCCFG_NOVBUSSENS;
 80032f6:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 80032f8:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 80032fc:	63a3      	str	r3, [r4, #56]	; 0x38
    USBx->GCCFG &= ~USB_OTG_GCCFG_VBUSBSEN;
 80032fe:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8003300:	f423 2300 	bic.w	r3, r3, #524288	; 0x80000
 8003304:	63a3      	str	r3, [r4, #56]	; 0x38
    USBx->GCCFG &= ~USB_OTG_GCCFG_VBUSASEN;
 8003306:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8003308:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
    USBx->GCCFG |= USB_OTG_GCCFG_VBUSBSEN;
 800330c:	63a3      	str	r3, [r4, #56]	; 0x38
  USBx_PCGCCTL = 0U;
 800330e:	2300      	movs	r3, #0
 8003310:	f8c4 3e00 	str.w	r3, [r4, #3584]	; 0xe00
  USBx_DEVICE->DCFG |= DCFG_FRAME_INTERVAL_80;
 8003314:	f8d4 3800 	ldr.w	r3, [r4, #2048]	; 0x800
 8003318:	f8c4 3800 	str.w	r3, [r4, #2048]	; 0x800
  if (cfg.phy_itface == USB_OTG_ULPI_PHY)
 800331c:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 800331e:	2b01      	cmp	r3, #1
 8003320:	d15c      	bne.n	80033dc <USB_DevInit+0x11c>
    if (cfg.speed == USBD_HS_SPEED)
 8003322:	990b      	ldr	r1, [sp, #44]	; 0x2c
 8003324:	2900      	cmp	r1, #0
 8003326:	d157      	bne.n	80033d8 <USB_DevInit+0x118>
    (void)USB_SetDevSpeed(USBx, USB_OTG_SPEED_FULL);
 8003328:	4620      	mov	r0, r4
 800332a:	f7ff ffc1 	bl	80032b0 <USB_SetDevSpeed>
  if (USB_FlushTxFifo(USBx, 0x10U) != HAL_OK) /* all Tx FIFOs */
 800332e:	2110      	movs	r1, #16
 8003330:	4620      	mov	r0, r4
 8003332:	f7ff ff73 	bl	800321c <USB_FlushTxFifo>
 8003336:	4601      	mov	r1, r0
  if (USB_FlushRxFifo(USBx) != HAL_OK)
 8003338:	4620      	mov	r0, r4
 800333a:	f7ff ff95 	bl	8003268 <USB_FlushRxFifo>
 800333e:	4308      	orrs	r0, r1
 8003340:	b2c0      	uxtb	r0, r0
  USBx_DEVICE->DIEPMSK = 0U;
 8003342:	2300      	movs	r3, #0
    ret = HAL_ERROR;
 8003344:	3800      	subs	r0, #0
  USBx_DEVICE->DIEPMSK = 0U;
 8003346:	613b      	str	r3, [r7, #16]
    ret = HAL_ERROR;
 8003348:	bf18      	it	ne
 800334a:	2001      	movne	r0, #1
  USBx_DEVICE->DOEPMSK = 0U;
 800334c:	617b      	str	r3, [r7, #20]
  USBx_DEVICE->DAINTMSK = 0U;
 800334e:	f504 6210 	add.w	r2, r4, #2304	; 0x900
 8003352:	61fb      	str	r3, [r7, #28]
      USBx_INEP(i)->DIEPCTL = 0U;
 8003354:	4619      	mov	r1, r3
        USBx_INEP(i)->DIEPCTL = USB_OTG_DIEPCTL_EPDIS | USB_OTG_DIEPCTL_SNAK;
 8003356:	f04f 4c90 	mov.w	ip, #1207959552	; 0x48000000
        USBx_INEP(i)->DIEPCTL = USB_OTG_DIEPCTL_SNAK;
 800335a:	f04f 6e00 	mov.w	lr, #134217728	; 0x8000000
    USBx_INEP(i)->DIEPINT  = 0xFB7FU;
 800335e:	f64f 387f 	movw	r8, #64383	; 0xfb7f
  for (i = 0U; i < cfg.dev_endpoints; i++)
 8003362:	42b3      	cmp	r3, r6
 8003364:	d13c      	bne.n	80033e0 <USB_DevInit+0x120>
  for (i = 0U; i < cfg.dev_endpoints; i++)
 8003366:	2200      	movs	r2, #0
 8003368:	f504 6330 	add.w	r3, r4, #2816	; 0xb00
      USBx_OUTEP(i)->DOEPCTL = 0U;
 800336c:	4611      	mov	r1, r2
        USBx_OUTEP(i)->DOEPCTL = USB_OTG_DOEPCTL_EPDIS | USB_OTG_DOEPCTL_SNAK;
 800336e:	f04f 4c90 	mov.w	ip, #1207959552	; 0x48000000
        USBx_OUTEP(i)->DOEPCTL = USB_OTG_DOEPCTL_SNAK;
 8003372:	f04f 6e00 	mov.w	lr, #134217728	; 0x8000000
    USBx_OUTEP(i)->DOEPINT  = 0xFB7FU;
 8003376:	f64f 387f 	movw	r8, #64383	; 0xfb7f
  for (i = 0U; i < cfg.dev_endpoints; i++)
 800337a:	42b2      	cmp	r2, r6
 800337c:	d143      	bne.n	8003406 <USB_DevInit+0x146>
  USBx_DEVICE->DIEPMSK &= ~(USB_OTG_DIEPMSK_TXFURM);
 800337e:	693b      	ldr	r3, [r7, #16]
 8003380:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 8003384:	613b      	str	r3, [r7, #16]
  USBx->GINTMSK = 0U;
 8003386:	2300      	movs	r3, #0
 8003388:	61a3      	str	r3, [r4, #24]
  USBx->GINTSTS = 0xBFFFFFFFU;
 800338a:	f06f 4380 	mvn.w	r3, #1073741824	; 0x40000000
 800338e:	6163      	str	r3, [r4, #20]
  if (cfg.dma_enable == 0U)
 8003390:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8003392:	b91b      	cbnz	r3, 800339c <USB_DevInit+0xdc>
    USBx->GINTMSK |= USB_OTG_GINTMSK_RXFLVLM;
 8003394:	69a3      	ldr	r3, [r4, #24]
 8003396:	f043 0310 	orr.w	r3, r3, #16
 800339a:	61a3      	str	r3, [r4, #24]
  USBx->GINTMSK |= USB_OTG_GINTMSK_USBSUSPM | USB_OTG_GINTMSK_USBRST |
 800339c:	69a2      	ldr	r2, [r4, #24]
 800339e:	4b23      	ldr	r3, [pc, #140]	; (800342c <USB_DevInit+0x16c>)
 80033a0:	4313      	orrs	r3, r2
 80033a2:	61a3      	str	r3, [r4, #24]
  if (cfg.Sof_enable != 0U)
 80033a4:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 80033a6:	b11b      	cbz	r3, 80033b0 <USB_DevInit+0xf0>
    USBx->GINTMSK |= USB_OTG_GINTMSK_SOFM;
 80033a8:	69a3      	ldr	r3, [r4, #24]
 80033aa:	f043 0308 	orr.w	r3, r3, #8
 80033ae:	61a3      	str	r3, [r4, #24]
  if (cfg.vbus_sensing_enable == 1U)
 80033b0:	2d01      	cmp	r5, #1
    USBx->GINTMSK |= (USB_OTG_GINTMSK_SRQIM | USB_OTG_GINTMSK_OTGINT);
 80033b2:	bf01      	itttt	eq
 80033b4:	69a3      	ldreq	r3, [r4, #24]
 80033b6:	f043 4380 	orreq.w	r3, r3, #1073741824	; 0x40000000
 80033ba:	f043 0304 	orreq.w	r3, r3, #4
 80033be:	61a3      	streq	r3, [r4, #24]
}
 80033c0:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 80033c4:	b004      	add	sp, #16
 80033c6:	4770      	bx	lr
    USBx->GCCFG &= ~USB_OTG_GCCFG_NOVBUSSENS;
 80033c8:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 80033ca:	f423 1300 	bic.w	r3, r3, #2097152	; 0x200000
 80033ce:	63a3      	str	r3, [r4, #56]	; 0x38
    USBx->GCCFG |= USB_OTG_GCCFG_VBUSBSEN;
 80033d0:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 80033d2:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
 80033d6:	e799      	b.n	800330c <USB_DevInit+0x4c>
      (void)USB_SetDevSpeed(USBx, USB_OTG_SPEED_HIGH_IN_FULL);
 80033d8:	4619      	mov	r1, r3
 80033da:	e7a5      	b.n	8003328 <USB_DevInit+0x68>
    (void)USB_SetDevSpeed(USBx, USB_OTG_SPEED_FULL);
 80033dc:	2103      	movs	r1, #3
 80033de:	e7a3      	b.n	8003328 <USB_DevInit+0x68>
    if ((USBx_INEP(i)->DIEPCTL & USB_OTG_DIEPCTL_EPENA) == USB_OTG_DIEPCTL_EPENA)
 80033e0:	f8d2 9000 	ldr.w	r9, [r2]
 80033e4:	f1b9 0f00 	cmp.w	r9, #0
 80033e8:	da0b      	bge.n	8003402 <USB_DevInit+0x142>
      if (i == 0U)
 80033ea:	b93b      	cbnz	r3, 80033fc <USB_DevInit+0x13c>
        USBx_INEP(i)->DIEPCTL = USB_OTG_DIEPCTL_SNAK;
 80033ec:	f8c2 e000 	str.w	lr, [r2]
    USBx_INEP(i)->DIEPTSIZ = 0U;
 80033f0:	6111      	str	r1, [r2, #16]
  for (i = 0U; i < cfg.dev_endpoints; i++)
 80033f2:	3301      	adds	r3, #1
    USBx_INEP(i)->DIEPINT  = 0xFB7FU;
 80033f4:	f8c2 8008 	str.w	r8, [r2, #8]
  for (i = 0U; i < cfg.dev_endpoints; i++)
 80033f8:	3220      	adds	r2, #32
 80033fa:	e7b2      	b.n	8003362 <USB_DevInit+0xa2>
        USBx_INEP(i)->DIEPCTL = USB_OTG_DIEPCTL_EPDIS | USB_OTG_DIEPCTL_SNAK;
 80033fc:	f8c2 c000 	str.w	ip, [r2]
 8003400:	e7f6      	b.n	80033f0 <USB_DevInit+0x130>
      USBx_INEP(i)->DIEPCTL = 0U;
 8003402:	6011      	str	r1, [r2, #0]
 8003404:	e7f4      	b.n	80033f0 <USB_DevInit+0x130>
    if ((USBx_OUTEP(i)->DOEPCTL & USB_OTG_DOEPCTL_EPENA) == USB_OTG_DOEPCTL_EPENA)
 8003406:	f8d3 9000 	ldr.w	r9, [r3]
 800340a:	f1b9 0f00 	cmp.w	r9, #0
 800340e:	da0b      	bge.n	8003428 <USB_DevInit+0x168>
      if (i == 0U)
 8003410:	b93a      	cbnz	r2, 8003422 <USB_DevInit+0x162>
        USBx_OUTEP(i)->DOEPCTL = USB_OTG_DOEPCTL_SNAK;
 8003412:	f8c3 e000 	str.w	lr, [r3]
    USBx_OUTEP(i)->DOEPTSIZ = 0U;
 8003416:	6119      	str	r1, [r3, #16]
  for (i = 0U; i < cfg.dev_endpoints; i++)
 8003418:	3201      	adds	r2, #1
    USBx_OUTEP(i)->DOEPINT  = 0xFB7FU;
 800341a:	f8c3 8008 	str.w	r8, [r3, #8]
  for (i = 0U; i < cfg.dev_endpoints; i++)
 800341e:	3320      	adds	r3, #32
 8003420:	e7ab      	b.n	800337a <USB_DevInit+0xba>
        USBx_OUTEP(i)->DOEPCTL = USB_OTG_DOEPCTL_EPDIS | USB_OTG_DOEPCTL_SNAK;
 8003422:	f8c3 c000 	str.w	ip, [r3]
 8003426:	e7f6      	b.n	8003416 <USB_DevInit+0x156>
      USBx_OUTEP(i)->DOEPCTL = 0U;
 8003428:	6019      	str	r1, [r3, #0]
 800342a:	e7f4      	b.n	8003416 <USB_DevInit+0x156>
 800342c:	803c3800 	.word	0x803c3800

08003430 <USB_GetDevSpeed>:
  uint32_t DevEnumSpeed = USBx_DEVICE->DSTS & USB_OTG_DSTS_ENUMSPD;
 8003430:	f8d0 3808 	ldr.w	r3, [r0, #2056]	; 0x808
  if (DevEnumSpeed == DSTS_ENUMSPD_HS_PHY_30MHZ_OR_60MHZ)
 8003434:	f013 0006 	ands.w	r0, r3, #6
 8003438:	d004      	beq.n	8003444 <USB_GetDevSpeed+0x14>
    speed = 0xFU;
 800343a:	f013 0f02 	tst.w	r3, #2
 800343e:	bf14      	ite	ne
 8003440:	2002      	movne	r0, #2
 8003442:	200f      	moveq	r0, #15
}
 8003444:	4770      	bx	lr

08003446 <USB_ActivateEndpoint>:
{
 8003446:	b530      	push	{r4, r5, lr}
  uint32_t epnum = (uint32_t)ep->num;
 8003448:	780c      	ldrb	r4, [r1, #0]
    USBx_DEVICE->DAINTMSK |= USB_OTG_DAINTMSK_IEPM & (uint32_t)(1UL << (ep->num & EP_ADDR_MSK));
 800344a:	2201      	movs	r2, #1
 800344c:	f004 050f 	and.w	r5, r4, #15
 8003450:	40aa      	lsls	r2, r5
  if (ep->is_in == 1U)
 8003452:	784d      	ldrb	r5, [r1, #1]
 8003454:	2d01      	cmp	r5, #1
    USBx_DEVICE->DAINTMSK |= USB_OTG_DAINTMSK_IEPM & (uint32_t)(1UL << (ep->num & EP_ADDR_MSK));
 8003456:	f500 6300 	add.w	r3, r0, #2048	; 0x800
    if ((USBx_INEP(epnum)->DIEPCTL & USB_OTG_DIEPCTL_USBAEP) == 0U)
 800345a:	eb00 1044 	add.w	r0, r0, r4, lsl #5
  if (ep->is_in == 1U)
 800345e:	d119      	bne.n	8003494 <USB_ActivateEndpoint+0x4e>
    USBx_DEVICE->DAINTMSK |= USB_OTG_DAINTMSK_IEPM & (uint32_t)(1UL << (ep->num & EP_ADDR_MSK));
 8003460:	69dd      	ldr	r5, [r3, #28]
 8003462:	432a      	orrs	r2, r5
 8003464:	61da      	str	r2, [r3, #28]
    if ((USBx_INEP(epnum)->DIEPCTL & USB_OTG_DIEPCTL_USBAEP) == 0U)
 8003466:	f8d0 3900 	ldr.w	r3, [r0, #2304]	; 0x900
 800346a:	041a      	lsls	r2, r3, #16
 800346c:	d410      	bmi.n	8003490 <USB_ActivateEndpoint+0x4a>
      USBx_INEP(epnum)->DIEPCTL |= (ep->maxpacket & USB_OTG_DIEPCTL_MPSIZ) |
 800346e:	68ca      	ldr	r2, [r1, #12]
 8003470:	f8d0 5900 	ldr.w	r5, [r0, #2304]	; 0x900
 8003474:	f3c2 030a 	ubfx	r3, r2, #0, #11
                                   ((uint32_t)ep->type << 18) | (epnum << 22) |
 8003478:	790a      	ldrb	r2, [r1, #4]
      USBx_INEP(epnum)->DIEPCTL |= (ep->maxpacket & USB_OTG_DIEPCTL_MPSIZ) |
 800347a:	432b      	orrs	r3, r5
 800347c:	ea43 4382 	orr.w	r3, r3, r2, lsl #18
 8003480:	ea43 5384 	orr.w	r3, r3, r4, lsl #22
 8003484:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 8003488:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 800348c:	f8c0 3900 	str.w	r3, [r0, #2304]	; 0x900
}
 8003490:	2000      	movs	r0, #0
 8003492:	bd30      	pop	{r4, r5, pc}
    USBx_DEVICE->DAINTMSK |= USB_OTG_DAINTMSK_OEPM & ((uint32_t)(1UL << (ep->num & EP_ADDR_MSK)) << 16);
 8003494:	69dc      	ldr	r4, [r3, #28]
 8003496:	ea44 4202 	orr.w	r2, r4, r2, lsl #16
 800349a:	61da      	str	r2, [r3, #28]
    if (((USBx_OUTEP(epnum)->DOEPCTL) & USB_OTG_DOEPCTL_USBAEP) == 0U)
 800349c:	f8d0 3b00 	ldr.w	r3, [r0, #2816]	; 0xb00
 80034a0:	041b      	lsls	r3, r3, #16
 80034a2:	d4f5      	bmi.n	8003490 <USB_ActivateEndpoint+0x4a>
      USBx_OUTEP(epnum)->DOEPCTL |= (ep->maxpacket & USB_OTG_DOEPCTL_MPSIZ) |
 80034a4:	68cb      	ldr	r3, [r1, #12]
 80034a6:	f8d0 2b00 	ldr.w	r2, [r0, #2816]	; 0xb00
 80034aa:	f3c3 030a 	ubfx	r3, r3, #0, #11
 80034ae:	4313      	orrs	r3, r2
                                    ((uint32_t)ep->type << 18) |
 80034b0:	790a      	ldrb	r2, [r1, #4]
      USBx_OUTEP(epnum)->DOEPCTL |= (ep->maxpacket & USB_OTG_DOEPCTL_MPSIZ) |
 80034b2:	ea43 4382 	orr.w	r3, r3, r2, lsl #18
 80034b6:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 80034ba:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 80034be:	f8c0 3b00 	str.w	r3, [r0, #2816]	; 0xb00
 80034c2:	e7e5      	b.n	8003490 <USB_ActivateEndpoint+0x4a>

080034c4 <USB_DeactivateEndpoint>:
{
 80034c4:	b510      	push	{r4, lr}
  uint32_t epnum = (uint32_t)ep->num;
 80034c6:	780a      	ldrb	r2, [r1, #0]
  if (ep->is_in == 1U)
 80034c8:	7849      	ldrb	r1, [r1, #1]
 80034ca:	2901      	cmp	r1, #1
    if ((USBx_INEP(epnum)->DIEPCTL & USB_OTG_DIEPCTL_EPENA) == USB_OTG_DIEPCTL_EPENA)
 80034cc:	eb00 1342 	add.w	r3, r0, r2, lsl #5
 80034d0:	f500 6000 	add.w	r0, r0, #2048	; 0x800
 80034d4:	f002 020f 	and.w	r2, r2, #15
  if (ep->is_in == 1U)
 80034d8:	d122      	bne.n	8003520 <USB_DeactivateEndpoint+0x5c>
    if ((USBx_INEP(epnum)->DIEPCTL & USB_OTG_DIEPCTL_EPENA) == USB_OTG_DIEPCTL_EPENA)
 80034da:	f8d3 1900 	ldr.w	r1, [r3, #2304]	; 0x900
 80034de:	2900      	cmp	r1, #0
 80034e0:	da0b      	bge.n	80034fa <USB_DeactivateEndpoint+0x36>
      USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_SNAK;
 80034e2:	f8d3 1900 	ldr.w	r1, [r3, #2304]	; 0x900
 80034e6:	f041 6100 	orr.w	r1, r1, #134217728	; 0x8000000
 80034ea:	f8c3 1900 	str.w	r1, [r3, #2304]	; 0x900
      USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_EPDIS;
 80034ee:	f8d3 1900 	ldr.w	r1, [r3, #2304]	; 0x900
 80034f2:	f041 4180 	orr.w	r1, r1, #1073741824	; 0x40000000
 80034f6:	f8c3 1900 	str.w	r1, [r3, #2304]	; 0x900
    USBx_DEVICE->DEACHMSK &= ~(USB_OTG_DAINTMSK_IEPM & (uint32_t)(1UL << (ep->num & EP_ADDR_MSK)));
 80034fa:	6bc4      	ldr	r4, [r0, #60]	; 0x3c
 80034fc:	2101      	movs	r1, #1
 80034fe:	fa01 f202 	lsl.w	r2, r1, r2
 8003502:	ea24 0402 	bic.w	r4, r4, r2
 8003506:	63c4      	str	r4, [r0, #60]	; 0x3c
    USBx_DEVICE->DAINTMSK &= ~(USB_OTG_DAINTMSK_IEPM & (uint32_t)(1UL << (ep->num & EP_ADDR_MSK)));
 8003508:	69c1      	ldr	r1, [r0, #28]
 800350a:	ea21 0202 	bic.w	r2, r1, r2
 800350e:	61c2      	str	r2, [r0, #28]
    USBx_INEP(epnum)->DIEPCTL &= ~(USB_OTG_DIEPCTL_USBAEP |
 8003510:	f8d3 1900 	ldr.w	r1, [r3, #2304]	; 0x900
 8003514:	4a14      	ldr	r2, [pc, #80]	; (8003568 <USB_DeactivateEndpoint+0xa4>)
 8003516:	400a      	ands	r2, r1
 8003518:	f8c3 2900 	str.w	r2, [r3, #2304]	; 0x900
}
 800351c:	2000      	movs	r0, #0
 800351e:	bd10      	pop	{r4, pc}
    if ((USBx_OUTEP(epnum)->DOEPCTL & USB_OTG_DOEPCTL_EPENA) == USB_OTG_DOEPCTL_EPENA)
 8003520:	f8d3 1b00 	ldr.w	r1, [r3, #2816]	; 0xb00
 8003524:	2900      	cmp	r1, #0
 8003526:	da0b      	bge.n	8003540 <USB_DeactivateEndpoint+0x7c>
      USBx_OUTEP(epnum)->DOEPCTL |= USB_OTG_DOEPCTL_SNAK;
 8003528:	f8d3 1b00 	ldr.w	r1, [r3, #2816]	; 0xb00
 800352c:	f041 6100 	orr.w	r1, r1, #134217728	; 0x8000000
 8003530:	f8c3 1b00 	str.w	r1, [r3, #2816]	; 0xb00
      USBx_OUTEP(epnum)->DOEPCTL |= USB_OTG_DOEPCTL_EPDIS;
 8003534:	f8d3 1b00 	ldr.w	r1, [r3, #2816]	; 0xb00
 8003538:	f041 4180 	orr.w	r1, r1, #1073741824	; 0x40000000
 800353c:	f8c3 1b00 	str.w	r1, [r3, #2816]	; 0xb00
    USBx_DEVICE->DEACHMSK &= ~(USB_OTG_DAINTMSK_OEPM & ((uint32_t)(1UL << (ep->num & EP_ADDR_MSK)) << 16));
 8003540:	6bc4      	ldr	r4, [r0, #60]	; 0x3c
 8003542:	f44f 3180 	mov.w	r1, #65536	; 0x10000
 8003546:	fa01 f202 	lsl.w	r2, r1, r2
 800354a:	ea24 0402 	bic.w	r4, r4, r2
 800354e:	63c4      	str	r4, [r0, #60]	; 0x3c
    USBx_DEVICE->DAINTMSK &= ~(USB_OTG_DAINTMSK_OEPM & ((uint32_t)(1UL << (ep->num & EP_ADDR_MSK)) << 16));
 8003550:	69c1      	ldr	r1, [r0, #28]
 8003552:	ea21 0202 	bic.w	r2, r1, r2
 8003556:	61c2      	str	r2, [r0, #28]
    USBx_OUTEP(epnum)->DOEPCTL &= ~(USB_OTG_DOEPCTL_USBAEP |
 8003558:	f8d3 1b00 	ldr.w	r1, [r3, #2816]	; 0xb00
 800355c:	4a03      	ldr	r2, [pc, #12]	; (800356c <USB_DeactivateEndpoint+0xa8>)
 800355e:	400a      	ands	r2, r1
 8003560:	f8c3 2b00 	str.w	r2, [r3, #2816]	; 0xb00
 8003564:	e7da      	b.n	800351c <USB_DeactivateEndpoint+0x58>
 8003566:	bf00      	nop
 8003568:	ec337800 	.word	0xec337800
 800356c:	eff37800 	.word	0xeff37800

08003570 <USB_EP0StartXfer>:
  if (ep->is_in == 1U)
 8003570:	784b      	ldrb	r3, [r1, #1]
 8003572:	f8df c0f0 	ldr.w	ip, [pc, #240]	; 8003664 <USB_EP0StartXfer+0xf4>
{
 8003576:	b5f0      	push	{r4, r5, r6, r7, lr}
  uint32_t epnum = (uint32_t)ep->num;
 8003578:	780e      	ldrb	r6, [r1, #0]
    if (ep->xfer_len == 0U)
 800357a:	698d      	ldr	r5, [r1, #24]
 800357c:	4f38      	ldr	r7, [pc, #224]	; (8003660 <USB_EP0StartXfer+0xf0>)
  if (ep->is_in == 1U)
 800357e:	2b01      	cmp	r3, #1
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT);
 8003580:	eb00 1446 	add.w	r4, r0, r6, lsl #5
  if (ep->is_in == 1U)
 8003584:	d146      	bne.n	8003614 <USB_EP0StartXfer+0xa4>
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT);
 8003586:	f504 6310 	add.w	r3, r4, #2304	; 0x900
    if (ep->xfer_len == 0U)
 800358a:	b9bd      	cbnz	r5, 80035bc <USB_EP0StartXfer+0x4c>
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT);
 800358c:	691d      	ldr	r5, [r3, #16]
 800358e:	403d      	ands	r5, r7
 8003590:	611d      	str	r5, [r3, #16]
      USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (1U << 19));
 8003592:	691d      	ldr	r5, [r3, #16]
 8003594:	f445 2500 	orr.w	r5, r5, #524288	; 0x80000
 8003598:	611d      	str	r5, [r3, #16]
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ);
 800359a:	691d      	ldr	r5, [r3, #16]
 800359c:	ea05 050c 	and.w	r5, r5, ip
    if (dma == 1U)
 80035a0:	2a01      	cmp	r2, #1
      USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_XFRSIZ & ep->xfer_len);
 80035a2:	611d      	str	r5, [r3, #16]
    if (dma == 1U)
 80035a4:	d123      	bne.n	80035ee <USB_EP0StartXfer+0x7e>
      if ((uint32_t)ep->dma_addr != 0U)
 80035a6:	694a      	ldr	r2, [r1, #20]
 80035a8:	b102      	cbz	r2, 80035ac <USB_EP0StartXfer+0x3c>
        USBx_INEP(epnum)->DIEPDMA = (uint32_t)(ep->dma_addr);
 80035aa:	615a      	str	r2, [r3, #20]
      USBx_INEP(epnum)->DIEPCTL |= (USB_OTG_DIEPCTL_CNAK | USB_OTG_DIEPCTL_EPENA);
 80035ac:	f8d4 3900 	ldr.w	r3, [r4, #2304]	; 0x900
 80035b0:	f043 4304 	orr.w	r3, r3, #2214592512	; 0x84000000
 80035b4:	f8c4 3900 	str.w	r3, [r4, #2304]	; 0x900
}
 80035b8:	2000      	movs	r0, #0
 80035ba:	bdf0      	pop	{r4, r5, r6, r7, pc}
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ);
 80035bc:	f8d3 e010 	ldr.w	lr, [r3, #16]
 80035c0:	ea0e 0c0c 	and.w	ip, lr, ip
 80035c4:	f8c3 c010 	str.w	ip, [r3, #16]
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT);
 80035c8:	f8d3 c010 	ldr.w	ip, [r3, #16]
 80035cc:	ea0c 0707 	and.w	r7, ip, r7
 80035d0:	611f      	str	r7, [r3, #16]
      if (ep->xfer_len > ep->maxpacket)
 80035d2:	68cf      	ldr	r7, [r1, #12]
 80035d4:	42af      	cmp	r7, r5
      USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (1U << 19));
 80035d6:	691d      	ldr	r5, [r3, #16]
        ep->xfer_len = ep->maxpacket;
 80035d8:	bf38      	it	cc
 80035da:	618f      	strcc	r7, [r1, #24]
      USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (1U << 19));
 80035dc:	f445 2500 	orr.w	r5, r5, #524288	; 0x80000
 80035e0:	611d      	str	r5, [r3, #16]
      USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_XFRSIZ & ep->xfer_len);
 80035e2:	698d      	ldr	r5, [r1, #24]
 80035e4:	691f      	ldr	r7, [r3, #16]
 80035e6:	f3c5 0512 	ubfx	r5, r5, #0, #19
 80035ea:	433d      	orrs	r5, r7
 80035ec:	e7d8      	b.n	80035a0 <USB_EP0StartXfer+0x30>
      USBx_INEP(epnum)->DIEPCTL |= (USB_OTG_DIEPCTL_CNAK | USB_OTG_DIEPCTL_EPENA);
 80035ee:	f8d4 3900 	ldr.w	r3, [r4, #2304]	; 0x900
 80035f2:	f043 4304 	orr.w	r3, r3, #2214592512	; 0x84000000
 80035f6:	f8c4 3900 	str.w	r3, [r4, #2304]	; 0x900
      if (ep->xfer_len > 0U)
 80035fa:	698b      	ldr	r3, [r1, #24]
 80035fc:	2b00      	cmp	r3, #0
 80035fe:	d0db      	beq.n	80035b8 <USB_EP0StartXfer+0x48>
        USBx_DEVICE->DIEPEMPMSK |= 1UL << (ep->num & EP_ADDR_MSK);
 8003600:	f8d0 2834 	ldr.w	r2, [r0, #2100]	; 0x834
 8003604:	f006 060f 	and.w	r6, r6, #15
 8003608:	2301      	movs	r3, #1
 800360a:	40b3      	lsls	r3, r6
 800360c:	4313      	orrs	r3, r2
 800360e:	f8c0 3834 	str.w	r3, [r0, #2100]	; 0x834
 8003612:	e7d1      	b.n	80035b8 <USB_EP0StartXfer+0x48>
    USBx_OUTEP(epnum)->DOEPTSIZ &= ~(USB_OTG_DOEPTSIZ_XFRSIZ);
 8003614:	f8d4 0b10 	ldr.w	r0, [r4, #2832]	; 0xb10
 8003618:	ea00 000c 	and.w	r0, r0, ip
 800361c:	f8c4 0b10 	str.w	r0, [r4, #2832]	; 0xb10
    USBx_OUTEP(epnum)->DOEPTSIZ &= ~(USB_OTG_DOEPTSIZ_PKTCNT);
 8003620:	f8d4 0b10 	ldr.w	r0, [r4, #2832]	; 0xb10
 8003624:	4038      	ands	r0, r7
    USBx_OUTEP(epnum)->DOEPTSIZ &= ~(USB_OTG_DOEPTSIZ_XFRSIZ);
 8003626:	f504 6330 	add.w	r3, r4, #2816	; 0xb00
    USBx_OUTEP(epnum)->DOEPTSIZ &= ~(USB_OTG_DOEPTSIZ_PKTCNT);
 800362a:	6118      	str	r0, [r3, #16]
      if (ep->xfer_len > ep->maxpacket)
 800362c:	68c8      	ldr	r0, [r1, #12]
    if (ep->xfer_len > 0U)
 800362e:	b105      	cbz	r5, 8003632 <USB_EP0StartXfer+0xc2>
      ep->xfer_len = ep->maxpacket;
 8003630:	6188      	str	r0, [r1, #24]
    USBx_OUTEP(epnum)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (1U << 19));
 8003632:	691d      	ldr	r5, [r3, #16]
    ep->xfer_size = ep->maxpacket;
 8003634:	61c8      	str	r0, [r1, #28]
    USBx_OUTEP(epnum)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (1U << 19));
 8003636:	f445 2500 	orr.w	r5, r5, #524288	; 0x80000
 800363a:	611d      	str	r5, [r3, #16]
    USBx_OUTEP(epnum)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_XFRSIZ & ep->xfer_size);
 800363c:	691d      	ldr	r5, [r3, #16]
 800363e:	f3c0 0012 	ubfx	r0, r0, #0, #19
 8003642:	4328      	orrs	r0, r5
    if (dma == 1U)
 8003644:	2a01      	cmp	r2, #1
    USBx_OUTEP(epnum)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_XFRSIZ & ep->xfer_size);
 8003646:	6118      	str	r0, [r3, #16]
    if (dma == 1U)
 8003648:	d102      	bne.n	8003650 <USB_EP0StartXfer+0xe0>
      if ((uint32_t)ep->xfer_buff != 0U)
 800364a:	690a      	ldr	r2, [r1, #16]
 800364c:	b102      	cbz	r2, 8003650 <USB_EP0StartXfer+0xe0>
        USBx_OUTEP(epnum)->DOEPDMA = (uint32_t)(ep->xfer_buff);
 800364e:	615a      	str	r2, [r3, #20]
    USBx_OUTEP(epnum)->DOEPCTL |= (USB_OTG_DOEPCTL_CNAK | USB_OTG_DOEPCTL_EPENA);
 8003650:	f8d4 3b00 	ldr.w	r3, [r4, #2816]	; 0xb00
 8003654:	f043 4304 	orr.w	r3, r3, #2214592512	; 0x84000000
 8003658:	f8c4 3b00 	str.w	r3, [r4, #2816]	; 0xb00
 800365c:	e7ac      	b.n	80035b8 <USB_EP0StartXfer+0x48>
 800365e:	bf00      	nop
 8003660:	e007ffff 	.word	0xe007ffff
 8003664:	fff80000 	.word	0xfff80000

08003668 <USB_EPStopXfer>:
{
 8003668:	b082      	sub	sp, #8
  __IO uint32_t count = 0U;
 800366a:	2300      	movs	r3, #0
  if (ep->is_in == 1U)
 800366c:	784a      	ldrb	r2, [r1, #1]
  __IO uint32_t count = 0U;
 800366e:	9301      	str	r3, [sp, #4]
    if (((USBx_INEP(ep->num)->DIEPCTL) & USB_OTG_DIEPCTL_EPENA) == USB_OTG_DIEPCTL_EPENA)
 8003670:	780b      	ldrb	r3, [r1, #0]
  if (ep->is_in == 1U)
 8003672:	2a01      	cmp	r2, #1
    if (((USBx_INEP(ep->num)->DIEPCTL) & USB_OTG_DIEPCTL_EPENA) == USB_OTG_DIEPCTL_EPENA)
 8003674:	ea4f 1343 	mov.w	r3, r3, lsl #5
  if (ep->is_in == 1U)
 8003678:	d11e      	bne.n	80036b8 <USB_EPStopXfer+0x50>
    if (((USBx_INEP(ep->num)->DIEPCTL) & USB_OTG_DIEPCTL_EPENA) == USB_OTG_DIEPCTL_EPENA)
 800367a:	f500 6010 	add.w	r0, r0, #2304	; 0x900
 800367e:	18c1      	adds	r1, r0, r3
 8003680:	58c2      	ldr	r2, [r0, r3]
 8003682:	2a00      	cmp	r2, #0
 8003684:	db02      	blt.n	800368c <USB_EPStopXfer+0x24>
  HAL_StatusTypeDef ret = HAL_OK;
 8003686:	2000      	movs	r0, #0
}
 8003688:	b002      	add	sp, #8
 800368a:	4770      	bx	lr
      USBx_INEP(ep->num)->DIEPCTL |= (USB_OTG_DIEPCTL_SNAK);
 800368c:	58c2      	ldr	r2, [r0, r3]
 800368e:	f042 6200 	orr.w	r2, r2, #134217728	; 0x8000000
 8003692:	50c2      	str	r2, [r0, r3]
      USBx_INEP(ep->num)->DIEPCTL |= (USB_OTG_DIEPCTL_EPDIS);
 8003694:	58c2      	ldr	r2, [r0, r3]
 8003696:	f042 4280 	orr.w	r2, r2, #1073741824	; 0x40000000
 800369a:	50c2      	str	r2, [r0, r3]
        if (count > 10000U)
 800369c:	f242 7210 	movw	r2, #10000	; 0x2710
        count++;
 80036a0:	9b01      	ldr	r3, [sp, #4]
 80036a2:	3301      	adds	r3, #1
 80036a4:	9301      	str	r3, [sp, #4]
        if (count > 10000U)
 80036a6:	9b01      	ldr	r3, [sp, #4]
 80036a8:	4293      	cmp	r3, r2
 80036aa:	d901      	bls.n	80036b0 <USB_EPStopXfer+0x48>
          ret = HAL_ERROR;
 80036ac:	2001      	movs	r0, #1
 80036ae:	e7eb      	b.n	8003688 <USB_EPStopXfer+0x20>
      } while (((USBx_INEP(ep->num)->DIEPCTL) & USB_OTG_DIEPCTL_EPENA) ==  USB_OTG_DIEPCTL_EPENA);
 80036b0:	680b      	ldr	r3, [r1, #0]
 80036b2:	2b00      	cmp	r3, #0
 80036b4:	dbf4      	blt.n	80036a0 <USB_EPStopXfer+0x38>
 80036b6:	e7e6      	b.n	8003686 <USB_EPStopXfer+0x1e>
    if (((USBx_OUTEP(ep->num)->DOEPCTL) & USB_OTG_DOEPCTL_EPENA) == USB_OTG_DOEPCTL_EPENA)
 80036b8:	f500 6030 	add.w	r0, r0, #2816	; 0xb00
 80036bc:	18c1      	adds	r1, r0, r3
 80036be:	58c2      	ldr	r2, [r0, r3]
 80036c0:	2a00      	cmp	r2, #0
 80036c2:	dae0      	bge.n	8003686 <USB_EPStopXfer+0x1e>
      USBx_OUTEP(ep->num)->DOEPCTL |= (USB_OTG_DOEPCTL_SNAK);
 80036c4:	58c2      	ldr	r2, [r0, r3]
 80036c6:	f042 6200 	orr.w	r2, r2, #134217728	; 0x8000000
 80036ca:	50c2      	str	r2, [r0, r3]
      USBx_OUTEP(ep->num)->DOEPCTL |= (USB_OTG_DOEPCTL_EPDIS);
 80036cc:	58c2      	ldr	r2, [r0, r3]
 80036ce:	f042 4280 	orr.w	r2, r2, #1073741824	; 0x40000000
 80036d2:	50c2      	str	r2, [r0, r3]
        if (count > 10000U)
 80036d4:	f242 7210 	movw	r2, #10000	; 0x2710
        count++;
 80036d8:	9b01      	ldr	r3, [sp, #4]
 80036da:	3301      	adds	r3, #1
 80036dc:	9301      	str	r3, [sp, #4]
        if (count > 10000U)
 80036de:	9b01      	ldr	r3, [sp, #4]
 80036e0:	4293      	cmp	r3, r2
 80036e2:	d8e3      	bhi.n	80036ac <USB_EPStopXfer+0x44>
      } while (((USBx_OUTEP(ep->num)->DOEPCTL) & USB_OTG_DOEPCTL_EPENA) ==  USB_OTG_DOEPCTL_EPENA);
 80036e4:	680b      	ldr	r3, [r1, #0]
 80036e6:	2b00      	cmp	r3, #0
 80036e8:	dbf6      	blt.n	80036d8 <USB_EPStopXfer+0x70>
 80036ea:	e7cc      	b.n	8003686 <USB_EPStopXfer+0x1e>

080036ec <USB_WritePacket>:
{
 80036ec:	b510      	push	{r4, lr}
 80036ee:	f89d 4008 	ldrb.w	r4, [sp, #8]
  if (dma == 0U)
 80036f2:	b944      	cbnz	r4, 8003706 <USB_WritePacket+0x1a>
    count32b = ((uint32_t)len + 3U) / 4U;
 80036f4:	3303      	adds	r3, #3
      USBx_DFIFO((uint32_t)ch_ep_num) = __UNALIGNED_UINT32_READ(pSrc);
 80036f6:	3201      	adds	r2, #1
    count32b = ((uint32_t)len + 3U) / 4U;
 80036f8:	089b      	lsrs	r3, r3, #2
      USBx_DFIFO((uint32_t)ch_ep_num) = __UNALIGNED_UINT32_READ(pSrc);
 80036fa:	eb00 3002 	add.w	r0, r0, r2, lsl #12
 80036fe:	eb01 0383 	add.w	r3, r1, r3, lsl #2
    for (i = 0U; i < count32b; i++)
 8003702:	428b      	cmp	r3, r1
 8003704:	d101      	bne.n	800370a <USB_WritePacket+0x1e>
}
 8003706:	2000      	movs	r0, #0
 8003708:	bd10      	pop	{r4, pc}
      USBx_DFIFO((uint32_t)ch_ep_num) = __UNALIGNED_UINT32_READ(pSrc);
 800370a:	f851 2b04 	ldr.w	r2, [r1], #4
 800370e:	6002      	str	r2, [r0, #0]
    for (i = 0U; i < count32b; i++)
 8003710:	e7f7      	b.n	8003702 <USB_WritePacket+0x16>
	...

08003714 <USB_EPStartXfer>:
{
 8003714:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
  if (ep->is_in == 1U)
 8003718:	784d      	ldrb	r5, [r1, #1]
    if (ep->xfer_len == 0U)
 800371a:	698b      	ldr	r3, [r1, #24]
      if (ep->type == EP_TYPE_ISOC)
 800371c:	790f      	ldrb	r7, [r1, #4]
 800371e:	f8df c1bc 	ldr.w	ip, [pc, #444]	; 80038dc <USB_EPStartXfer+0x1c8>
 8003722:	f8df e1bc 	ldr.w	lr, [pc, #444]	; 80038e0 <USB_EPStartXfer+0x1cc>
{
 8003726:	4616      	mov	r6, r2
  uint32_t epnum = (uint32_t)ep->num;
 8003728:	780a      	ldrb	r2, [r1, #0]
  if (ep->is_in == 1U)
 800372a:	2d01      	cmp	r5, #1
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT);
 800372c:	eb00 1442 	add.w	r4, r0, r2, lsl #5
  if (ep->is_in == 1U)
 8003730:	f040 808b 	bne.w	800384a <USB_EPStartXfer+0x136>
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT);
 8003734:	f504 6510 	add.w	r5, r4, #2304	; 0x900
 8003738:	f8d5 8010 	ldr.w	r8, [r5, #16]
    if (ep->xfer_len == 0U)
 800373c:	bb6b      	cbnz	r3, 800379a <USB_EPStartXfer+0x86>
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT);
 800373e:	ea08 0c0c 	and.w	ip, r8, ip
 8003742:	f8c5 c010 	str.w	ip, [r5, #16]
      USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (1U << 19));
 8003746:	f8d5 c010 	ldr.w	ip, [r5, #16]
 800374a:	f44c 2c00 	orr.w	ip, ip, #524288	; 0x80000
 800374e:	f8c5 c010 	str.w	ip, [r5, #16]
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ);
 8003752:	f8d5 c010 	ldr.w	ip, [r5, #16]
 8003756:	ea0c 0c0e 	and.w	ip, ip, lr
        USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_MULCNT & (1U << 29));
 800375a:	f8c5 c010 	str.w	ip, [r5, #16]
    if (dma == 1U)
 800375e:	2e01      	cmp	r6, #1
 8003760:	d14c      	bne.n	80037fc <USB_EPStartXfer+0xe8>
      if ((uint32_t)ep->dma_addr != 0U)
 8003762:	694b      	ldr	r3, [r1, #20]
 8003764:	b103      	cbz	r3, 8003768 <USB_EPStartXfer+0x54>
        USBx_INEP(epnum)->DIEPDMA = (uint32_t)(ep->dma_addr);
 8003766:	616b      	str	r3, [r5, #20]
      if (ep->type == EP_TYPE_ISOC)
 8003768:	2f01      	cmp	r7, #1
 800376a:	d10c      	bne.n	8003786 <USB_EPStartXfer+0x72>
        if ((USBx_DEVICE->DSTS & (1U << 8)) == 0U)
 800376c:	f8d0 3808 	ldr.w	r3, [r0, #2056]	; 0x808
 8003770:	f413 7f80 	tst.w	r3, #256	; 0x100
          USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_SODDFRM;
 8003774:	f8d4 3900 	ldr.w	r3, [r4, #2304]	; 0x900
 8003778:	bf0c      	ite	eq
 800377a:	f043 5300 	orreq.w	r3, r3, #536870912	; 0x20000000
          USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_SD0PID_SEVNFRM;
 800377e:	f043 5380 	orrne.w	r3, r3, #268435456	; 0x10000000
 8003782:	f8c4 3900 	str.w	r3, [r4, #2304]	; 0x900
      USBx_INEP(epnum)->DIEPCTL |= (USB_OTG_DIEPCTL_CNAK | USB_OTG_DIEPCTL_EPENA);
 8003786:	f8d4 3900 	ldr.w	r3, [r4, #2304]	; 0x900
 800378a:	f043 4304 	orr.w	r3, r3, #2214592512	; 0x84000000
 800378e:	f8c4 3900 	str.w	r3, [r4, #2304]	; 0x900
}
 8003792:	2000      	movs	r0, #0
 8003794:	b002      	add	sp, #8
 8003796:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ);
 800379a:	ea08 0e0e 	and.w	lr, r8, lr
 800379e:	f8c5 e010 	str.w	lr, [r5, #16]
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT);
 80037a2:	f8d5 e010 	ldr.w	lr, [r5, #16]
 80037a6:	ea0e 0c0c 	and.w	ip, lr, ip
 80037aa:	f8c5 c010 	str.w	ip, [r5, #16]
                                     (((ep->xfer_len + ep->maxpacket - 1U) / ep->maxpacket) << 19));
 80037ae:	f8d1 c00c 	ldr.w	ip, [r1, #12]
      USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT &
 80037b2:	f8d5 8010 	ldr.w	r8, [r5, #16]
                                     (((ep->xfer_len + ep->maxpacket - 1U) / ep->maxpacket) << 19));
 80037b6:	eb0c 0e03 	add.w	lr, ip, r3
 80037ba:	f10e 3eff 	add.w	lr, lr, #4294967295
 80037be:	fbbe fefc 	udiv	lr, lr, ip
      USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT &
 80037c2:	f8df c120 	ldr.w	ip, [pc, #288]	; 80038e4 <USB_EPStartXfer+0x1d0>
 80037c6:	ea0c 4cce 	and.w	ip, ip, lr, lsl #19
 80037ca:	ea4c 0c08 	orr.w	ip, ip, r8
 80037ce:	f8c5 c010 	str.w	ip, [r5, #16]
      USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_XFRSIZ & ep->xfer_len);
 80037d2:	f8d5 e010 	ldr.w	lr, [r5, #16]
 80037d6:	f3c3 0c12 	ubfx	ip, r3, #0, #19
 80037da:	ea4c 0c0e 	orr.w	ip, ip, lr
      if (ep->type == EP_TYPE_ISOC)
 80037de:	2f01      	cmp	r7, #1
      USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_XFRSIZ & ep->xfer_len);
 80037e0:	f8c5 c010 	str.w	ip, [r5, #16]
      if (ep->type == EP_TYPE_ISOC)
 80037e4:	d1bb      	bne.n	800375e <USB_EPStartXfer+0x4a>
        USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_MULCNT);
 80037e6:	f8d5 c010 	ldr.w	ip, [r5, #16]
 80037ea:	f02c 4cc0 	bic.w	ip, ip, #1610612736	; 0x60000000
 80037ee:	f8c5 c010 	str.w	ip, [r5, #16]
        USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_MULCNT & (1U << 29));
 80037f2:	f8d5 c010 	ldr.w	ip, [r5, #16]
 80037f6:	f04c 5c00 	orr.w	ip, ip, #536870912	; 0x20000000
 80037fa:	e7ae      	b.n	800375a <USB_EPStartXfer+0x46>
      USBx_INEP(epnum)->DIEPCTL |= (USB_OTG_DIEPCTL_CNAK | USB_OTG_DIEPCTL_EPENA);
 80037fc:	f8d4 5900 	ldr.w	r5, [r4, #2304]	; 0x900
      if (ep->type != EP_TYPE_ISOC)
 8003800:	2f01      	cmp	r7, #1
      USBx_INEP(epnum)->DIEPCTL |= (USB_OTG_DIEPCTL_CNAK | USB_OTG_DIEPCTL_EPENA);
 8003802:	f045 4504 	orr.w	r5, r5, #2214592512	; 0x84000000
 8003806:	f8c4 5900 	str.w	r5, [r4, #2304]	; 0x900
      if (ep->type != EP_TYPE_ISOC)
 800380a:	d00b      	beq.n	8003824 <USB_EPStartXfer+0x110>
        if (ep->xfer_len > 0U)
 800380c:	2b00      	cmp	r3, #0
 800380e:	d0c0      	beq.n	8003792 <USB_EPStartXfer+0x7e>
          USBx_DEVICE->DIEPEMPMSK |= 1UL << (ep->num & EP_ADDR_MSK);
 8003810:	f8d0 1834 	ldr.w	r1, [r0, #2100]	; 0x834
 8003814:	f002 020f 	and.w	r2, r2, #15
 8003818:	2301      	movs	r3, #1
 800381a:	4093      	lsls	r3, r2
 800381c:	430b      	orrs	r3, r1
 800381e:	f8c0 3834 	str.w	r3, [r0, #2100]	; 0x834
 8003822:	e7b6      	b.n	8003792 <USB_EPStartXfer+0x7e>
        if ((USBx_DEVICE->DSTS & (1U << 8)) == 0U)
 8003824:	f8d0 5808 	ldr.w	r5, [r0, #2056]	; 0x808
 8003828:	f415 7f80 	tst.w	r5, #256	; 0x100
          USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_SODDFRM;
 800382c:	f8d4 5900 	ldr.w	r5, [r4, #2304]	; 0x900
 8003830:	bf0c      	ite	eq
 8003832:	f045 5500 	orreq.w	r5, r5, #536870912	; 0x20000000
          USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_SD0PID_SEVNFRM;
 8003836:	f045 5580 	orrne.w	r5, r5, #268435456	; 0x10000000
 800383a:	f8c4 5900 	str.w	r5, [r4, #2304]	; 0x900
        (void)USB_WritePacket(USBx, ep->xfer_buff, ep->num, (uint16_t)ep->xfer_len, dma);
 800383e:	9600      	str	r6, [sp, #0]
 8003840:	6909      	ldr	r1, [r1, #16]
 8003842:	b29b      	uxth	r3, r3
 8003844:	f7ff ff52 	bl	80036ec <USB_WritePacket>
 8003848:	e7a3      	b.n	8003792 <USB_EPStartXfer+0x7e>
    USBx_OUTEP(epnum)->DOEPTSIZ &= ~(USB_OTG_DOEPTSIZ_XFRSIZ);
 800384a:	f8d4 5b10 	ldr.w	r5, [r4, #2832]	; 0xb10
 800384e:	ea05 050e 	and.w	r5, r5, lr
 8003852:	f8c4 5b10 	str.w	r5, [r4, #2832]	; 0xb10
    USBx_OUTEP(epnum)->DOEPTSIZ &= ~(USB_OTG_DOEPTSIZ_PKTCNT);
 8003856:	f8d4 5b10 	ldr.w	r5, [r4, #2832]	; 0xb10
 800385a:	ea05 050c 	and.w	r5, r5, ip
    USBx_OUTEP(epnum)->DOEPTSIZ &= ~(USB_OTG_DOEPTSIZ_XFRSIZ);
 800385e:	f504 6230 	add.w	r2, r4, #2816	; 0xb00
    USBx_OUTEP(epnum)->DOEPTSIZ &= ~(USB_OTG_DOEPTSIZ_PKTCNT);
 8003862:	6115      	str	r5, [r2, #16]
                                     (((ep->xfer_len + ep->maxpacket - 1U) / ep->maxpacket) << 19));
 8003864:	68cd      	ldr	r5, [r1, #12]
    if (ep->xfer_len == 0U)
 8003866:	bb1b      	cbnz	r3, 80038b0 <USB_EPStartXfer+0x19c>
      USBx_OUTEP(epnum)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_XFRSIZ & ep->maxpacket);
 8003868:	6913      	ldr	r3, [r2, #16]
 800386a:	f3c5 0512 	ubfx	r5, r5, #0, #19
 800386e:	431d      	orrs	r5, r3
 8003870:	6115      	str	r5, [r2, #16]
      USBx_OUTEP(epnum)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (1U << 19));
 8003872:	6913      	ldr	r3, [r2, #16]
 8003874:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
 8003878:	6113      	str	r3, [r2, #16]
    if (dma == 1U)
 800387a:	2e01      	cmp	r6, #1
 800387c:	d102      	bne.n	8003884 <USB_EPStartXfer+0x170>
      if ((uint32_t)ep->xfer_buff != 0U)
 800387e:	690b      	ldr	r3, [r1, #16]
 8003880:	b103      	cbz	r3, 8003884 <USB_EPStartXfer+0x170>
        USBx_OUTEP(epnum)->DOEPDMA = (uint32_t)(ep->xfer_buff);
 8003882:	6153      	str	r3, [r2, #20]
    if (ep->type == EP_TYPE_ISOC)
 8003884:	2f01      	cmp	r7, #1
 8003886:	d10c      	bne.n	80038a2 <USB_EPStartXfer+0x18e>
      if ((USBx_DEVICE->DSTS & (1U << 8)) == 0U)
 8003888:	f8d0 3808 	ldr.w	r3, [r0, #2056]	; 0x808
 800388c:	f413 7f80 	tst.w	r3, #256	; 0x100
        USBx_OUTEP(epnum)->DOEPCTL |= USB_OTG_DOEPCTL_SODDFRM;
 8003890:	f8d4 3b00 	ldr.w	r3, [r4, #2816]	; 0xb00
 8003894:	bf0c      	ite	eq
 8003896:	f043 5300 	orreq.w	r3, r3, #536870912	; 0x20000000
        USBx_OUTEP(epnum)->DOEPCTL |= USB_OTG_DOEPCTL_SD0PID_SEVNFRM;
 800389a:	f043 5380 	orrne.w	r3, r3, #268435456	; 0x10000000
 800389e:	f8c4 3b00 	str.w	r3, [r4, #2816]	; 0xb00
    USBx_OUTEP(epnum)->DOEPCTL |= (USB_OTG_DOEPCTL_CNAK | USB_OTG_DOEPCTL_EPENA);
 80038a2:	f8d4 3b00 	ldr.w	r3, [r4, #2816]	; 0xb00
 80038a6:	f043 4304 	orr.w	r3, r3, #2214592512	; 0x84000000
 80038aa:	f8c4 3b00 	str.w	r3, [r4, #2816]	; 0xb00
 80038ae:	e770      	b.n	8003792 <USB_EPStartXfer+0x7e>
      pktcnt = (uint16_t)((ep->xfer_len + ep->maxpacket - 1U) / ep->maxpacket);
 80038b0:	442b      	add	r3, r5
      USBx_OUTEP(epnum)->DOEPTSIZ |= USB_OTG_DOEPTSIZ_PKTCNT & ((uint32_t)pktcnt << 19);
 80038b2:	f8df c030 	ldr.w	ip, [pc, #48]	; 80038e4 <USB_EPStartXfer+0x1d0>
 80038b6:	f8d2 e010 	ldr.w	lr, [r2, #16]
      pktcnt = (uint16_t)((ep->xfer_len + ep->maxpacket - 1U) / ep->maxpacket);
 80038ba:	3b01      	subs	r3, #1
 80038bc:	fbb3 f3f5 	udiv	r3, r3, r5
 80038c0:	b29b      	uxth	r3, r3
      ep->xfer_size = ep->maxpacket * pktcnt;
 80038c2:	435d      	muls	r5, r3
      USBx_OUTEP(epnum)->DOEPTSIZ |= USB_OTG_DOEPTSIZ_PKTCNT & ((uint32_t)pktcnt << 19);
 80038c4:	ea0c 43c3 	and.w	r3, ip, r3, lsl #19
 80038c8:	ea43 030e 	orr.w	r3, r3, lr
      ep->xfer_size = ep->maxpacket * pktcnt;
 80038cc:	61cd      	str	r5, [r1, #28]
      USBx_OUTEP(epnum)->DOEPTSIZ |= USB_OTG_DOEPTSIZ_PKTCNT & ((uint32_t)pktcnt << 19);
 80038ce:	6113      	str	r3, [r2, #16]
      USBx_OUTEP(epnum)->DOEPTSIZ |= USB_OTG_DOEPTSIZ_XFRSIZ & ep->xfer_size;
 80038d0:	6913      	ldr	r3, [r2, #16]
 80038d2:	f3c5 0512 	ubfx	r5, r5, #0, #19
 80038d6:	431d      	orrs	r5, r3
 80038d8:	6115      	str	r5, [r2, #16]
 80038da:	e7ce      	b.n	800387a <USB_EPStartXfer+0x166>
 80038dc:	e007ffff 	.word	0xe007ffff
 80038e0:	fff80000 	.word	0xfff80000
 80038e4:	1ff80000 	.word	0x1ff80000

080038e8 <USB_ReadPacket>:
{
 80038e8:	b570      	push	{r4, r5, r6, lr}
  for (i = 0U; i < count32b; i++)
 80038ea:	2300      	movs	r3, #0
  uint32_t count32b = (uint32_t)len >> 2U;
 80038ec:	0894      	lsrs	r4, r2, #2
    __UNALIGNED_UINT32_WRITE(pDest, USBx_DFIFO(0U));
 80038ee:	f500 5580 	add.w	r5, r0, #4096	; 0x1000
  uint16_t remaining_bytes = len % 4U;
 80038f2:	f002 0203 	and.w	r2, r2, #3
  for (i = 0U; i < count32b; i++)
 80038f6:	42a3      	cmp	r3, r4
 80038f8:	d311      	bcc.n	800391e <USB_ReadPacket+0x36>
 80038fa:	eb01 0184 	add.w	r1, r1, r4, lsl #2
  if (remaining_bytes != 0U)
 80038fe:	b162      	cbz	r2, 800391a <USB_ReadPacket+0x32>
    __UNALIGNED_UINT32_WRITE(&pData, USBx_DFIFO(0U));
 8003900:	f500 5080 	add.w	r0, r0, #4096	; 0x1000
    i = 0U;
 8003904:	2300      	movs	r3, #0
    __UNALIGNED_UINT32_WRITE(&pData, USBx_DFIFO(0U));
 8003906:	6804      	ldr	r4, [r0, #0]
      *(uint8_t *)pDest = (uint8_t)(pData >> (8U * (uint8_t)(i)));
 8003908:	00d8      	lsls	r0, r3, #3
 800390a:	fa24 f000 	lsr.w	r0, r4, r0
 800390e:	54c8      	strb	r0, [r1, r3]
      i++;
 8003910:	3301      	adds	r3, #1
    } while (remaining_bytes != 0U);
 8003912:	b298      	uxth	r0, r3
 8003914:	4282      	cmp	r2, r0
 8003916:	d1f7      	bne.n	8003908 <USB_ReadPacket+0x20>
      pDest++;
 8003918:	4411      	add	r1, r2
}
 800391a:	4608      	mov	r0, r1
 800391c:	bd70      	pop	{r4, r5, r6, pc}
    __UNALIGNED_UINT32_WRITE(pDest, USBx_DFIFO(0U));
 800391e:	682e      	ldr	r6, [r5, #0]
 8003920:	f841 6023 	str.w	r6, [r1, r3, lsl #2]
  for (i = 0U; i < count32b; i++)
 8003924:	3301      	adds	r3, #1
 8003926:	e7e6      	b.n	80038f6 <USB_ReadPacket+0xe>

08003928 <USB_EPSetStall>:
  if (ep->is_in == 1U)
 8003928:	784a      	ldrb	r2, [r1, #1]
  uint32_t epnum = (uint32_t)ep->num;
 800392a:	780b      	ldrb	r3, [r1, #0]
  if (ep->is_in == 1U)
 800392c:	2a01      	cmp	r2, #1
    if (((USBx_INEP(epnum)->DIEPCTL & USB_OTG_DIEPCTL_EPENA) == 0U) && (epnum != 0U))
 800392e:	eb00 1043 	add.w	r0, r0, r3, lsl #5
  if (ep->is_in == 1U)
 8003932:	d112      	bne.n	800395a <USB_EPSetStall+0x32>
    if (((USBx_INEP(epnum)->DIEPCTL & USB_OTG_DIEPCTL_EPENA) == 0U) && (epnum != 0U))
 8003934:	f8d0 2900 	ldr.w	r2, [r0, #2304]	; 0x900
 8003938:	2a00      	cmp	r2, #0
 800393a:	db06      	blt.n	800394a <USB_EPSetStall+0x22>
 800393c:	b12b      	cbz	r3, 800394a <USB_EPSetStall+0x22>
      USBx_INEP(epnum)->DIEPCTL &= ~(USB_OTG_DIEPCTL_EPDIS);
 800393e:	f8d0 3900 	ldr.w	r3, [r0, #2304]	; 0x900
 8003942:	f023 4380 	bic.w	r3, r3, #1073741824	; 0x40000000
 8003946:	f8c0 3900 	str.w	r3, [r0, #2304]	; 0x900
    USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_STALL;
 800394a:	f8d0 3900 	ldr.w	r3, [r0, #2304]	; 0x900
 800394e:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 8003952:	f8c0 3900 	str.w	r3, [r0, #2304]	; 0x900
}
 8003956:	2000      	movs	r0, #0
 8003958:	4770      	bx	lr
    if (((USBx_OUTEP(epnum)->DOEPCTL & USB_OTG_DOEPCTL_EPENA) == 0U) && (epnum != 0U))
 800395a:	f8d0 2b00 	ldr.w	r2, [r0, #2816]	; 0xb00
 800395e:	2a00      	cmp	r2, #0
 8003960:	db06      	blt.n	8003970 <USB_EPSetStall+0x48>
 8003962:	b12b      	cbz	r3, 8003970 <USB_EPSetStall+0x48>
      USBx_OUTEP(epnum)->DOEPCTL &= ~(USB_OTG_DOEPCTL_EPDIS);
 8003964:	f8d0 3b00 	ldr.w	r3, [r0, #2816]	; 0xb00
 8003968:	f023 4380 	bic.w	r3, r3, #1073741824	; 0x40000000
 800396c:	f8c0 3b00 	str.w	r3, [r0, #2816]	; 0xb00
    USBx_OUTEP(epnum)->DOEPCTL |= USB_OTG_DOEPCTL_STALL;
 8003970:	f8d0 3b00 	ldr.w	r3, [r0, #2816]	; 0xb00
 8003974:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 8003978:	f8c0 3b00 	str.w	r3, [r0, #2816]	; 0xb00
 800397c:	e7eb      	b.n	8003956 <USB_EPSetStall+0x2e>

0800397e <USB_EPClearStall>:
    USBx_INEP(epnum)->DIEPCTL &= ~USB_OTG_DIEPCTL_STALL;
 800397e:	780b      	ldrb	r3, [r1, #0]
  if (ep->is_in == 1U)
 8003980:	784a      	ldrb	r2, [r1, #1]
    USBx_INEP(epnum)->DIEPCTL &= ~USB_OTG_DIEPCTL_STALL;
 8003982:	eb00 1043 	add.w	r0, r0, r3, lsl #5
    if ((ep->type == EP_TYPE_INTR) || (ep->type == EP_TYPE_BULK))
 8003986:	790b      	ldrb	r3, [r1, #4]
  if (ep->is_in == 1U)
 8003988:	2a01      	cmp	r2, #1
    if ((ep->type == EP_TYPE_INTR) || (ep->type == EP_TYPE_BULK))
 800398a:	f1a3 0302 	sub.w	r3, r3, #2
 800398e:	b2db      	uxtb	r3, r3
  if (ep->is_in == 1U)
 8003990:	d10f      	bne.n	80039b2 <USB_EPClearStall+0x34>
    USBx_INEP(epnum)->DIEPCTL &= ~USB_OTG_DIEPCTL_STALL;
 8003992:	f8d0 2900 	ldr.w	r2, [r0, #2304]	; 0x900
    if ((ep->type == EP_TYPE_INTR) || (ep->type == EP_TYPE_BULK))
 8003996:	2b01      	cmp	r3, #1
    USBx_INEP(epnum)->DIEPCTL &= ~USB_OTG_DIEPCTL_STALL;
 8003998:	f422 1200 	bic.w	r2, r2, #2097152	; 0x200000
 800399c:	f8c0 2900 	str.w	r2, [r0, #2304]	; 0x900
    if ((ep->type == EP_TYPE_INTR) || (ep->type == EP_TYPE_BULK))
 80039a0:	d805      	bhi.n	80039ae <USB_EPClearStall+0x30>
      USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_SD0PID_SEVNFRM; /* DATA0 */
 80039a2:	f8d0 3900 	ldr.w	r3, [r0, #2304]	; 0x900
 80039a6:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 80039aa:	f8c0 3900 	str.w	r3, [r0, #2304]	; 0x900
}
 80039ae:	2000      	movs	r0, #0
 80039b0:	4770      	bx	lr
    USBx_OUTEP(epnum)->DOEPCTL &= ~USB_OTG_DOEPCTL_STALL;
 80039b2:	f8d0 2b00 	ldr.w	r2, [r0, #2816]	; 0xb00
 80039b6:	f422 1200 	bic.w	r2, r2, #2097152	; 0x200000
    if ((ep->type == EP_TYPE_INTR) || (ep->type == EP_TYPE_BULK))
 80039ba:	2b01      	cmp	r3, #1
    USBx_OUTEP(epnum)->DOEPCTL &= ~USB_OTG_DOEPCTL_STALL;
 80039bc:	f8c0 2b00 	str.w	r2, [r0, #2816]	; 0xb00
      USBx_OUTEP(epnum)->DOEPCTL |= USB_OTG_DOEPCTL_SD0PID_SEVNFRM; /* DATA0 */
 80039c0:	bf9e      	ittt	ls
 80039c2:	f8d0 3b00 	ldrls.w	r3, [r0, #2816]	; 0xb00
 80039c6:	f043 5380 	orrls.w	r3, r3, #268435456	; 0x10000000
 80039ca:	f8c0 3b00 	strls.w	r3, [r0, #2816]	; 0xb00
 80039ce:	e7ee      	b.n	80039ae <USB_EPClearStall+0x30>

080039d0 <USB_SetDevAddress>:
  USBx_DEVICE->DCFG &= ~(USB_OTG_DCFG_DAD);
 80039d0:	f8d0 3800 	ldr.w	r3, [r0, #2048]	; 0x800
 80039d4:	f423 63fe 	bic.w	r3, r3, #2032	; 0x7f0
 80039d8:	f8c0 3800 	str.w	r3, [r0, #2048]	; 0x800
  USBx_DEVICE->DCFG |= ((uint32_t)address << 4) & USB_OTG_DCFG_DAD;
 80039dc:	f8d0 3800 	ldr.w	r3, [r0, #2048]	; 0x800
 80039e0:	0109      	lsls	r1, r1, #4
 80039e2:	f401 61fe 	and.w	r1, r1, #2032	; 0x7f0
 80039e6:	4319      	orrs	r1, r3
 80039e8:	f8c0 1800 	str.w	r1, [r0, #2048]	; 0x800
}
 80039ec:	2000      	movs	r0, #0
 80039ee:	4770      	bx	lr

080039f0 <USB_DevConnect>:
  USBx_PCGCCTL &= ~(USB_OTG_PCGCCTL_STOPCLK | USB_OTG_PCGCCTL_GATECLK);
 80039f0:	f8d0 3e00 	ldr.w	r3, [r0, #3584]	; 0xe00
 80039f4:	f023 0303 	bic.w	r3, r3, #3
 80039f8:	f8c0 3e00 	str.w	r3, [r0, #3584]	; 0xe00
  USBx_DEVICE->DCTL &= ~USB_OTG_DCTL_SDIS;
 80039fc:	f8d0 3804 	ldr.w	r3, [r0, #2052]	; 0x804
 8003a00:	f023 0302 	bic.w	r3, r3, #2
 8003a04:	f8c0 3804 	str.w	r3, [r0, #2052]	; 0x804
}
 8003a08:	2000      	movs	r0, #0
 8003a0a:	4770      	bx	lr

08003a0c <USB_DevDisconnect>:
  USBx_PCGCCTL &= ~(USB_OTG_PCGCCTL_STOPCLK | USB_OTG_PCGCCTL_GATECLK);
 8003a0c:	f8d0 3e00 	ldr.w	r3, [r0, #3584]	; 0xe00
 8003a10:	f023 0303 	bic.w	r3, r3, #3
 8003a14:	f8c0 3e00 	str.w	r3, [r0, #3584]	; 0xe00
  USBx_DEVICE->DCTL |= USB_OTG_DCTL_SDIS;
 8003a18:	f8d0 3804 	ldr.w	r3, [r0, #2052]	; 0x804
 8003a1c:	f043 0302 	orr.w	r3, r3, #2
 8003a20:	f8c0 3804 	str.w	r3, [r0, #2052]	; 0x804
}
 8003a24:	2000      	movs	r0, #0
 8003a26:	4770      	bx	lr

08003a28 <USB_ReadInterrupts>:
  tmpreg = USBx->GINTSTS;
 8003a28:	6942      	ldr	r2, [r0, #20]
  tmpreg &= USBx->GINTMSK;
 8003a2a:	6980      	ldr	r0, [r0, #24]
}
 8003a2c:	4010      	ands	r0, r2
 8003a2e:	4770      	bx	lr

08003a30 <USB_ReadDevAllOutEpInterrupt>:
  tmpreg  = USBx_DEVICE->DAINT;
 8003a30:	f8d0 3818 	ldr.w	r3, [r0, #2072]	; 0x818
 8003a34:	f500 6000 	add.w	r0, r0, #2048	; 0x800
  tmpreg &= USBx_DEVICE->DAINTMSK;
 8003a38:	69c0      	ldr	r0, [r0, #28]
 8003a3a:	4018      	ands	r0, r3
}
 8003a3c:	0c00      	lsrs	r0, r0, #16
 8003a3e:	4770      	bx	lr

08003a40 <USB_ReadDevAllInEpInterrupt>:
  tmpreg  = USBx_DEVICE->DAINT;
 8003a40:	f8d0 3818 	ldr.w	r3, [r0, #2072]	; 0x818
 8003a44:	f500 6000 	add.w	r0, r0, #2048	; 0x800
  tmpreg &= USBx_DEVICE->DAINTMSK;
 8003a48:	69c0      	ldr	r0, [r0, #28]
 8003a4a:	4018      	ands	r0, r3
}
 8003a4c:	b280      	uxth	r0, r0
 8003a4e:	4770      	bx	lr

08003a50 <USB_ReadDevOutEPInterrupt>:
  tmpreg  = USBx_OUTEP((uint32_t)epnum)->DOEPINT;
 8003a50:	eb00 1141 	add.w	r1, r0, r1, lsl #5
  tmpreg &= USBx_DEVICE->DOEPMSK;
 8003a54:	f500 6000 	add.w	r0, r0, #2048	; 0x800
  tmpreg  = USBx_OUTEP((uint32_t)epnum)->DOEPINT;
 8003a58:	f8d1 2b08 	ldr.w	r2, [r1, #2824]	; 0xb08
  tmpreg &= USBx_DEVICE->DOEPMSK;
 8003a5c:	6940      	ldr	r0, [r0, #20]
}
 8003a5e:	4010      	ands	r0, r2
 8003a60:	4770      	bx	lr

08003a62 <USB_ReadDevInEPInterrupt>:
  msk = USBx_DEVICE->DIEPMSK;
 8003a62:	f8d0 2810 	ldr.w	r2, [r0, #2064]	; 0x810
  emp = USBx_DEVICE->DIEPEMPMSK;
 8003a66:	f8d0 3834 	ldr.w	r3, [r0, #2100]	; 0x834
  tmpreg = USBx_INEP((uint32_t)epnum)->DIEPINT & msk;
 8003a6a:	eb00 1041 	add.w	r0, r0, r1, lsl #5
  msk |= ((emp >> (epnum & EP_ADDR_MSK)) & 0x1U) << 7;
 8003a6e:	f001 010f 	and.w	r1, r1, #15
 8003a72:	40cb      	lsrs	r3, r1
  tmpreg = USBx_INEP((uint32_t)epnum)->DIEPINT & msk;
 8003a74:	f500 6010 	add.w	r0, r0, #2304	; 0x900
  msk |= ((emp >> (epnum & EP_ADDR_MSK)) & 0x1U) << 7;
 8003a78:	01db      	lsls	r3, r3, #7
  tmpreg = USBx_INEP((uint32_t)epnum)->DIEPINT & msk;
 8003a7a:	6880      	ldr	r0, [r0, #8]
  msk |= ((emp >> (epnum & EP_ADDR_MSK)) & 0x1U) << 7;
 8003a7c:	b2db      	uxtb	r3, r3
 8003a7e:	4313      	orrs	r3, r2
}
 8003a80:	4018      	ands	r0, r3
 8003a82:	4770      	bx	lr

08003a84 <USB_GetMode>:
  return ((USBx->GINTSTS) & 0x1U);
 8003a84:	6940      	ldr	r0, [r0, #20]
}
 8003a86:	f000 0001 	and.w	r0, r0, #1
 8003a8a:	4770      	bx	lr

08003a8c <USB_ActivateSetup>:
  USBx_INEP(0U)->DIEPCTL &= ~USB_OTG_DIEPCTL_MPSIZ;
 8003a8c:	f8d0 3900 	ldr.w	r3, [r0, #2304]	; 0x900
 8003a90:	f423 63ff 	bic.w	r3, r3, #2040	; 0x7f8
 8003a94:	f023 0307 	bic.w	r3, r3, #7
 8003a98:	f8c0 3900 	str.w	r3, [r0, #2304]	; 0x900
  USBx_DEVICE->DCTL |= USB_OTG_DCTL_CGINAK;
 8003a9c:	f8d0 3804 	ldr.w	r3, [r0, #2052]	; 0x804
 8003aa0:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8003aa4:	f8c0 3804 	str.w	r3, [r0, #2052]	; 0x804
}
 8003aa8:	2000      	movs	r0, #0
 8003aaa:	4770      	bx	lr

08003aac <USB_EP0_OutStart>:
{
 8003aac:	b530      	push	{r4, r5, lr}
  uint32_t gSNPSiD = *(__IO uint32_t *)(&USBx->CID + 0x1U);
 8003aae:	6c05      	ldr	r5, [r0, #64]	; 0x40
  if (gSNPSiD > USB_OTG_CORE_ID_300A)
 8003ab0:	4c10      	ldr	r4, [pc, #64]	; (8003af4 <USB_EP0_OutStart+0x48>)
 8003ab2:	42a5      	cmp	r5, r4
    if ((USBx_OUTEP(0U)->DOEPCTL & USB_OTG_DOEPCTL_EPENA) == USB_OTG_DOEPCTL_EPENA)
 8003ab4:	f500 6330 	add.w	r3, r0, #2816	; 0xb00
  if (gSNPSiD > USB_OTG_CORE_ID_300A)
 8003ab8:	d903      	bls.n	8003ac2 <USB_EP0_OutStart+0x16>
    if ((USBx_OUTEP(0U)->DOEPCTL & USB_OTG_DOEPCTL_EPENA) == USB_OTG_DOEPCTL_EPENA)
 8003aba:	f8d0 4b00 	ldr.w	r4, [r0, #2816]	; 0xb00
 8003abe:	2c00      	cmp	r4, #0
 8003ac0:	db16      	blt.n	8003af0 <USB_EP0_OutStart+0x44>
  USBx_OUTEP(0U)->DOEPTSIZ = 0U;
 8003ac2:	2400      	movs	r4, #0
 8003ac4:	611c      	str	r4, [r3, #16]
  USBx_OUTEP(0U)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (1U << 19));
 8003ac6:	691c      	ldr	r4, [r3, #16]
 8003ac8:	f444 2400 	orr.w	r4, r4, #524288	; 0x80000
 8003acc:	611c      	str	r4, [r3, #16]
  USBx_OUTEP(0U)->DOEPTSIZ |= (3U * 8U);
 8003ace:	691c      	ldr	r4, [r3, #16]
 8003ad0:	f044 0418 	orr.w	r4, r4, #24
 8003ad4:	611c      	str	r4, [r3, #16]
  USBx_OUTEP(0U)->DOEPTSIZ |=  USB_OTG_DOEPTSIZ_STUPCNT;
 8003ad6:	691c      	ldr	r4, [r3, #16]
  if (dma == 1U)
 8003ad8:	2901      	cmp	r1, #1
  USBx_OUTEP(0U)->DOEPTSIZ |=  USB_OTG_DOEPTSIZ_STUPCNT;
 8003ada:	f044 44c0 	orr.w	r4, r4, #1610612736	; 0x60000000
 8003ade:	611c      	str	r4, [r3, #16]
    USBx_OUTEP(0U)->DOEPDMA = (uint32_t)psetup;
 8003ae0:	bf01      	itttt	eq
 8003ae2:	615a      	streq	r2, [r3, #20]
    USBx_OUTEP(0U)->DOEPCTL |= USB_OTG_DOEPCTL_EPENA | USB_OTG_DOEPCTL_USBAEP;
 8003ae4:	f8d0 3b00 	ldreq.w	r3, [r0, #2816]	; 0xb00
 8003ae8:	f043 2380 	orreq.w	r3, r3, #2147516416	; 0x80008000
 8003aec:	f8c0 3b00 	streq.w	r3, [r0, #2816]	; 0xb00
}
 8003af0:	2000      	movs	r0, #0
 8003af2:	bd30      	pop	{r4, r5, pc}
 8003af4:	4f54300a 	.word	0x4f54300a

08003af8 <USBD_CDC_EP0_RxReady>:
  * @param  pdev: device instance
  * @retval status
  */
static uint8_t USBD_CDC_EP0_RxReady(USBD_HandleTypeDef *pdev)
{
  USBD_CDC_HandleTypeDef *hcdc = (USBD_CDC_HandleTypeDef *)pdev->pClassDataCmsit[pdev->classId];
 8003af8:	f8d0 32d4 	ldr.w	r3, [r0, #724]	; 0x2d4
 8003afc:	eb00 0083 	add.w	r0, r0, r3, lsl #2
{
 8003b00:	b510      	push	{r4, lr}
  USBD_CDC_HandleTypeDef *hcdc = (USBD_CDC_HandleTypeDef *)pdev->pClassDataCmsit[pdev->classId];
 8003b02:	f8d0 42c0 	ldr.w	r4, [r0, #704]	; 0x2c0

  if (hcdc == NULL)
 8003b06:	b184      	cbz	r4, 8003b2a <USBD_CDC_EP0_RxReady+0x32>
  {
    return (uint8_t)USBD_FAIL;
  }

  if ((pdev->pUserData[pdev->classId] != NULL) && (hcdc->CmdOpCode != 0xFFU))
 8003b08:	f8d0 32c4 	ldr.w	r3, [r0, #708]	; 0x2c4
 8003b0c:	b15b      	cbz	r3, 8003b26 <USBD_CDC_EP0_RxReady+0x2e>
 8003b0e:	f894 0200 	ldrb.w	r0, [r4, #512]	; 0x200
 8003b12:	28ff      	cmp	r0, #255	; 0xff
 8003b14:	d007      	beq.n	8003b26 <USBD_CDC_EP0_RxReady+0x2e>
  {
    ((USBD_CDC_ItfTypeDef *)pdev->pUserData[pdev->classId])->Control(hcdc->CmdOpCode,
 8003b16:	689b      	ldr	r3, [r3, #8]
 8003b18:	f894 2201 	ldrb.w	r2, [r4, #513]	; 0x201
 8003b1c:	4621      	mov	r1, r4
 8003b1e:	4798      	blx	r3
                                                                     (uint8_t *)hcdc->data,
                                                                     (uint16_t)hcdc->CmdLength);
    hcdc->CmdOpCode = 0xFFU;
 8003b20:	23ff      	movs	r3, #255	; 0xff
 8003b22:	f884 3200 	strb.w	r3, [r4, #512]	; 0x200
  }

  return (uint8_t)USBD_OK;
 8003b26:	2000      	movs	r0, #0
 8003b28:	e000      	b.n	8003b2c <USBD_CDC_EP0_RxReady+0x34>
    return (uint8_t)USBD_FAIL;
 8003b2a:	2003      	movs	r0, #3
}
 8003b2c:	bd10      	pop	{r4, pc}
	...

08003b30 <USBD_CDC_GetDeviceQualifierDescriptor>:
  * @param  length : pointer data length
  * @retval pointer to descriptor buffer
  */
uint8_t *USBD_CDC_GetDeviceQualifierDescriptor(uint16_t *length)
{
  *length = (uint16_t)sizeof(USBD_CDC_DeviceQualifierDesc);
 8003b30:	230a      	movs	r3, #10
 8003b32:	8003      	strh	r3, [r0, #0]

  return USBD_CDC_DeviceQualifierDesc;
}
 8003b34:	4800      	ldr	r0, [pc, #0]	; (8003b38 <USBD_CDC_GetDeviceQualifierDescriptor+0x8>)
 8003b36:	4770      	bx	lr
 8003b38:	20000078 	.word	0x20000078

08003b3c <USBD_CDC_GetFSCfgDesc>:
{
 8003b3c:	b570      	push	{r4, r5, r6, lr}
  USBD_EpDescTypeDef *pEpCmdDesc = USBD_GetEpDesc(USBD_CDC_CfgDesc, CDC_CMD_EP);
 8003b3e:	2182      	movs	r1, #130	; 0x82
{
 8003b40:	4606      	mov	r6, r0
  USBD_EpDescTypeDef *pEpCmdDesc = USBD_GetEpDesc(USBD_CDC_CfgDesc, CDC_CMD_EP);
 8003b42:	480f      	ldr	r0, [pc, #60]	; (8003b80 <USBD_CDC_GetFSCfgDesc+0x44>)
 8003b44:	f000 fb93 	bl	800426e <USBD_GetEpDesc>
  USBD_EpDescTypeDef *pEpOutDesc = USBD_GetEpDesc(USBD_CDC_CfgDesc, CDC_OUT_EP);
 8003b48:	2101      	movs	r1, #1
  USBD_EpDescTypeDef *pEpCmdDesc = USBD_GetEpDesc(USBD_CDC_CfgDesc, CDC_CMD_EP);
 8003b4a:	4605      	mov	r5, r0
  USBD_EpDescTypeDef *pEpOutDesc = USBD_GetEpDesc(USBD_CDC_CfgDesc, CDC_OUT_EP);
 8003b4c:	480c      	ldr	r0, [pc, #48]	; (8003b80 <USBD_CDC_GetFSCfgDesc+0x44>)
 8003b4e:	f000 fb8e 	bl	800426e <USBD_GetEpDesc>
  USBD_EpDescTypeDef *pEpInDesc = USBD_GetEpDesc(USBD_CDC_CfgDesc, CDC_IN_EP);
 8003b52:	2181      	movs	r1, #129	; 0x81
  USBD_EpDescTypeDef *pEpOutDesc = USBD_GetEpDesc(USBD_CDC_CfgDesc, CDC_OUT_EP);
 8003b54:	4604      	mov	r4, r0
  USBD_EpDescTypeDef *pEpInDesc = USBD_GetEpDesc(USBD_CDC_CfgDesc, CDC_IN_EP);
 8003b56:	480a      	ldr	r0, [pc, #40]	; (8003b80 <USBD_CDC_GetFSCfgDesc+0x44>)
 8003b58:	f000 fb89 	bl	800426e <USBD_GetEpDesc>
  if (pEpCmdDesc != NULL)
 8003b5c:	b10d      	cbz	r5, 8003b62 <USBD_CDC_GetFSCfgDesc+0x26>
    pEpCmdDesc->bInterval = CDC_FS_BINTERVAL;
 8003b5e:	2210      	movs	r2, #16
 8003b60:	71aa      	strb	r2, [r5, #6]
  if (pEpOutDesc != NULL)
 8003b62:	b11c      	cbz	r4, 8003b6c <USBD_CDC_GetFSCfgDesc+0x30>
    pEpOutDesc->wMaxPacketSize = CDC_DATA_FS_MAX_PACKET_SIZE;
 8003b64:	2240      	movs	r2, #64	; 0x40
 8003b66:	7122      	strb	r2, [r4, #4]
 8003b68:	2200      	movs	r2, #0
 8003b6a:	7162      	strb	r2, [r4, #5]
  if (pEpInDesc != NULL)
 8003b6c:	b118      	cbz	r0, 8003b76 <USBD_CDC_GetFSCfgDesc+0x3a>
    pEpInDesc->wMaxPacketSize = CDC_DATA_FS_MAX_PACKET_SIZE;
 8003b6e:	2240      	movs	r2, #64	; 0x40
 8003b70:	7102      	strb	r2, [r0, #4]
 8003b72:	2200      	movs	r2, #0
 8003b74:	7142      	strb	r2, [r0, #5]
  *length = (uint16_t)sizeof(USBD_CDC_CfgDesc);
 8003b76:	2343      	movs	r3, #67	; 0x43
}
 8003b78:	4801      	ldr	r0, [pc, #4]	; (8003b80 <USBD_CDC_GetFSCfgDesc+0x44>)
  *length = (uint16_t)sizeof(USBD_CDC_CfgDesc);
 8003b7a:	8033      	strh	r3, [r6, #0]
}
 8003b7c:	bd70      	pop	{r4, r5, r6, pc}
 8003b7e:	bf00      	nop
 8003b80:	20000084 	.word	0x20000084

08003b84 <USBD_CDC_GetOtherSpeedCfgDesc>:
 8003b84:	f7ff bfda 	b.w	8003b3c <USBD_CDC_GetFSCfgDesc>

08003b88 <USBD_CDC_GetHSCfgDesc>:
{
 8003b88:	b570      	push	{r4, r5, r6, lr}
  USBD_EpDescTypeDef *pEpCmdDesc = USBD_GetEpDesc(USBD_CDC_CfgDesc, CDC_CMD_EP);
 8003b8a:	2182      	movs	r1, #130	; 0x82
{
 8003b8c:	4606      	mov	r6, r0
  USBD_EpDescTypeDef *pEpCmdDesc = USBD_GetEpDesc(USBD_CDC_CfgDesc, CDC_CMD_EP);
 8003b8e:	480f      	ldr	r0, [pc, #60]	; (8003bcc <USBD_CDC_GetHSCfgDesc+0x44>)
 8003b90:	f000 fb6d 	bl	800426e <USBD_GetEpDesc>
  USBD_EpDescTypeDef *pEpOutDesc = USBD_GetEpDesc(USBD_CDC_CfgDesc, CDC_OUT_EP);
 8003b94:	2101      	movs	r1, #1
  USBD_EpDescTypeDef *pEpCmdDesc = USBD_GetEpDesc(USBD_CDC_CfgDesc, CDC_CMD_EP);
 8003b96:	4605      	mov	r5, r0
  USBD_EpDescTypeDef *pEpOutDesc = USBD_GetEpDesc(USBD_CDC_CfgDesc, CDC_OUT_EP);
 8003b98:	480c      	ldr	r0, [pc, #48]	; (8003bcc <USBD_CDC_GetHSCfgDesc+0x44>)
 8003b9a:	f000 fb68 	bl	800426e <USBD_GetEpDesc>
  USBD_EpDescTypeDef *pEpInDesc = USBD_GetEpDesc(USBD_CDC_CfgDesc, CDC_IN_EP);
 8003b9e:	2181      	movs	r1, #129	; 0x81
  USBD_EpDescTypeDef *pEpOutDesc = USBD_GetEpDesc(USBD_CDC_CfgDesc, CDC_OUT_EP);
 8003ba0:	4604      	mov	r4, r0
  USBD_EpDescTypeDef *pEpInDesc = USBD_GetEpDesc(USBD_CDC_CfgDesc, CDC_IN_EP);
 8003ba2:	480a      	ldr	r0, [pc, #40]	; (8003bcc <USBD_CDC_GetHSCfgDesc+0x44>)
 8003ba4:	f000 fb63 	bl	800426e <USBD_GetEpDesc>
  if (pEpCmdDesc != NULL)
 8003ba8:	b10d      	cbz	r5, 8003bae <USBD_CDC_GetHSCfgDesc+0x26>
    pEpCmdDesc->bInterval = CDC_HS_BINTERVAL;
 8003baa:	2210      	movs	r2, #16
 8003bac:	71aa      	strb	r2, [r5, #6]
  if (pEpOutDesc != NULL)
 8003bae:	b11c      	cbz	r4, 8003bb8 <USBD_CDC_GetHSCfgDesc+0x30>
    pEpOutDesc->wMaxPacketSize = CDC_DATA_HS_MAX_PACKET_SIZE;
 8003bb0:	2200      	movs	r2, #0
 8003bb2:	7122      	strb	r2, [r4, #4]
 8003bb4:	2202      	movs	r2, #2
 8003bb6:	7162      	strb	r2, [r4, #5]
  if (pEpInDesc != NULL)
 8003bb8:	b118      	cbz	r0, 8003bc2 <USBD_CDC_GetHSCfgDesc+0x3a>
    pEpInDesc->wMaxPacketSize = CDC_DATA_HS_MAX_PACKET_SIZE;
 8003bba:	2200      	movs	r2, #0
 8003bbc:	7102      	strb	r2, [r0, #4]
 8003bbe:	2202      	movs	r2, #2
 8003bc0:	7142      	strb	r2, [r0, #5]
  *length = (uint16_t)sizeof(USBD_CDC_CfgDesc);
 8003bc2:	2343      	movs	r3, #67	; 0x43
}
 8003bc4:	4801      	ldr	r0, [pc, #4]	; (8003bcc <USBD_CDC_GetHSCfgDesc+0x44>)
  *length = (uint16_t)sizeof(USBD_CDC_CfgDesc);
 8003bc6:	8033      	strh	r3, [r6, #0]
}
 8003bc8:	bd70      	pop	{r4, r5, r6, pc}
 8003bca:	bf00      	nop
 8003bcc:	20000084 	.word	0x20000084

08003bd0 <USBD_CDC_DataOut>:
{
 8003bd0:	b538      	push	{r3, r4, r5, lr}
  USBD_CDC_HandleTypeDef *hcdc = (USBD_CDC_HandleTypeDef *)pdev->pClassDataCmsit[pdev->classId];
 8003bd2:	f8d0 32d4 	ldr.w	r3, [r0, #724]	; 0x2d4
 8003bd6:	33b0      	adds	r3, #176	; 0xb0
{
 8003bd8:	4604      	mov	r4, r0
  USBD_CDC_HandleTypeDef *hcdc = (USBD_CDC_HandleTypeDef *)pdev->pClassDataCmsit[pdev->classId];
 8003bda:	f850 5023 	ldr.w	r5, [r0, r3, lsl #2]
  if (pdev->pClassDataCmsit[pdev->classId] == NULL)
 8003bde:	b18d      	cbz	r5, 8003c04 <USBD_CDC_DataOut+0x34>
  hcdc->RxLength = USBD_LL_GetRxDataSize(pdev, epnum);
 8003be0:	f7fd f884 	bl	8000cec <USBD_LL_GetRxDataSize>
  ((USBD_CDC_ItfTypeDef *)pdev->pUserData[pdev->classId])->Receive(hcdc->RxBuffer, &hcdc->RxLength);
 8003be4:	f8d4 32d4 	ldr.w	r3, [r4, #724]	; 0x2d4
  hcdc->RxLength = USBD_LL_GetRxDataSize(pdev, epnum);
 8003be8:	f8c5 020c 	str.w	r0, [r5, #524]	; 0x20c
  ((USBD_CDC_ItfTypeDef *)pdev->pUserData[pdev->classId])->Receive(hcdc->RxBuffer, &hcdc->RxLength);
 8003bec:	eb04 0483 	add.w	r4, r4, r3, lsl #2
 8003bf0:	f8d5 0204 	ldr.w	r0, [r5, #516]	; 0x204
 8003bf4:	f8d4 32c4 	ldr.w	r3, [r4, #708]	; 0x2c4
 8003bf8:	f505 7103 	add.w	r1, r5, #524	; 0x20c
 8003bfc:	68db      	ldr	r3, [r3, #12]
 8003bfe:	4798      	blx	r3
  return (uint8_t)USBD_OK;
 8003c00:	2000      	movs	r0, #0
}
 8003c02:	bd38      	pop	{r3, r4, r5, pc}
    return (uint8_t)USBD_FAIL;
 8003c04:	2003      	movs	r0, #3
 8003c06:	e7fc      	b.n	8003c02 <USBD_CDC_DataOut+0x32>

08003c08 <USBD_CDC_DataIn>:
{
 8003c08:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8003c0a:	f8d0 62d4 	ldr.w	r6, [r0, #724]	; 0x2d4
  PCD_HandleTypeDef *hpcd = (PCD_HandleTypeDef *)pdev->pData;
 8003c0e:	f8d0 72c8 	ldr.w	r7, [r0, #712]	; 0x2c8
  if (pdev->pClassDataCmsit[pdev->classId] == NULL)
 8003c12:	eb00 0686 	add.w	r6, r0, r6, lsl #2
{
 8003c16:	460a      	mov	r2, r1
  if (pdev->pClassDataCmsit[pdev->classId] == NULL)
 8003c18:	f8d6 52c0 	ldr.w	r5, [r6, #704]	; 0x2c0
 8003c1c:	b335      	cbz	r5, 8003c6c <USBD_CDC_DataIn+0x64>
  if ((pdev->ep_in[epnum & 0xFU].total_length > 0U) &&
 8003c1e:	2414      	movs	r4, #20
 8003c20:	f001 0c0f 	and.w	ip, r1, #15
 8003c24:	fb04 030c 	mla	r3, r4, ip, r0
 8003c28:	699c      	ldr	r4, [r3, #24]
 8003c2a:	b184      	cbz	r4, 8003c4e <USBD_CDC_DataIn+0x46>
      ((pdev->ep_in[epnum & 0xFU].total_length % hpcd->IN_ep[epnum & 0xFU].maxpacket) == 0U))
 8003c2c:	f04f 0e24 	mov.w	lr, #36	; 0x24
 8003c30:	fb0e 770c 	mla	r7, lr, ip, r7
 8003c34:	6cbf      	ldr	r7, [r7, #72]	; 0x48
 8003c36:	fbb4 fcf7 	udiv	ip, r4, r7
 8003c3a:	fb07 441c 	mls	r4, r7, ip, r4
  if ((pdev->ep_in[epnum & 0xFU].total_length > 0U) &&
 8003c3e:	b934      	cbnz	r4, 8003c4e <USBD_CDC_DataIn+0x46>
    pdev->ep_in[epnum & 0xFU].total_length = 0U;
 8003c40:	619c      	str	r4, [r3, #24]
    (void)USBD_LL_Transmit(pdev, epnum, NULL, 0U);
 8003c42:	4622      	mov	r2, r4
 8003c44:	4623      	mov	r3, r4
 8003c46:	f7fd f843 	bl	8000cd0 <USBD_LL_Transmit>
  return (uint8_t)USBD_OK;
 8003c4a:	4620      	mov	r0, r4
 8003c4c:	e00d      	b.n	8003c6a <USBD_CDC_DataIn+0x62>
    if (((USBD_CDC_ItfTypeDef *)pdev->pUserData[pdev->classId])->TransmitCplt != NULL)
 8003c4e:	f8d6 32c4 	ldr.w	r3, [r6, #708]	; 0x2c4
 8003c52:	691c      	ldr	r4, [r3, #16]
    hcdc->TxState = 0U;
 8003c54:	2700      	movs	r7, #0
 8003c56:	f8c5 7214 	str.w	r7, [r5, #532]	; 0x214
    if (((USBD_CDC_ItfTypeDef *)pdev->pUserData[pdev->classId])->TransmitCplt != NULL)
 8003c5a:	2c00      	cmp	r4, #0
 8003c5c:	d0f5      	beq.n	8003c4a <USBD_CDC_DataIn+0x42>
      ((USBD_CDC_ItfTypeDef *)pdev->pUserData[pdev->classId])->TransmitCplt(hcdc->TxBuffer, &hcdc->TxLength, epnum);
 8003c5e:	f8d5 0208 	ldr.w	r0, [r5, #520]	; 0x208
 8003c62:	f505 7104 	add.w	r1, r5, #528	; 0x210
 8003c66:	47a0      	blx	r4
  return (uint8_t)USBD_OK;
 8003c68:	4638      	mov	r0, r7
}
 8003c6a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    return (uint8_t)USBD_FAIL;
 8003c6c:	2003      	movs	r0, #3
 8003c6e:	e7fc      	b.n	8003c6a <USBD_CDC_DataIn+0x62>

08003c70 <USBD_CDC_Setup>:
  USBD_CDC_HandleTypeDef *hcdc = (USBD_CDC_HandleTypeDef *)pdev->pClassDataCmsit[pdev->classId];
 8003c70:	f8d0 32d4 	ldr.w	r3, [r0, #724]	; 0x2d4
{
 8003c74:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
 8003c78:	eb00 0383 	add.w	r3, r0, r3, lsl #2
  uint8_t ifalt = 0U;
 8003c7c:	f04f 0800 	mov.w	r8, #0
  USBD_CDC_HandleTypeDef *hcdc = (USBD_CDC_HandleTypeDef *)pdev->pClassDataCmsit[pdev->classId];
 8003c80:	f8d3 72c0 	ldr.w	r7, [r3, #704]	; 0x2c0
  uint8_t ifalt = 0U;
 8003c84:	f88d 8005 	strb.w	r8, [sp, #5]
{
 8003c88:	4605      	mov	r5, r0
 8003c8a:	460e      	mov	r6, r1
  uint16_t status_info = 0U;
 8003c8c:	f8ad 8006 	strh.w	r8, [sp, #6]
  if (hcdc == NULL)
 8003c90:	2f00      	cmp	r7, #0
 8003c92:	d06e      	beq.n	8003d72 <USBD_CDC_Setup+0x102>
  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 8003c94:	780a      	ldrb	r2, [r1, #0]
 8003c96:	f012 0460 	ands.w	r4, r2, #96	; 0x60
 8003c9a:	d02e      	beq.n	8003cfa <USBD_CDC_Setup+0x8a>
 8003c9c:	2c20      	cmp	r4, #32
 8003c9e:	d164      	bne.n	8003d6a <USBD_CDC_Setup+0xfa>
      if (req->wLength != 0U)
 8003ca0:	88cc      	ldrh	r4, [r1, #6]
          ((USBD_CDC_ItfTypeDef *)pdev->pUserData[pdev->classId])->Control(req->bRequest,
 8003ca2:	f891 c001 	ldrb.w	ip, [r1, #1]
      if (req->wLength != 0U)
 8003ca6:	b30c      	cbz	r4, 8003cec <USBD_CDC_Setup+0x7c>
        if ((req->bmRequest & 0x80U) != 0U)
 8003ca8:	0612      	lsls	r2, r2, #24
 8003caa:	d513      	bpl.n	8003cd4 <USBD_CDC_Setup+0x64>
          ((USBD_CDC_ItfTypeDef *)pdev->pUserData[pdev->classId])->Control(req->bRequest,
 8003cac:	f8d3 32c4 	ldr.w	r3, [r3, #708]	; 0x2c4
 8003cb0:	4622      	mov	r2, r4
 8003cb2:	4639      	mov	r1, r7
 8003cb4:	689b      	ldr	r3, [r3, #8]
 8003cb6:	4660      	mov	r0, ip
 8003cb8:	4798      	blx	r3
          len = MIN(CDC_REQ_MAX_DATA_SIZE, req->wLength);
 8003cba:	88f2      	ldrh	r2, [r6, #6]
          (void)USBD_CtlSendData(pdev, (uint8_t *)hcdc->data, len);
 8003cbc:	2a07      	cmp	r2, #7
 8003cbe:	bf28      	it	cs
 8003cc0:	2207      	movcs	r2, #7
 8003cc2:	4639      	mov	r1, r7
 8003cc4:	4628      	mov	r0, r5
 8003cc6:	f000 fd40 	bl	800474a <USBD_CtlSendData>
  USBD_StatusTypeDef ret = USBD_OK;
 8003cca:	4644      	mov	r4, r8
}
 8003ccc:	4620      	mov	r0, r4
 8003cce:	b002      	add	sp, #8
 8003cd0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
          hcdc->CmdOpCode = req->bRequest;
 8003cd4:	2c40      	cmp	r4, #64	; 0x40
 8003cd6:	bf28      	it	cs
 8003cd8:	2440      	movcs	r4, #64	; 0x40
 8003cda:	f887 c200 	strb.w	ip, [r7, #512]	; 0x200
          hcdc->CmdLength = (uint8_t)MIN(req->wLength, USB_MAX_EP0_SIZE);
 8003cde:	f887 4201 	strb.w	r4, [r7, #513]	; 0x201
          (void)USBD_CtlPrepareRx(pdev, (uint8_t *)hcdc->data, hcdc->CmdLength);
 8003ce2:	4622      	mov	r2, r4
 8003ce4:	4639      	mov	r1, r7
 8003ce6:	f000 fd45 	bl	8004774 <USBD_CtlPrepareRx>
 8003cea:	e7ee      	b.n	8003cca <USBD_CDC_Setup+0x5a>
        ((USBD_CDC_ItfTypeDef *)pdev->pUserData[pdev->classId])->Control(req->bRequest,
 8003cec:	f8d3 32c4 	ldr.w	r3, [r3, #708]	; 0x2c4
 8003cf0:	4622      	mov	r2, r4
 8003cf2:	689b      	ldr	r3, [r3, #8]
 8003cf4:	4660      	mov	r0, ip
 8003cf6:	4798      	blx	r3
 8003cf8:	e7e8      	b.n	8003ccc <USBD_CDC_Setup+0x5c>
      switch (req->bRequest)
 8003cfa:	784f      	ldrb	r7, [r1, #1]
 8003cfc:	2f0b      	cmp	r7, #11
 8003cfe:	d834      	bhi.n	8003d6a <USBD_CDC_Setup+0xfa>
 8003d00:	a301      	add	r3, pc, #4	; (adr r3, 8003d08 <USBD_CDC_Setup+0x98>)
 8003d02:	f853 f027 	ldr.w	pc, [r3, r7, lsl #2]
 8003d06:	bf00      	nop
 8003d08:	08003d39 	.word	0x08003d39
 8003d0c:	08003ccd 	.word	0x08003ccd
 8003d10:	08003d6b 	.word	0x08003d6b
 8003d14:	08003d6b 	.word	0x08003d6b
 8003d18:	08003d6b 	.word	0x08003d6b
 8003d1c:	08003d6b 	.word	0x08003d6b
 8003d20:	08003d6b 	.word	0x08003d6b
 8003d24:	08003d6b 	.word	0x08003d6b
 8003d28:	08003d6b 	.word	0x08003d6b
 8003d2c:	08003d6b 	.word	0x08003d6b
 8003d30:	08003d4f 	.word	0x08003d4f
 8003d34:	08003d63 	.word	0x08003d63
          if (pdev->dev_state == USBD_STATE_CONFIGURED)
 8003d38:	f890 329c 	ldrb.w	r3, [r0, #668]	; 0x29c
 8003d3c:	2b03      	cmp	r3, #3
 8003d3e:	d114      	bne.n	8003d6a <USBD_CDC_Setup+0xfa>
            (void)USBD_CtlSendData(pdev, (uint8_t *)&status_info, 2U);
 8003d40:	2202      	movs	r2, #2
 8003d42:	f10d 0106 	add.w	r1, sp, #6
 8003d46:	f000 fd00 	bl	800474a <USBD_CtlSendData>
  USBD_StatusTypeDef ret = USBD_OK;
 8003d4a:	463c      	mov	r4, r7
 8003d4c:	e7be      	b.n	8003ccc <USBD_CDC_Setup+0x5c>
          if (pdev->dev_state == USBD_STATE_CONFIGURED)
 8003d4e:	f890 329c 	ldrb.w	r3, [r0, #668]	; 0x29c
 8003d52:	2b03      	cmp	r3, #3
 8003d54:	d109      	bne.n	8003d6a <USBD_CDC_Setup+0xfa>
            (void)USBD_CtlSendData(pdev, &ifalt, 1U);
 8003d56:	2201      	movs	r2, #1
 8003d58:	f10d 0105 	add.w	r1, sp, #5
 8003d5c:	f000 fcf5 	bl	800474a <USBD_CtlSendData>
 8003d60:	e7b4      	b.n	8003ccc <USBD_CDC_Setup+0x5c>
          if (pdev->dev_state != USBD_STATE_CONFIGURED)
 8003d62:	f890 329c 	ldrb.w	r3, [r0, #668]	; 0x29c
 8003d66:	2b03      	cmp	r3, #3
 8003d68:	d0b0      	beq.n	8003ccc <USBD_CDC_Setup+0x5c>
          USBD_CtlError(pdev, req);
 8003d6a:	4631      	mov	r1, r6
 8003d6c:	4628      	mov	r0, r5
 8003d6e:	f000 fcc5 	bl	80046fc <USBD_CtlError>
    return (uint8_t)USBD_FAIL;
 8003d72:	2403      	movs	r4, #3
 8003d74:	e7aa      	b.n	8003ccc <USBD_CDC_Setup+0x5c>
 8003d76:	bf00      	nop

08003d78 <USBD_CDC_DeInit>:
{
 8003d78:	b538      	push	{r3, r4, r5, lr}
 8003d7a:	4604      	mov	r4, r0
  pdev->ep_in[CDCInEpAdd & 0xFU].is_used = 0U;
 8003d7c:	2500      	movs	r5, #0
  (void)USBD_LL_CloseEP(pdev, CDCInEpAdd);
 8003d7e:	2181      	movs	r1, #129	; 0x81
 8003d80:	f7fc ff77 	bl	8000c72 <USBD_LL_CloseEP>
  (void)USBD_LL_CloseEP(pdev, CDCOutEpAdd);
 8003d84:	2101      	movs	r1, #1
  pdev->ep_in[CDCInEpAdd & 0xFU].is_used = 0U;
 8003d86:	8725      	strh	r5, [r4, #56]	; 0x38
  (void)USBD_LL_CloseEP(pdev, CDCOutEpAdd);
 8003d88:	4620      	mov	r0, r4
 8003d8a:	f7fc ff72 	bl	8000c72 <USBD_LL_CloseEP>
  pdev->ep_out[CDCOutEpAdd & 0xFU].is_used = 0U;
 8003d8e:	f8a4 5178 	strh.w	r5, [r4, #376]	; 0x178
  (void)USBD_LL_CloseEP(pdev, CDCCmdEpAdd);
 8003d92:	2182      	movs	r1, #130	; 0x82
 8003d94:	4620      	mov	r0, r4
 8003d96:	f7fc ff6c 	bl	8000c72 <USBD_LL_CloseEP>
  pdev->ep_in[CDCCmdEpAdd & 0xFU].bInterval = 0U;
 8003d9a:	f8d4 32d4 	ldr.w	r3, [r4, #724]	; 0x2d4
  pdev->ep_in[CDCCmdEpAdd & 0xFU].is_used = 0U;
 8003d9e:	64e5      	str	r5, [r4, #76]	; 0x4c
  if (pdev->pClassDataCmsit[pdev->classId] != NULL)
 8003da0:	eb04 0383 	add.w	r3, r4, r3, lsl #2
 8003da4:	f8d3 22c0 	ldr.w	r2, [r3, #704]	; 0x2c0
 8003da8:	b18a      	cbz	r2, 8003dce <USBD_CDC_DeInit+0x56>
    ((USBD_CDC_ItfTypeDef *)pdev->pUserData[pdev->classId])->DeInit();
 8003daa:	f8d3 32c4 	ldr.w	r3, [r3, #708]	; 0x2c4
 8003dae:	685b      	ldr	r3, [r3, #4]
 8003db0:	4798      	blx	r3
    (void)USBD_free(pdev->pClassDataCmsit[pdev->classId]);
 8003db2:	f8d4 32d4 	ldr.w	r3, [r4, #724]	; 0x2d4
 8003db6:	33b0      	adds	r3, #176	; 0xb0
 8003db8:	f854 0023 	ldr.w	r0, [r4, r3, lsl #2]
 8003dbc:	f000 fd0e 	bl	80047dc <free>
    pdev->pClassDataCmsit[pdev->classId] = NULL;
 8003dc0:	f8d4 32d4 	ldr.w	r3, [r4, #724]	; 0x2d4
 8003dc4:	33b0      	adds	r3, #176	; 0xb0
 8003dc6:	f844 5023 	str.w	r5, [r4, r3, lsl #2]
    pdev->pClassData = NULL;
 8003dca:	f8c4 52bc 	str.w	r5, [r4, #700]	; 0x2bc
}
 8003dce:	2000      	movs	r0, #0
 8003dd0:	bd38      	pop	{r3, r4, r5, pc}

08003dd2 <USBD_CDC_Init>:
{
 8003dd2:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8003dd4:	4604      	mov	r4, r0
  hcdc = (USBD_CDC_HandleTypeDef *)USBD_malloc(sizeof(USBD_CDC_HandleTypeDef));
 8003dd6:	f44f 7007 	mov.w	r0, #540	; 0x21c
 8003dda:	f000 fcf7 	bl	80047cc <malloc>
  if (hcdc == NULL)
 8003dde:	4605      	mov	r5, r0
 8003de0:	b930      	cbnz	r0, 8003df0 <USBD_CDC_Init+0x1e>
    pdev->pClassDataCmsit[pdev->classId] = NULL;
 8003de2:	f8d4 32d4 	ldr.w	r3, [r4, #724]	; 0x2d4
 8003de6:	33b0      	adds	r3, #176	; 0xb0
 8003de8:	f844 0023 	str.w	r0, [r4, r3, lsl #2]
    return (uint8_t)USBD_EMEM;
 8003dec:	2502      	movs	r5, #2
 8003dee:	e045      	b.n	8003e7c <USBD_CDC_Init+0xaa>
  (void)USBD_memset(hcdc, 0, sizeof(USBD_CDC_HandleTypeDef));
 8003df0:	f44f 7207 	mov.w	r2, #540	; 0x21c
 8003df4:	2100      	movs	r1, #0
 8003df6:	f000 fda5 	bl	8004944 <memset>
  pdev->pClassDataCmsit[pdev->classId] = (void *)hcdc;
 8003dfa:	f8d4 32d4 	ldr.w	r3, [r4, #724]	; 0x2d4
 8003dfe:	33b0      	adds	r3, #176	; 0xb0
 8003e00:	f844 5023 	str.w	r5, [r4, r3, lsl #2]
  if (pdev->dev_speed == USBD_SPEED_HIGH)
 8003e04:	7c23      	ldrb	r3, [r4, #16]
  pdev->pClassData = pdev->pClassDataCmsit[pdev->classId];
 8003e06:	f8c4 52bc 	str.w	r5, [r4, #700]	; 0x2bc
  if (pdev->dev_speed == USBD_SPEED_HIGH)
 8003e0a:	bbcb      	cbnz	r3, 8003e80 <USBD_CDC_Init+0xae>
    (void)USBD_LL_OpenEP(pdev, CDCInEpAdd, USBD_EP_TYPE_BULK,
 8003e0c:	f44f 7300 	mov.w	r3, #512	; 0x200
 8003e10:	2181      	movs	r1, #129	; 0x81
 8003e12:	2202      	movs	r2, #2
 8003e14:	4620      	mov	r0, r4
 8003e16:	f7fc ff22 	bl	8000c5e <USBD_LL_OpenEP>
    pdev->ep_in[CDCInEpAdd & 0xFU].is_used = 1U;
 8003e1a:	2101      	movs	r1, #1
 8003e1c:	8721      	strh	r1, [r4, #56]	; 0x38
    (void)USBD_LL_OpenEP(pdev, CDCOutEpAdd, USBD_EP_TYPE_BULK,
 8003e1e:	f44f 7300 	mov.w	r3, #512	; 0x200
    (void)USBD_LL_OpenEP(pdev, CDCOutEpAdd, USBD_EP_TYPE_BULK,
 8003e22:	2202      	movs	r2, #2
 8003e24:	4620      	mov	r0, r4
 8003e26:	f7fc ff1a 	bl	8000c5e <USBD_LL_OpenEP>
    pdev->ep_out[CDCOutEpAdd & 0xFU].is_used = 1U;
 8003e2a:	2701      	movs	r7, #1
    pdev->ep_in[CDCCmdEpAdd & 0xFU].bInterval = CDC_HS_BINTERVAL;
 8003e2c:	2310      	movs	r3, #16
  (void)USBD_LL_OpenEP(pdev, CDCCmdEpAdd, USBD_EP_TYPE_INTR, CDC_CMD_PACKET_SIZE);
 8003e2e:	2203      	movs	r2, #3
    pdev->ep_in[CDCCmdEpAdd & 0xFU].bInterval = CDC_HS_BINTERVAL;
 8003e30:	f8a4 304e 	strh.w	r3, [r4, #78]	; 0x4e
  (void)USBD_LL_OpenEP(pdev, CDCCmdEpAdd, USBD_EP_TYPE_INTR, CDC_CMD_PACKET_SIZE);
 8003e34:	2182      	movs	r1, #130	; 0x82
 8003e36:	2308      	movs	r3, #8
    pdev->ep_out[CDCOutEpAdd & 0xFU].is_used = 1U;
 8003e38:	f8a4 7178 	strh.w	r7, [r4, #376]	; 0x178
  (void)USBD_LL_OpenEP(pdev, CDCCmdEpAdd, USBD_EP_TYPE_INTR, CDC_CMD_PACKET_SIZE);
 8003e3c:	4620      	mov	r0, r4
 8003e3e:	f7fc ff0e 	bl	8000c5e <USBD_LL_OpenEP>
  ((USBD_CDC_ItfTypeDef *)pdev->pUserData[pdev->classId])->Init();
 8003e42:	f8d4 32d4 	ldr.w	r3, [r4, #724]	; 0x2d4
  pdev->ep_in[CDCCmdEpAdd & 0xFU].is_used = 1U;
 8003e46:	f8a4 704c 	strh.w	r7, [r4, #76]	; 0x4c
  ((USBD_CDC_ItfTypeDef *)pdev->pUserData[pdev->classId])->Init();
 8003e4a:	eb04 0383 	add.w	r3, r4, r3, lsl #2
  hcdc->RxBuffer = NULL;
 8003e4e:	2600      	movs	r6, #0
  ((USBD_CDC_ItfTypeDef *)pdev->pUserData[pdev->classId])->Init();
 8003e50:	f8d3 32c4 	ldr.w	r3, [r3, #708]	; 0x2c4
  hcdc->RxBuffer = NULL;
 8003e54:	f8c5 6204 	str.w	r6, [r5, #516]	; 0x204
  ((USBD_CDC_ItfTypeDef *)pdev->pUserData[pdev->classId])->Init();
 8003e58:	681b      	ldr	r3, [r3, #0]
 8003e5a:	4798      	blx	r3
  if (hcdc->RxBuffer == NULL)
 8003e5c:	f8d5 2204 	ldr.w	r2, [r5, #516]	; 0x204
  hcdc->TxState = 0U;
 8003e60:	f8c5 6214 	str.w	r6, [r5, #532]	; 0x214
  hcdc->RxState = 0U;
 8003e64:	f8c5 6218 	str.w	r6, [r5, #536]	; 0x218
  if (hcdc->RxBuffer == NULL)
 8003e68:	2a00      	cmp	r2, #0
 8003e6a:	d0bf      	beq.n	8003dec <USBD_CDC_Init+0x1a>
  if (pdev->dev_speed == USBD_SPEED_HIGH)
 8003e6c:	7c25      	ldrb	r5, [r4, #16]
 8003e6e:	b98d      	cbnz	r5, 8003e94 <USBD_CDC_Init+0xc2>
    (void)USBD_LL_PrepareReceive(pdev, CDCOutEpAdd, hcdc->RxBuffer,
 8003e70:	f44f 7300 	mov.w	r3, #512	; 0x200
 8003e74:	4639      	mov	r1, r7
 8003e76:	4620      	mov	r0, r4
 8003e78:	f7fc ff31 	bl	8000cde <USBD_LL_PrepareReceive>
}
 8003e7c:	4628      	mov	r0, r5
 8003e7e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    (void)USBD_LL_OpenEP(pdev, CDCInEpAdd, USBD_EP_TYPE_BULK,
 8003e80:	2340      	movs	r3, #64	; 0x40
 8003e82:	2181      	movs	r1, #129	; 0x81
 8003e84:	2202      	movs	r2, #2
 8003e86:	4620      	mov	r0, r4
 8003e88:	f7fc fee9 	bl	8000c5e <USBD_LL_OpenEP>
    pdev->ep_in[CDCInEpAdd & 0xFU].is_used = 1U;
 8003e8c:	2101      	movs	r1, #1
 8003e8e:	8721      	strh	r1, [r4, #56]	; 0x38
    (void)USBD_LL_OpenEP(pdev, CDCOutEpAdd, USBD_EP_TYPE_BULK,
 8003e90:	2340      	movs	r3, #64	; 0x40
 8003e92:	e7c6      	b.n	8003e22 <USBD_CDC_Init+0x50>
    (void)USBD_LL_PrepareReceive(pdev, CDCOutEpAdd, hcdc->RxBuffer,
 8003e94:	2340      	movs	r3, #64	; 0x40
 8003e96:	4639      	mov	r1, r7
 8003e98:	4620      	mov	r0, r4
 8003e9a:	f7fc ff20 	bl	8000cde <USBD_LL_PrepareReceive>
  return (uint8_t)USBD_OK;
 8003e9e:	4635      	mov	r5, r6
 8003ea0:	e7ec      	b.n	8003e7c <USBD_CDC_Init+0xaa>

08003ea2 <USBD_CDC_RegisterInterface>:
  * @retval status
  */
uint8_t USBD_CDC_RegisterInterface(USBD_HandleTypeDef *pdev,
                                   USBD_CDC_ItfTypeDef *fops)
{
  if (fops == NULL)
 8003ea2:	b139      	cbz	r1, 8003eb4 <USBD_CDC_RegisterInterface+0x12>
  {
    return (uint8_t)USBD_FAIL;
  }

  pdev->pUserData[pdev->classId] = fops;
 8003ea4:	f8d0 32d4 	ldr.w	r3, [r0, #724]	; 0x2d4
 8003ea8:	eb00 0083 	add.w	r0, r0, r3, lsl #2
 8003eac:	f8c0 12c4 	str.w	r1, [r0, #708]	; 0x2c4

  return (uint8_t)USBD_OK;
 8003eb0:	2000      	movs	r0, #0
 8003eb2:	4770      	bx	lr
    return (uint8_t)USBD_FAIL;
 8003eb4:	2003      	movs	r0, #3
}
 8003eb6:	4770      	bx	lr

08003eb8 <USBD_CDC_SetTxBuffer>:
  * @retval status
  */
uint8_t USBD_CDC_SetTxBuffer(USBD_HandleTypeDef *pdev,
                             uint8_t *pbuff, uint32_t length)
{
  USBD_CDC_HandleTypeDef *hcdc = (USBD_CDC_HandleTypeDef *)pdev->pClassDataCmsit[pdev->classId];
 8003eb8:	f8d0 32d4 	ldr.w	r3, [r0, #724]	; 0x2d4
 8003ebc:	33b0      	adds	r3, #176	; 0xb0
 8003ebe:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]

  if (hcdc == NULL)
 8003ec2:	b12b      	cbz	r3, 8003ed0 <USBD_CDC_SetTxBuffer+0x18>
  {
    return (uint8_t)USBD_FAIL;
  }

  hcdc->TxBuffer = pbuff;
 8003ec4:	f8c3 1208 	str.w	r1, [r3, #520]	; 0x208
  hcdc->TxLength = length;
 8003ec8:	f8c3 2210 	str.w	r2, [r3, #528]	; 0x210

  return (uint8_t)USBD_OK;
 8003ecc:	2000      	movs	r0, #0
 8003ece:	4770      	bx	lr
    return (uint8_t)USBD_FAIL;
 8003ed0:	2003      	movs	r0, #3
}
 8003ed2:	4770      	bx	lr

08003ed4 <USBD_CDC_SetRxBuffer>:
  * @param  pbuff: Rx Buffer
  * @retval status
  */
uint8_t USBD_CDC_SetRxBuffer(USBD_HandleTypeDef *pdev, uint8_t *pbuff)
{
  USBD_CDC_HandleTypeDef *hcdc = (USBD_CDC_HandleTypeDef *)pdev->pClassDataCmsit[pdev->classId];
 8003ed4:	f8d0 32d4 	ldr.w	r3, [r0, #724]	; 0x2d4
 8003ed8:	33b0      	adds	r3, #176	; 0xb0
 8003eda:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]

  if (hcdc == NULL)
 8003ede:	b11b      	cbz	r3, 8003ee8 <USBD_CDC_SetRxBuffer+0x14>
  {
    return (uint8_t)USBD_FAIL;
  }

  hcdc->RxBuffer = pbuff;
 8003ee0:	f8c3 1204 	str.w	r1, [r3, #516]	; 0x204

  return (uint8_t)USBD_OK;
 8003ee4:	2000      	movs	r0, #0
 8003ee6:	4770      	bx	lr
    return (uint8_t)USBD_FAIL;
 8003ee8:	2003      	movs	r0, #3
}
 8003eea:	4770      	bx	lr

08003eec <USBD_CDC_TransmitPacket>:
  * @param  pdev: device instance
  * @retval status
  */
uint8_t USBD_CDC_TransmitPacket(USBD_HandleTypeDef *pdev)
{
  USBD_CDC_HandleTypeDef *hcdc = (USBD_CDC_HandleTypeDef *)pdev->pClassDataCmsit[pdev->classId];
 8003eec:	f8d0 32d4 	ldr.w	r3, [r0, #724]	; 0x2d4
 8003ef0:	33b0      	adds	r3, #176	; 0xb0
{
 8003ef2:	b510      	push	{r4, lr}
  USBD_CDC_HandleTypeDef *hcdc = (USBD_CDC_HandleTypeDef *)pdev->pClassDataCmsit[pdev->classId];
 8003ef4:	f850 2023 	ldr.w	r2, [r0, r3, lsl #2]

#ifdef USE_USBD_COMPOSITE
  /* Get the Endpoints addresses allocated for this class instance */
  CDCInEpAdd  = USBD_CoreGetEPAdd(pdev, USBD_EP_IN, USBD_EP_TYPE_BULK);
#endif /* USE_USBD_COMPOSITE */
  if (pdev->pClassDataCmsit[pdev->classId] == NULL)
 8003ef8:	b17a      	cbz	r2, 8003f1a <USBD_CDC_TransmitPacket+0x2e>
  {
    return (uint8_t)USBD_FAIL;
  }

  if (hcdc->TxState == 0U)
 8003efa:	f8d2 4214 	ldr.w	r4, [r2, #532]	; 0x214
 8003efe:	2301      	movs	r3, #1
 8003f00:	b96c      	cbnz	r4, 8003f1e <USBD_CDC_TransmitPacket+0x32>
  {
    /* Tx Transfer in progress */
    hcdc->TxState = 1U;
 8003f02:	f8c2 3214 	str.w	r3, [r2, #532]	; 0x214

    /* Update the packet total length */
    pdev->ep_in[CDCInEpAdd & 0xFU].total_length = hcdc->TxLength;
 8003f06:	f8d2 3210 	ldr.w	r3, [r2, #528]	; 0x210
 8003f0a:	62c3      	str	r3, [r0, #44]	; 0x2c

    /* Transmit next packet */
    (void)USBD_LL_Transmit(pdev, CDCInEpAdd, hcdc->TxBuffer, hcdc->TxLength);
 8003f0c:	f8d2 2208 	ldr.w	r2, [r2, #520]	; 0x208
 8003f10:	2181      	movs	r1, #129	; 0x81
 8003f12:	f7fc fedd 	bl	8000cd0 <USBD_LL_Transmit>

    ret = USBD_OK;
 8003f16:	4620      	mov	r0, r4
  }

  return (uint8_t)ret;
}
 8003f18:	bd10      	pop	{r4, pc}
    return (uint8_t)USBD_FAIL;
 8003f1a:	2003      	movs	r0, #3
 8003f1c:	e7fc      	b.n	8003f18 <USBD_CDC_TransmitPacket+0x2c>
  USBD_StatusTypeDef ret = USBD_BUSY;
 8003f1e:	4618      	mov	r0, r3
 8003f20:	e7fa      	b.n	8003f18 <USBD_CDC_TransmitPacket+0x2c>

08003f22 <USBD_CDC_ReceivePacket>:
  * @param  pdev: device instance
  * @retval status
  */
uint8_t USBD_CDC_ReceivePacket(USBD_HandleTypeDef *pdev)
{
  USBD_CDC_HandleTypeDef *hcdc = (USBD_CDC_HandleTypeDef *)pdev->pClassDataCmsit[pdev->classId];
 8003f22:	f8d0 22d4 	ldr.w	r2, [r0, #724]	; 0x2d4
 8003f26:	32b0      	adds	r2, #176	; 0xb0
{
 8003f28:	b510      	push	{r4, lr}
  USBD_CDC_HandleTypeDef *hcdc = (USBD_CDC_HandleTypeDef *)pdev->pClassDataCmsit[pdev->classId];
 8003f2a:	f850 2022 	ldr.w	r2, [r0, r2, lsl #2]
#ifdef USE_USBD_COMPOSITE
  /* Get the Endpoints addresses allocated for this class instance */
  CDCOutEpAdd = USBD_CoreGetEPAdd(pdev, USBD_EP_OUT, USBD_EP_TYPE_BULK);
#endif /* USE_USBD_COMPOSITE */

  if (pdev->pClassDataCmsit[pdev->classId] == NULL)
 8003f2e:	b182      	cbz	r2, 8003f52 <USBD_CDC_ReceivePacket+0x30>
  {
    return (uint8_t)USBD_FAIL;
  }

  if (pdev->dev_speed == USBD_SPEED_HIGH)
 8003f30:	7c04      	ldrb	r4, [r0, #16]
  {
    /* Prepare Out endpoint to receive next packet */
    (void)USBD_LL_PrepareReceive(pdev, CDCOutEpAdd, hcdc->RxBuffer,
 8003f32:	f8d2 2204 	ldr.w	r2, [r2, #516]	; 0x204
  if (pdev->dev_speed == USBD_SPEED_HIGH)
 8003f36:	b934      	cbnz	r4, 8003f46 <USBD_CDC_ReceivePacket+0x24>
    (void)USBD_LL_PrepareReceive(pdev, CDCOutEpAdd, hcdc->RxBuffer,
 8003f38:	f44f 7300 	mov.w	r3, #512	; 0x200
 8003f3c:	2101      	movs	r1, #1
 8003f3e:	f7fc fece 	bl	8000cde <USBD_LL_PrepareReceive>
    (void)USBD_LL_PrepareReceive(pdev, CDCOutEpAdd, hcdc->RxBuffer,
                                 CDC_DATA_FS_OUT_PACKET_SIZE);
  }

  return (uint8_t)USBD_OK;
}
 8003f42:	4620      	mov	r0, r4
 8003f44:	bd10      	pop	{r4, pc}
    (void)USBD_LL_PrepareReceive(pdev, CDCOutEpAdd, hcdc->RxBuffer,
 8003f46:	2340      	movs	r3, #64	; 0x40
 8003f48:	2101      	movs	r1, #1
 8003f4a:	f7fc fec8 	bl	8000cde <USBD_LL_PrepareReceive>
  return (uint8_t)USBD_OK;
 8003f4e:	2400      	movs	r4, #0
 8003f50:	e7f7      	b.n	8003f42 <USBD_CDC_ReceivePacket+0x20>
    return (uint8_t)USBD_FAIL;
 8003f52:	2403      	movs	r4, #3
 8003f54:	e7f5      	b.n	8003f42 <USBD_CDC_ReceivePacket+0x20>

08003f56 <USBD_Init>:
                             USBD_DescriptorsTypeDef *pdesc, uint8_t id)
{
  USBD_StatusTypeDef ret;

  /* Check whether the USB Host handle is valid */
  if (pdev == NULL)
 8003f56:	b178      	cbz	r0, 8003f78 <USBD_Init+0x22>
    pdev->NumClasses = 0;
    pdev->classId = 0;
  }
#else
  /* Unlink previous class*/
  pdev->pClass[0] = NULL;
 8003f58:	2300      	movs	r3, #0
 8003f5a:	f8c0 32b8 	str.w	r3, [r0, #696]	; 0x2b8
  pdev->pUserData[0] = NULL;
 8003f5e:	f8c0 32c4 	str.w	r3, [r0, #708]	; 0x2c4
#endif /* USE_USBD_COMPOSITE */

  pdev->pConfDesc = NULL;
 8003f62:	f8c0 32d0 	str.w	r3, [r0, #720]	; 0x2d0

  /* Assign USBD Descriptors */
  if (pdesc != NULL)
 8003f66:	b109      	cbz	r1, 8003f6c <USBD_Init+0x16>
  {
    pdev->pDesc = pdesc;
 8003f68:	f8c0 12b4 	str.w	r1, [r0, #692]	; 0x2b4
  }

  /* Set Device initial State */
  pdev->dev_state = USBD_STATE_DEFAULT;
 8003f6c:	2301      	movs	r3, #1
 8003f6e:	f880 329c 	strb.w	r3, [r0, #668]	; 0x29c
  pdev->id = id;
 8003f72:	7002      	strb	r2, [r0, #0]

  /* Initialize low level driver */
  ret = USBD_LL_Init(pdev);
 8003f74:	f7fc be3c 	b.w	8000bf0 <USBD_LL_Init>

  return ret;
}
 8003f78:	2003      	movs	r0, #3
 8003f7a:	4770      	bx	lr

08003f7c <USBD_RegisterClass>:
  * @param  pDevice : Device Handle
  * @param  pclass: Class handle
  * @retval USBD Status
  */
USBD_StatusTypeDef USBD_RegisterClass(USBD_HandleTypeDef *pdev, USBD_ClassTypeDef *pclass)
{
 8003f7c:	b513      	push	{r0, r1, r4, lr}
  uint16_t len = 0U;
 8003f7e:	2300      	movs	r3, #0
{
 8003f80:	4604      	mov	r4, r0
  uint16_t len = 0U;
 8003f82:	f8ad 3006 	strh.w	r3, [sp, #6]

  if (pclass == NULL)
 8003f86:	b181      	cbz	r1, 8003faa <USBD_RegisterClass+0x2e>
  if (pdev->pClass[pdev->classId]->GetHSConfigDescriptor != NULL)
  {
    pdev->pConfDesc = (void *)pdev->pClass[pdev->classId]->GetHSConfigDescriptor(&len);
  }
#else /* Default USE_USB_FS */
  if (pdev->pClass[pdev->classId]->GetFSConfigDescriptor != NULL)
 8003f88:	6acb      	ldr	r3, [r1, #44]	; 0x2c
  pdev->pClass[0] = pclass;
 8003f8a:	f8c0 12b8 	str.w	r1, [r0, #696]	; 0x2b8
  if (pdev->pClass[pdev->classId]->GetFSConfigDescriptor != NULL)
 8003f8e:	b123      	cbz	r3, 8003f9a <USBD_RegisterClass+0x1e>
  {
    pdev->pConfDesc = (void *)pdev->pClass[pdev->classId]->GetFSConfigDescriptor(&len);
 8003f90:	f10d 0006 	add.w	r0, sp, #6
 8003f94:	4798      	blx	r3
 8003f96:	f8c4 02d0 	str.w	r0, [r4, #720]	; 0x2d0
  }
#endif /* USE_USB_FS */

  /* Increment the NumClasses */
  pdev->NumClasses ++;
 8003f9a:	f8d4 32d8 	ldr.w	r3, [r4, #728]	; 0x2d8
 8003f9e:	3301      	adds	r3, #1
 8003fa0:	f8c4 32d8 	str.w	r3, [r4, #728]	; 0x2d8

  return USBD_OK;
 8003fa4:	2000      	movs	r0, #0
}
 8003fa6:	b002      	add	sp, #8
 8003fa8:	bd10      	pop	{r4, pc}
    return USBD_FAIL;
 8003faa:	2003      	movs	r0, #3
 8003fac:	e7fb      	b.n	8003fa6 <USBD_RegisterClass+0x2a>

08003fae <USBD_Start>:
#ifdef USE_USBD_COMPOSITE
  pdev->classId = 0U;
#endif /* USE_USBD_COMPOSITE */

  /* Start the low level driver  */
  return USBD_LL_Start(pdev);
 8003fae:	f7fc be4f 	b.w	8000c50 <USBD_LL_Start>

08003fb2 <USBD_SetClassConfig>:
        }
      }
    }
  }
#else
  if (pdev->pClass[0] != NULL)
 8003fb2:	f8d0 32b8 	ldr.w	r3, [r0, #696]	; 0x2b8
 8003fb6:	b10b      	cbz	r3, 8003fbc <USBD_SetClassConfig+0xa>
  {
    /* Set configuration and Start the Class */
    ret = (USBD_StatusTypeDef)pdev->pClass[0]->Init(pdev, cfgidx);
 8003fb8:	681b      	ldr	r3, [r3, #0]
 8003fba:	4718      	bx	r3
  }
#endif /* USE_USBD_COMPOSITE */

  return ret;
}
 8003fbc:	4618      	mov	r0, r3
 8003fbe:	4770      	bx	lr

08003fc0 <USBD_ClrClassConfig>:
  * @param  pdev: device instance
  * @param  cfgidx: configuration index
  * @retval status: USBD_StatusTypeDef
  */
USBD_StatusTypeDef USBD_ClrClassConfig(USBD_HandleTypeDef *pdev, uint8_t cfgidx)
{
 8003fc0:	b508      	push	{r3, lr}
      }
    }
  }
#else
  /* Clear configuration  and De-initialize the Class process */
  if (pdev->pClass[0]->DeInit(pdev, cfgidx) != 0U)
 8003fc2:	f8d0 32b8 	ldr.w	r3, [r0, #696]	; 0x2b8
 8003fc6:	685b      	ldr	r3, [r3, #4]
 8003fc8:	4798      	blx	r3
  {
    ret = USBD_FAIL;
 8003fca:	2800      	cmp	r0, #0
  }
#endif /* USE_USBD_COMPOSITE */

  return ret;
}
 8003fcc:	bf18      	it	ne
 8003fce:	2003      	movne	r0, #3
 8003fd0:	bd08      	pop	{r3, pc}

08003fd2 <USBD_LL_SetupStage>:
  *         Handle the setup stage
  * @param  pdev: device instance
  * @retval status
  */
USBD_StatusTypeDef USBD_LL_SetupStage(USBD_HandleTypeDef *pdev, uint8_t *psetup)
{
 8003fd2:	b538      	push	{r3, r4, r5, lr}
 8003fd4:	4604      	mov	r4, r0
  USBD_StatusTypeDef ret;

  USBD_ParseSetupRequest(&pdev->request, psetup);
 8003fd6:	f200 25aa 	addw	r5, r0, #682	; 0x2aa
 8003fda:	4628      	mov	r0, r5
 8003fdc:	f000 fb83 	bl	80046e6 <USBD_ParseSetupRequest>

  pdev->ep0_state = USBD_EP0_SETUP;
 8003fe0:	2301      	movs	r3, #1

  pdev->ep0_data_len = pdev->request.wLength;

  switch (pdev->request.bmRequest & 0x1FU)
 8003fe2:	f894 12aa 	ldrb.w	r1, [r4, #682]	; 0x2aa
  pdev->ep0_state = USBD_EP0_SETUP;
 8003fe6:	f8c4 3294 	str.w	r3, [r4, #660]	; 0x294
  pdev->ep0_data_len = pdev->request.wLength;
 8003fea:	f8b4 32b0 	ldrh.w	r3, [r4, #688]	; 0x2b0
 8003fee:	f8c4 3298 	str.w	r3, [r4, #664]	; 0x298
  switch (pdev->request.bmRequest & 0x1FU)
 8003ff2:	f001 031f 	and.w	r3, r1, #31
 8003ff6:	2b01      	cmp	r3, #1
 8003ff8:	d008      	beq.n	800400c <USBD_LL_SetupStage+0x3a>
 8003ffa:	2b02      	cmp	r3, #2
 8003ffc:	d00c      	beq.n	8004018 <USBD_LL_SetupStage+0x46>
 8003ffe:	b98b      	cbnz	r3, 8004024 <USBD_LL_SetupStage+0x52>
  {
    case USB_REQ_RECIPIENT_DEVICE:
      ret = USBD_StdDevReq(pdev, &pdev->request);
 8004000:	4629      	mov	r1, r5
 8004002:	4620      	mov	r0, r4
      ret = USBD_LL_StallEP(pdev, (pdev->request.bmRequest & 0x80U));
      break;
  }

  return ret;
}
 8004004:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
      ret = USBD_StdDevReq(pdev, &pdev->request);
 8004008:	f000 b94e 	b.w	80042a8 <USBD_StdDevReq>
      ret = USBD_StdItfReq(pdev, &pdev->request);
 800400c:	4629      	mov	r1, r5
 800400e:	4620      	mov	r0, r4
}
 8004010:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
      ret = USBD_StdItfReq(pdev, &pdev->request);
 8004014:	f000 ba9c 	b.w	8004550 <USBD_StdItfReq>
      ret = USBD_StdEPReq(pdev, &pdev->request);
 8004018:	4629      	mov	r1, r5
 800401a:	4620      	mov	r0, r4
}
 800401c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
      ret = USBD_StdEPReq(pdev, &pdev->request);
 8004020:	f000 bac5 	b.w	80045ae <USBD_StdEPReq>
      ret = USBD_LL_StallEP(pdev, (pdev->request.bmRequest & 0x80U));
 8004024:	4620      	mov	r0, r4
 8004026:	f001 0180 	and.w	r1, r1, #128	; 0x80
}
 800402a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
      ret = USBD_LL_StallEP(pdev, (pdev->request.bmRequest & 0x80U));
 800402e:	f7fc be27 	b.w	8000c80 <USBD_LL_StallEP>

08004032 <USBD_LL_DataOutStage>:
  * @param  pdata: data pointer
  * @retval status
  */
USBD_StatusTypeDef USBD_LL_DataOutStage(USBD_HandleTypeDef *pdev,
                                        uint8_t epnum, uint8_t *pdata)
{
 8004032:	b570      	push	{r4, r5, r6, lr}
 8004034:	4604      	mov	r4, r0
 8004036:	4616      	mov	r6, r2
  USBD_EndpointTypeDef *pep;
  USBD_StatusTypeDef ret = USBD_OK;
  uint8_t idx;

  if (epnum == 0U)
 8004038:	bb09      	cbnz	r1, 800407e <USBD_LL_DataOutStage+0x4c>
  {
    pep = &pdev->ep_out[0];

    if (pdev->ep0_state == USBD_EP0_DATA_OUT)
 800403a:	f8d0 3294 	ldr.w	r3, [r0, #660]	; 0x294
 800403e:	2b03      	cmp	r3, #3
 8004040:	d10c      	bne.n	800405c <USBD_LL_DataOutStage+0x2a>
    {
      if (pep->rem_length > pep->maxpacket)
 8004042:	e9d0 3257 	ldrd	r3, r2, [r0, #348]	; 0x15c
 8004046:	4293      	cmp	r3, r2
 8004048:	d90a      	bls.n	8004060 <USBD_LL_DataOutStage+0x2e>
      {
        pep->rem_length -= pep->maxpacket;
 800404a:	1a9b      	subs	r3, r3, r2

        (void)USBD_CtlContinueRx(pdev, pdata, MIN(pep->rem_length, pep->maxpacket));
 800404c:	429a      	cmp	r2, r3
        pep->rem_length -= pep->maxpacket;
 800404e:	f8c0 315c 	str.w	r3, [r0, #348]	; 0x15c
        (void)USBD_CtlContinueRx(pdev, pdata, MIN(pep->rem_length, pep->maxpacket));
 8004052:	bf28      	it	cs
 8004054:	461a      	movcs	r2, r3
 8004056:	4631      	mov	r1, r6
 8004058:	f000 fb99 	bl	800478e <USBD_CtlContinueRx>
      }
    }
  }

  return USBD_OK;
}
 800405c:	2000      	movs	r0, #0
 800405e:	bd70      	pop	{r4, r5, r6, pc}
          if (pdev->dev_state == USBD_STATE_CONFIGURED)
 8004060:	f890 329c 	ldrb.w	r3, [r0, #668]	; 0x29c
 8004064:	2b03      	cmp	r3, #3
 8004066:	d106      	bne.n	8004076 <USBD_LL_DataOutStage+0x44>
            if (pdev->pClass[idx]->EP0_RxReady != NULL)
 8004068:	f8d0 32b8 	ldr.w	r3, [r0, #696]	; 0x2b8
 800406c:	691b      	ldr	r3, [r3, #16]
 800406e:	b113      	cbz	r3, 8004076 <USBD_LL_DataOutStage+0x44>
              pdev->classId = idx;
 8004070:	f8c0 12d4 	str.w	r1, [r0, #724]	; 0x2d4
              pdev->pClass[idx]->EP0_RxReady(pdev);
 8004074:	4798      	blx	r3
        (void)USBD_CtlSendStatus(pdev);
 8004076:	4620      	mov	r0, r4
 8004078:	f000 fb91 	bl	800479e <USBD_CtlSendStatus>
 800407c:	e7ee      	b.n	800405c <USBD_LL_DataOutStage+0x2a>
      if (pdev->dev_state == USBD_STATE_CONFIGURED)
 800407e:	f890 329c 	ldrb.w	r3, [r0, #668]	; 0x29c
 8004082:	2b03      	cmp	r3, #3
 8004084:	d1ea      	bne.n	800405c <USBD_LL_DataOutStage+0x2a>
        if (pdev->pClass[idx]->DataOut != NULL)
 8004086:	f8d0 32b8 	ldr.w	r3, [r0, #696]	; 0x2b8
 800408a:	699b      	ldr	r3, [r3, #24]
 800408c:	2b00      	cmp	r3, #0
 800408e:	d0e5      	beq.n	800405c <USBD_LL_DataOutStage+0x2a>
          pdev->classId = idx;
 8004090:	2200      	movs	r2, #0
}
 8004092:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
          pdev->classId = idx;
 8004096:	f8c0 22d4 	str.w	r2, [r0, #724]	; 0x2d4
          ret = (USBD_StatusTypeDef)pdev->pClass[idx]->DataOut(pdev, epnum);
 800409a:	4718      	bx	r3

0800409c <USBD_LL_DataInStage>:
  * @param  epnum: endpoint index
  * @retval status
  */
USBD_StatusTypeDef USBD_LL_DataInStage(USBD_HandleTypeDef *pdev,
                                       uint8_t epnum, uint8_t *pdata)
{
 800409c:	b573      	push	{r0, r1, r4, r5, r6, lr}
 800409e:	4604      	mov	r4, r0
 80040a0:	4616      	mov	r6, r2
  USBD_EndpointTypeDef *pep;
  USBD_StatusTypeDef ret;
  uint8_t idx;

  if (epnum == 0U)
 80040a2:	2900      	cmp	r1, #0
 80040a4:	d141      	bne.n	800412a <USBD_LL_DataInStage+0x8e>
  {
    pep = &pdev->ep_in[0];

    if (pdev->ep0_state == USBD_EP0_DATA_IN)
 80040a6:	f8d0 2294 	ldr.w	r2, [r0, #660]	; 0x294
 80040aa:	2a02      	cmp	r2, #2
 80040ac:	d10f      	bne.n	80040ce <USBD_LL_DataInStage+0x32>
    {
      if (pep->rem_length > pep->maxpacket)
 80040ae:	e9d0 5207 	ldrd	r5, r2, [r0, #28]
 80040b2:	4295      	cmp	r5, r2
 80040b4:	d914      	bls.n	80040e0 <USBD_LL_DataInStage+0x44>
      {
        pep->rem_length -= pep->maxpacket;
 80040b6:	1aaa      	subs	r2, r5, r2
 80040b8:	9101      	str	r1, [sp, #4]
 80040ba:	61c2      	str	r2, [r0, #28]

        (void)USBD_CtlContinueSendData(pdev, pdata, pep->rem_length);
 80040bc:	4631      	mov	r1, r6
 80040be:	f000 fb51 	bl	8004764 <USBD_CtlContinueSendData>

        /* Prepare endpoint for premature end of transfer */
        (void)USBD_LL_PrepareReceive(pdev, 0U, NULL, 0U);
 80040c2:	9b01      	ldr	r3, [sp, #4]
        {
          (void)USBD_CtlContinueSendData(pdev, NULL, 0U);
          pdev->ep0_data_len = 0U;

          /* Prepare endpoint for premature end of transfer */
          (void)USBD_LL_PrepareReceive(pdev, 0U, NULL, 0U);
 80040c4:	461a      	mov	r2, r3
 80040c6:	4619      	mov	r1, r3
 80040c8:	4620      	mov	r0, r4
 80040ca:	f7fc fe08 	bl	8000cde <USBD_LL_PrepareReceive>
        (void)USBD_LL_StallEP(pdev, 0x80U);
      }
#endif
    }

    if (pdev->dev_test_mode != 0U)
 80040ce:	f894 32a0 	ldrb.w	r3, [r4, #672]	; 0x2a0
 80040d2:	b113      	cbz	r3, 80040da <USBD_LL_DataInStage+0x3e>
    {
      (void)USBD_RunTestMode(pdev);
      pdev->dev_test_mode = 0U;
 80040d4:	2300      	movs	r3, #0
 80040d6:	f884 32a0 	strb.w	r3, [r4, #672]	; 0x2a0
      }
    }
  }

  return USBD_OK;
}
 80040da:	2000      	movs	r0, #0
 80040dc:	b002      	add	sp, #8
 80040de:	bd70      	pop	{r4, r5, r6, pc}
        if ((pep->maxpacket == pep->rem_length) &&
 80040e0:	d10e      	bne.n	8004100 <USBD_LL_DataInStage+0x64>
            (pep->total_length >= pep->maxpacket) &&
 80040e2:	6982      	ldr	r2, [r0, #24]
        if ((pep->maxpacket == pep->rem_length) &&
 80040e4:	4295      	cmp	r5, r2
 80040e6:	d80b      	bhi.n	8004100 <USBD_LL_DataInStage+0x64>
            (pep->total_length >= pep->maxpacket) &&
 80040e8:	f8d0 5298 	ldr.w	r5, [r0, #664]	; 0x298
 80040ec:	42aa      	cmp	r2, r5
 80040ee:	d207      	bcs.n	8004100 <USBD_LL_DataInStage+0x64>
          (void)USBD_CtlContinueSendData(pdev, NULL, 0U);
 80040f0:	460a      	mov	r2, r1
 80040f2:	9101      	str	r1, [sp, #4]
 80040f4:	f000 fb36 	bl	8004764 <USBD_CtlContinueSendData>
          pdev->ep0_data_len = 0U;
 80040f8:	9b01      	ldr	r3, [sp, #4]
 80040fa:	f8c4 3298 	str.w	r3, [r4, #664]	; 0x298
 80040fe:	e7e1      	b.n	80040c4 <USBD_LL_DataInStage+0x28>
          if (pdev->dev_state == USBD_STATE_CONFIGURED)
 8004100:	f894 329c 	ldrb.w	r3, [r4, #668]	; 0x29c
 8004104:	2b03      	cmp	r3, #3
 8004106:	d108      	bne.n	800411a <USBD_LL_DataInStage+0x7e>
            if (pdev->pClass[0]->EP0_TxSent != NULL)
 8004108:	f8d4 32b8 	ldr.w	r3, [r4, #696]	; 0x2b8
 800410c:	68db      	ldr	r3, [r3, #12]
 800410e:	b123      	cbz	r3, 800411a <USBD_LL_DataInStage+0x7e>
              pdev->classId = 0U;
 8004110:	2200      	movs	r2, #0
 8004112:	f8c4 22d4 	str.w	r2, [r4, #724]	; 0x2d4
              pdev->pClass[0]->EP0_TxSent(pdev);
 8004116:	4620      	mov	r0, r4
 8004118:	4798      	blx	r3
          (void)USBD_LL_StallEP(pdev, 0x80U);
 800411a:	2180      	movs	r1, #128	; 0x80
 800411c:	4620      	mov	r0, r4
 800411e:	f7fc fdaf 	bl	8000c80 <USBD_LL_StallEP>
          (void)USBD_CtlReceiveStatus(pdev);
 8004122:	4620      	mov	r0, r4
 8004124:	f000 fb46 	bl	80047b4 <USBD_CtlReceiveStatus>
 8004128:	e7d1      	b.n	80040ce <USBD_LL_DataInStage+0x32>
      if (pdev->dev_state == USBD_STATE_CONFIGURED)
 800412a:	f890 329c 	ldrb.w	r3, [r0, #668]	; 0x29c
 800412e:	2b03      	cmp	r3, #3
 8004130:	d1d3      	bne.n	80040da <USBD_LL_DataInStage+0x3e>
        if (pdev->pClass[idx]->DataIn != NULL)
 8004132:	f8d0 32b8 	ldr.w	r3, [r0, #696]	; 0x2b8
 8004136:	695b      	ldr	r3, [r3, #20]
 8004138:	2b00      	cmp	r3, #0
 800413a:	d0ce      	beq.n	80040da <USBD_LL_DataInStage+0x3e>
          pdev->classId = idx;
 800413c:	2200      	movs	r2, #0
 800413e:	f8c0 22d4 	str.w	r2, [r0, #724]	; 0x2d4
}
 8004142:	b002      	add	sp, #8
 8004144:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
          ret = (USBD_StatusTypeDef)pdev->pClass[idx]->DataIn(pdev, epnum);
 8004148:	4718      	bx	r3

0800414a <USBD_LL_Reset>:
  * @param  pdev: device instance
  * @retval status
  */

USBD_StatusTypeDef USBD_LL_Reset(USBD_HandleTypeDef *pdev)
{
 800414a:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  USBD_StatusTypeDef ret = USBD_OK;

  /* Upon Reset call user call back */
  pdev->dev_state = USBD_STATE_DEFAULT;
 800414c:	2301      	movs	r3, #1
 800414e:	f880 329c 	strb.w	r3, [r0, #668]	; 0x29c
      }
    }
  }
#else

  if (pdev->pClass[0] != NULL)
 8004152:	f8d0 32b8 	ldr.w	r3, [r0, #696]	; 0x2b8
  pdev->ep0_state = USBD_EP0_IDLE;
 8004156:	2100      	movs	r1, #0
{
 8004158:	4604      	mov	r4, r0
  pdev->ep0_state = USBD_EP0_IDLE;
 800415a:	f8c0 1294 	str.w	r1, [r0, #660]	; 0x294
  pdev->dev_config = 0U;
 800415e:	6041      	str	r1, [r0, #4]
  pdev->dev_remote_wakeup = 0U;
 8004160:	f8c0 12a4 	str.w	r1, [r0, #676]	; 0x2a4
  pdev->dev_test_mode = 0U;
 8004164:	f880 12a0 	strb.w	r1, [r0, #672]	; 0x2a0
  if (pdev->pClass[0] != NULL)
 8004168:	b9b3      	cbnz	r3, 8004198 <USBD_LL_Reset+0x4e>
  USBD_StatusTypeDef ret = USBD_OK;
 800416a:	2600      	movs	r6, #0
    }
  }
#endif /* USE_USBD_COMPOSITE */

  /* Open EP0 OUT */
  (void)USBD_LL_OpenEP(pdev, 0x00U, USBD_EP_TYPE_CTRL, USB_MAX_EP0_SIZE);
 800416c:	2200      	movs	r2, #0
  pdev->ep_out[0x00U & 0xFU].is_used = 1U;

  pdev->ep_out[0].maxpacket = USB_MAX_EP0_SIZE;
 800416e:	2540      	movs	r5, #64	; 0x40
  (void)USBD_LL_OpenEP(pdev, 0x00U, USBD_EP_TYPE_CTRL, USB_MAX_EP0_SIZE);
 8004170:	4611      	mov	r1, r2
  pdev->ep_out[0x00U & 0xFU].is_used = 1U;
 8004172:	2701      	movs	r7, #1
  (void)USBD_LL_OpenEP(pdev, 0x00U, USBD_EP_TYPE_CTRL, USB_MAX_EP0_SIZE);
 8004174:	2340      	movs	r3, #64	; 0x40
 8004176:	4620      	mov	r0, r4
 8004178:	f7fc fd71 	bl	8000c5e <USBD_LL_OpenEP>
  pdev->ep_out[0x00U & 0xFU].is_used = 1U;
 800417c:	f8a4 7164 	strh.w	r7, [r4, #356]	; 0x164
  pdev->ep_out[0].maxpacket = USB_MAX_EP0_SIZE;
 8004180:	f8c4 5160 	str.w	r5, [r4, #352]	; 0x160

  /* Open EP0 IN */
  (void)USBD_LL_OpenEP(pdev, 0x80U, USBD_EP_TYPE_CTRL, USB_MAX_EP0_SIZE);
 8004184:	462b      	mov	r3, r5
 8004186:	2200      	movs	r2, #0
 8004188:	2180      	movs	r1, #128	; 0x80
 800418a:	4620      	mov	r0, r4
 800418c:	f7fc fd67 	bl	8000c5e <USBD_LL_OpenEP>
  pdev->ep_in[0x80U & 0xFU].is_used = 1U;
 8004190:	84a7      	strh	r7, [r4, #36]	; 0x24

  pdev->ep_in[0].maxpacket = USB_MAX_EP0_SIZE;
 8004192:	6225      	str	r5, [r4, #32]

  return ret;
}
 8004194:	4630      	mov	r0, r6
 8004196:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    if (pdev->pClass[0]->DeInit != NULL)
 8004198:	685b      	ldr	r3, [r3, #4]
 800419a:	2b00      	cmp	r3, #0
 800419c:	d0e5      	beq.n	800416a <USBD_LL_Reset+0x20>
      if (pdev->pClass[0]->DeInit(pdev, (uint8_t)pdev->dev_config) != USBD_OK)
 800419e:	4798      	blx	r3
 80041a0:	2800      	cmp	r0, #0
 80041a2:	d0e2      	beq.n	800416a <USBD_LL_Reset+0x20>
        ret = USBD_FAIL;
 80041a4:	2603      	movs	r6, #3
 80041a6:	e7e1      	b.n	800416c <USBD_LL_Reset+0x22>

080041a8 <USBD_LL_SetSpeed>:
  * @retval status
  */
USBD_StatusTypeDef USBD_LL_SetSpeed(USBD_HandleTypeDef *pdev,
                                    USBD_SpeedTypeDef speed)
{
  pdev->dev_speed = speed;
 80041a8:	7401      	strb	r1, [r0, #16]

  return USBD_OK;
}
 80041aa:	2000      	movs	r0, #0
 80041ac:	4770      	bx	lr

080041ae <USBD_LL_Suspend>:
  * @retval status
  */

USBD_StatusTypeDef USBD_LL_Suspend(USBD_HandleTypeDef *pdev)
{
  pdev->dev_old_state = pdev->dev_state;
 80041ae:	f890 329c 	ldrb.w	r3, [r0, #668]	; 0x29c
 80041b2:	b2db      	uxtb	r3, r3
 80041b4:	f880 329d 	strb.w	r3, [r0, #669]	; 0x29d
  pdev->dev_state = USBD_STATE_SUSPENDED;
 80041b8:	2304      	movs	r3, #4
 80041ba:	f880 329c 	strb.w	r3, [r0, #668]	; 0x29c

  return USBD_OK;
}
 80041be:	2000      	movs	r0, #0
 80041c0:	4770      	bx	lr

080041c2 <USBD_LL_Resume>:
  * @retval status
  */

USBD_StatusTypeDef USBD_LL_Resume(USBD_HandleTypeDef *pdev)
{
  if (pdev->dev_state == USBD_STATE_SUSPENDED)
 80041c2:	f890 329c 	ldrb.w	r3, [r0, #668]	; 0x29c
 80041c6:	2b04      	cmp	r3, #4
  {
    pdev->dev_state = pdev->dev_old_state;
 80041c8:	bf02      	ittt	eq
 80041ca:	f890 329d 	ldrbeq.w	r3, [r0, #669]	; 0x29d
 80041ce:	b2db      	uxtbeq	r3, r3
 80041d0:	f880 329c 	strbeq.w	r3, [r0, #668]	; 0x29c
  }

  return USBD_OK;
}
 80041d4:	2000      	movs	r0, #0
 80041d6:	4770      	bx	lr

080041d8 <USBD_LL_SOF>:
  * @param  pdev: device instance
  * @retval status
  */

USBD_StatusTypeDef USBD_LL_SOF(USBD_HandleTypeDef *pdev)
{
 80041d8:	b508      	push	{r3, lr}
  /* The SOF event can be distributed for all classes that support it */
  if (pdev->dev_state == USBD_STATE_CONFIGURED)
 80041da:	f890 229c 	ldrb.w	r2, [r0, #668]	; 0x29c
 80041de:	2a03      	cmp	r2, #3
 80041e0:	d105      	bne.n	80041ee <USBD_LL_SOF+0x16>
          }
        }
      }
    }
#else
    if (pdev->pClass[0] != NULL)
 80041e2:	f8d0 32b8 	ldr.w	r3, [r0, #696]	; 0x2b8
 80041e6:	b113      	cbz	r3, 80041ee <USBD_LL_SOF+0x16>
    {
      if (pdev->pClass[0]->SOF != NULL)
 80041e8:	69db      	ldr	r3, [r3, #28]
 80041ea:	b103      	cbz	r3, 80041ee <USBD_LL_SOF+0x16>
      {
        (void)pdev->pClass[0]->SOF(pdev);
 80041ec:	4798      	blx	r3
    }
#endif /* USE_USBD_COMPOSITE */
  }

  return USBD_OK;
}
 80041ee:	2000      	movs	r0, #0
 80041f0:	bd08      	pop	{r3, pc}

080041f2 <USBD_LL_IsoINIncomplete>:
  * @retval status
  */
USBD_StatusTypeDef USBD_LL_IsoINIncomplete(USBD_HandleTypeDef *pdev,
                                           uint8_t epnum)
{
  if (pdev->pClass[pdev->classId] == NULL)
 80041f2:	f8d0 22d4 	ldr.w	r2, [r0, #724]	; 0x2d4
 80041f6:	32ae      	adds	r2, #174	; 0xae
{
 80041f8:	b508      	push	{r3, lr}
  if (pdev->pClass[pdev->classId] == NULL)
 80041fa:	f850 2022 	ldr.w	r2, [r0, r2, lsl #2]
 80041fe:	b142      	cbz	r2, 8004212 <USBD_LL_IsoINIncomplete+0x20>
  {
    return USBD_FAIL;
  }

  if (pdev->dev_state == USBD_STATE_CONFIGURED)
 8004200:	f890 329c 	ldrb.w	r3, [r0, #668]	; 0x29c
 8004204:	2b03      	cmp	r3, #3
 8004206:	d102      	bne.n	800420e <USBD_LL_IsoINIncomplete+0x1c>
  {
    if (pdev->pClass[pdev->classId]->IsoINIncomplete != NULL)
 8004208:	6a13      	ldr	r3, [r2, #32]
 800420a:	b123      	cbz	r3, 8004216 <USBD_LL_IsoINIncomplete+0x24>
    {
      (void)pdev->pClass[pdev->classId]->IsoINIncomplete(pdev, epnum);
 800420c:	4798      	blx	r3
    }
  }

  return USBD_OK;
 800420e:	2000      	movs	r0, #0
 8004210:	e000      	b.n	8004214 <USBD_LL_IsoINIncomplete+0x22>
    return USBD_FAIL;
 8004212:	2003      	movs	r0, #3
}
 8004214:	bd08      	pop	{r3, pc}
  return USBD_OK;
 8004216:	4618      	mov	r0, r3
 8004218:	e7fc      	b.n	8004214 <USBD_LL_IsoINIncomplete+0x22>

0800421a <USBD_LL_IsoOUTIncomplete>:
  * @retval status
  */
USBD_StatusTypeDef USBD_LL_IsoOUTIncomplete(USBD_HandleTypeDef *pdev,
                                            uint8_t epnum)
{
  if (pdev->pClass[pdev->classId] == NULL)
 800421a:	f8d0 22d4 	ldr.w	r2, [r0, #724]	; 0x2d4
 800421e:	32ae      	adds	r2, #174	; 0xae
{
 8004220:	b508      	push	{r3, lr}
  if (pdev->pClass[pdev->classId] == NULL)
 8004222:	f850 2022 	ldr.w	r2, [r0, r2, lsl #2]
 8004226:	b142      	cbz	r2, 800423a <USBD_LL_IsoOUTIncomplete+0x20>
  {
    return USBD_FAIL;
  }

  if (pdev->dev_state == USBD_STATE_CONFIGURED)
 8004228:	f890 329c 	ldrb.w	r3, [r0, #668]	; 0x29c
 800422c:	2b03      	cmp	r3, #3
 800422e:	d102      	bne.n	8004236 <USBD_LL_IsoOUTIncomplete+0x1c>
  {
    if (pdev->pClass[pdev->classId]->IsoOUTIncomplete != NULL)
 8004230:	6a53      	ldr	r3, [r2, #36]	; 0x24
 8004232:	b123      	cbz	r3, 800423e <USBD_LL_IsoOUTIncomplete+0x24>
    {
      (void)pdev->pClass[pdev->classId]->IsoOUTIncomplete(pdev, epnum);
 8004234:	4798      	blx	r3
    }
  }

  return USBD_OK;
 8004236:	2000      	movs	r0, #0
 8004238:	e000      	b.n	800423c <USBD_LL_IsoOUTIncomplete+0x22>
    return USBD_FAIL;
 800423a:	2003      	movs	r0, #3
}
 800423c:	bd08      	pop	{r3, pc}
  return USBD_OK;
 800423e:	4618      	mov	r0, r3
 8004240:	e7fc      	b.n	800423c <USBD_LL_IsoOUTIncomplete+0x22>

08004242 <USBD_LL_DevConnected>:
 8004242:	2000      	movs	r0, #0
 8004244:	4770      	bx	lr

08004246 <USBD_LL_DevDisconnected>:
USBD_StatusTypeDef USBD_LL_DevDisconnected(USBD_HandleTypeDef *pdev)
{
  USBD_StatusTypeDef   ret = USBD_OK;

  /* Free Class Resources */
  pdev->dev_state = USBD_STATE_DEFAULT;
 8004246:	2201      	movs	r2, #1
{
 8004248:	b508      	push	{r3, lr}
  pdev->dev_state = USBD_STATE_DEFAULT;
 800424a:	f880 229c 	strb.w	r2, [r0, #668]	; 0x29c
        }
      }
    }
  }
#else
  if (pdev->pClass[0] != NULL)
 800424e:	f8d0 22b8 	ldr.w	r2, [r0, #696]	; 0x2b8
 8004252:	b90a      	cbnz	r2, 8004258 <USBD_LL_DevDisconnected+0x12>
  USBD_StatusTypeDef   ret = USBD_OK;
 8004254:	2000      	movs	r0, #0
    }
  }
#endif /* USE_USBD_COMPOSITE */

  return ret;
}
 8004256:	bd08      	pop	{r3, pc}
    if (pdev->pClass[0]->DeInit(pdev, (uint8_t)pdev->dev_config) != 0U)
 8004258:	6852      	ldr	r2, [r2, #4]
 800425a:	7901      	ldrb	r1, [r0, #4]
 800425c:	4790      	blx	r2
 800425e:	2800      	cmp	r0, #0
 8004260:	d0f8      	beq.n	8004254 <USBD_LL_DevDisconnected+0xe>
      ret = USBD_FAIL;
 8004262:	2003      	movs	r0, #3
 8004264:	e7f7      	b.n	8004256 <USBD_LL_DevDisconnected+0x10>

08004266 <USBD_CoreFindIF>:
  UNUSED(pdev);
  UNUSED(index);

  return 0x00U;
#endif /* USE_USBD_COMPOSITE */
}
 8004266:	2000      	movs	r0, #0
 8004268:	4770      	bx	lr

0800426a <USBD_CoreFindEP>:
 800426a:	2000      	movs	r0, #0
 800426c:	4770      	bx	lr

0800426e <USBD_GetEpDesc>:
  * @param  pConfDesc:  pointer to Bos descriptor
  * @param  EpAddr:  endpoint address
  * @retval pointer to video endpoint descriptor
  */
void *USBD_GetEpDesc(uint8_t *pConfDesc, uint8_t EpAddr)
{
 800426e:	b510      	push	{r4, lr}
  USBD_DescHeaderTypeDef *pdesc = (USBD_DescHeaderTypeDef *)(void *)pConfDesc;
  USBD_ConfigDescTypeDef *desc = (USBD_ConfigDescTypeDef *)(void *)pConfDesc;
  USBD_EpDescTypeDef *pEpDesc = NULL;
  uint16_t ptr;

  if (desc->wTotalLength > desc->bLength)
 8004270:	8842      	ldrh	r2, [r0, #2]
 8004272:	7803      	ldrb	r3, [r0, #0]
 8004274:	429a      	cmp	r2, r3
 8004276:	d90a      	bls.n	800428e <USBD_GetEpDesc+0x20>
  */
USBD_DescHeaderTypeDef *USBD_GetNextDesc(uint8_t *pbuf, uint16_t *ptr)
{
  USBD_DescHeaderTypeDef *pnext = (USBD_DescHeaderTypeDef *)(void *)pbuf;

  *ptr += pnext->bLength;
 8004278:	7804      	ldrb	r4, [r0, #0]
  pnext = (USBD_DescHeaderTypeDef *)(void *)(pbuf + pnext->bLength);
 800427a:	4420      	add	r0, r4
  *ptr += pnext->bLength;
 800427c:	4423      	add	r3, r4
      if (pdesc->bDescriptorType == USB_DESC_TYPE_ENDPOINT)
 800427e:	7844      	ldrb	r4, [r0, #1]
 8004280:	2c05      	cmp	r4, #5
  *ptr += pnext->bLength;
 8004282:	b29b      	uxth	r3, r3
      if (pdesc->bDescriptorType == USB_DESC_TYPE_ENDPOINT)
 8004284:	d1f6      	bne.n	8004274 <USBD_GetEpDesc+0x6>
        if (pEpDesc->bEndpointAddress == EpAddr)
 8004286:	7884      	ldrb	r4, [r0, #2]
 8004288:	428c      	cmp	r4, r1
 800428a:	d1f3      	bne.n	8004274 <USBD_GetEpDesc+0x6>
}
 800428c:	bd10      	pop	{r4, pc}
  USBD_EpDescTypeDef *pEpDesc = NULL;
 800428e:	2000      	movs	r0, #0
 8004290:	e7fc      	b.n	800428c <USBD_GetEpDesc+0x1e>

08004292 <USBD_CtlError.constprop.0>:
  *         Handle USB low level Error
  * @param  pdev: device instance
  * @param  req: usb request
  * @retval None
  */
void USBD_CtlError(USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req)
 8004292:	b510      	push	{r4, lr}
{
  UNUSED(req);

  (void)USBD_LL_StallEP(pdev, 0x80U);
 8004294:	2180      	movs	r1, #128	; 0x80
void USBD_CtlError(USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req)
 8004296:	4604      	mov	r4, r0
  (void)USBD_LL_StallEP(pdev, 0x80U);
 8004298:	f7fc fcf2 	bl	8000c80 <USBD_LL_StallEP>
  (void)USBD_LL_StallEP(pdev, 0U);
 800429c:	4620      	mov	r0, r4
 800429e:	2100      	movs	r1, #0
}
 80042a0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  (void)USBD_LL_StallEP(pdev, 0U);
 80042a4:	f7fc bcec 	b.w	8000c80 <USBD_LL_StallEP>

080042a8 <USBD_StdDevReq>:
{
 80042a8:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
 80042ac:	780d      	ldrb	r5, [r1, #0]
 80042ae:	f005 0560 	and.w	r5, r5, #96	; 0x60
  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 80042b2:	2d20      	cmp	r5, #32
{
 80042b4:	4604      	mov	r4, r0
 80042b6:	460e      	mov	r6, r1
  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 80042b8:	d014      	beq.n	80042e4 <USBD_StdDevReq+0x3c>
 80042ba:	2d40      	cmp	r5, #64	; 0x40
 80042bc:	d012      	beq.n	80042e4 <USBD_StdDevReq+0x3c>
 80042be:	2d00      	cmp	r5, #0
 80042c0:	f040 810a 	bne.w	80044d8 <USBD_StdDevReq+0x230>
      switch (req->bRequest)
 80042c4:	784f      	ldrb	r7, [r1, #1]
 80042c6:	2f09      	cmp	r7, #9
 80042c8:	f200 8106 	bhi.w	80044d8 <USBD_StdDevReq+0x230>
 80042cc:	e8df f017 	tbh	[pc, r7, lsl #1]
 80042d0:	0132010b 	.word	0x0132010b
 80042d4:	01210104 	.word	0x01210104
 80042d8:	00860104 	.word	0x00860104
 80042dc:	01040016 	.word	0x01040016
 80042e0:	00a200f3 	.word	0x00a200f3
      ret = (USBD_StatusTypeDef)pdev->pClass[pdev->classId]->Setup(pdev, req);
 80042e4:	f8d4 32d4 	ldr.w	r3, [r4, #724]	; 0x2d4
 80042e8:	33ae      	adds	r3, #174	; 0xae
 80042ea:	4631      	mov	r1, r6
 80042ec:	f854 3023 	ldr.w	r3, [r4, r3, lsl #2]
 80042f0:	689b      	ldr	r3, [r3, #8]
 80042f2:	4620      	mov	r0, r4
}
 80042f4:	b002      	add	sp, #8
 80042f6:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
      ret = (USBD_StatusTypeDef)pdev->pClass[pdev->classId]->Setup(pdev, req);
 80042fa:	4718      	bx	r3
  uint16_t len = 0U;
 80042fc:	2300      	movs	r3, #0
 80042fe:	f8ad 3006 	strh.w	r3, [sp, #6]
  switch (req->wValue >> 8)
 8004302:	884b      	ldrh	r3, [r1, #2]
 8004304:	0a1a      	lsrs	r2, r3, #8
 8004306:	3a01      	subs	r2, #1
 8004308:	2a06      	cmp	r2, #6
 800430a:	d837      	bhi.n	800437c <USBD_StdDevReq+0xd4>
 800430c:	e8df f002 	tbb	[pc, r2]
 8004310:	36291c04 	.word	0x36291c04
 8004314:	5136      	.short	0x5136
 8004316:	5b          	.byte	0x5b
 8004317:	00          	.byte	0x00
      pbuf = pdev->pDesc->GetDeviceDescriptor(pdev->dev_speed, &len);
 8004318:	f8d0 32b4 	ldr.w	r3, [r0, #692]	; 0x2b4
 800431c:	681b      	ldr	r3, [r3, #0]
            pbuf = pdev->pDesc->GetInterfaceStrDescriptor(pdev->dev_speed, &len);
 800431e:	7c20      	ldrb	r0, [r4, #16]
 8004320:	f10d 0106 	add.w	r1, sp, #6
 8004324:	4798      	blx	r3
  if (req->wLength != 0U)
 8004326:	88f2      	ldrh	r2, [r6, #6]
 8004328:	2a00      	cmp	r2, #0
 800432a:	f000 80ff 	beq.w	800452c <USBD_StdDevReq+0x284>
    if (len != 0U)
 800432e:	f8bd 3006 	ldrh.w	r3, [sp, #6]
 8004332:	b31b      	cbz	r3, 800437c <USBD_StdDevReq+0xd4>
      len = MIN(len, req->wLength);
 8004334:	429a      	cmp	r2, r3
 8004336:	bf28      	it	cs
 8004338:	461a      	movcs	r2, r3
 800433a:	f8ad 2006 	strh.w	r2, [sp, #6]
      (void)USBD_CtlSendData(pdev, pbuf, len);
 800433e:	4601      	mov	r1, r0
        (void)USBD_CtlSendData(pdev, (uint8_t *)&pdev->dev_config, 1U);
 8004340:	4620      	mov	r0, r4
 8004342:	f000 fa02 	bl	800474a <USBD_CtlSendData>
        break;
 8004346:	e01c      	b.n	8004382 <USBD_StdDevReq+0xda>
      if (pdev->dev_speed == USBD_SPEED_HIGH)
 8004348:	7c02      	ldrb	r2, [r0, #16]
          pbuf = (uint8_t *)pdev->pClass[0]->GetHSConfigDescriptor(&len);
 800434a:	f8d0 32b8 	ldr.w	r3, [r0, #696]	; 0x2b8
      if (pdev->dev_speed == USBD_SPEED_HIGH)
 800434e:	b932      	cbnz	r2, 800435e <USBD_StdDevReq+0xb6>
          pbuf = (uint8_t *)pdev->pClass[0]->GetHSConfigDescriptor(&len);
 8004350:	6a9b      	ldr	r3, [r3, #40]	; 0x28
          pbuf   = (uint8_t *)pdev->pClass[0]->GetFSConfigDescriptor(&len);
 8004352:	f10d 0006 	add.w	r0, sp, #6
 8004356:	4798      	blx	r3
        pbuf[1] = USB_DESC_TYPE_CONFIGURATION;
 8004358:	2302      	movs	r3, #2
        pbuf[1] = USB_DESC_TYPE_OTHER_SPEED_CONFIGURATION;
 800435a:	7043      	strb	r3, [r0, #1]
  if (err != 0U)
 800435c:	e7e3      	b.n	8004326 <USBD_StdDevReq+0x7e>
          pbuf   = (uint8_t *)pdev->pClass[0]->GetFSConfigDescriptor(&len);
 800435e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8004360:	e7f7      	b.n	8004352 <USBD_StdDevReq+0xaa>
      switch ((uint8_t)(req->wValue))
 8004362:	b2db      	uxtb	r3, r3
 8004364:	2b05      	cmp	r3, #5
 8004366:	d809      	bhi.n	800437c <USBD_StdDevReq+0xd4>
 8004368:	e8df f003 	tbb	[pc, r3]
 800436c:	17130f03 	.word	0x17130f03
 8004370:	1f1b      	.short	0x1f1b
          if (pdev->pDesc->GetLangIDStrDescriptor != NULL)
 8004372:	f8d0 32b4 	ldr.w	r3, [r0, #692]	; 0x2b4
 8004376:	685b      	ldr	r3, [r3, #4]
          if (pdev->pDesc->GetInterfaceStrDescriptor != NULL)
 8004378:	2b00      	cmp	r3, #0
 800437a:	d1d0      	bne.n	800431e <USBD_StdDevReq+0x76>
      USBD_CtlError(pdev, req);
 800437c:	4620      	mov	r0, r4
 800437e:	f7ff ff88 	bl	8004292 <USBD_CtlError.constprop.0>
}
 8004382:	4628      	mov	r0, r5
 8004384:	b002      	add	sp, #8
 8004386:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
          if (pdev->pDesc->GetManufacturerStrDescriptor != NULL)
 800438a:	f8d0 32b4 	ldr.w	r3, [r0, #692]	; 0x2b4
 800438e:	689b      	ldr	r3, [r3, #8]
 8004390:	e7f2      	b.n	8004378 <USBD_StdDevReq+0xd0>
          if (pdev->pDesc->GetProductStrDescriptor != NULL)
 8004392:	f8d0 32b4 	ldr.w	r3, [r0, #692]	; 0x2b4
 8004396:	68db      	ldr	r3, [r3, #12]
 8004398:	e7ee      	b.n	8004378 <USBD_StdDevReq+0xd0>
          if (pdev->pDesc->GetSerialStrDescriptor != NULL)
 800439a:	f8d0 32b4 	ldr.w	r3, [r0, #692]	; 0x2b4
 800439e:	691b      	ldr	r3, [r3, #16]
 80043a0:	e7ea      	b.n	8004378 <USBD_StdDevReq+0xd0>
          if (pdev->pDesc->GetConfigurationStrDescriptor != NULL)
 80043a2:	f8d0 32b4 	ldr.w	r3, [r0, #692]	; 0x2b4
 80043a6:	695b      	ldr	r3, [r3, #20]
 80043a8:	e7e6      	b.n	8004378 <USBD_StdDevReq+0xd0>
          if (pdev->pDesc->GetInterfaceStrDescriptor != NULL)
 80043aa:	f8d0 32b4 	ldr.w	r3, [r0, #692]	; 0x2b4
 80043ae:	699b      	ldr	r3, [r3, #24]
 80043b0:	e7e2      	b.n	8004378 <USBD_StdDevReq+0xd0>
      if (pdev->dev_speed == USBD_SPEED_HIGH)
 80043b2:	7c03      	ldrb	r3, [r0, #16]
 80043b4:	2b00      	cmp	r3, #0
 80043b6:	d1e1      	bne.n	800437c <USBD_StdDevReq+0xd4>
          pbuf = (uint8_t *)pdev->pClass[0]->GetDeviceQualifierDescriptor(&len);
 80043b8:	f8d0 32b8 	ldr.w	r3, [r0, #696]	; 0x2b8
 80043bc:	f10d 0006 	add.w	r0, sp, #6
 80043c0:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80043c2:	4798      	blx	r3
  if (err != 0U)
 80043c4:	e7af      	b.n	8004326 <USBD_StdDevReq+0x7e>
      if (pdev->dev_speed == USBD_SPEED_HIGH)
 80043c6:	7c03      	ldrb	r3, [r0, #16]
 80043c8:	2b00      	cmp	r3, #0
 80043ca:	d1d7      	bne.n	800437c <USBD_StdDevReq+0xd4>
          pbuf = (uint8_t *)pdev->pClass[0]->GetOtherSpeedConfigDescriptor(&len);
 80043cc:	f8d0 32b8 	ldr.w	r3, [r0, #696]	; 0x2b8
 80043d0:	f10d 0006 	add.w	r0, sp, #6
 80043d4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80043d6:	4798      	blx	r3
        pbuf[1] = USB_DESC_TYPE_OTHER_SPEED_CONFIGURATION;
 80043d8:	2307      	movs	r3, #7
 80043da:	e7be      	b.n	800435a <USBD_StdDevReq+0xb2>
  if ((req->wIndex == 0U) && (req->wLength == 0U) && (req->wValue < 128U))
 80043dc:	888b      	ldrh	r3, [r1, #4]
 80043de:	2b00      	cmp	r3, #0
 80043e0:	d1cc      	bne.n	800437c <USBD_StdDevReq+0xd4>
 80043e2:	88cb      	ldrh	r3, [r1, #6]
 80043e4:	2b00      	cmp	r3, #0
 80043e6:	d1c9      	bne.n	800437c <USBD_StdDevReq+0xd4>
 80043e8:	884e      	ldrh	r6, [r1, #2]
 80043ea:	2e7f      	cmp	r6, #127	; 0x7f
 80043ec:	d8c6      	bhi.n	800437c <USBD_StdDevReq+0xd4>
    if (pdev->dev_state == USBD_STATE_CONFIGURED)
 80043ee:	f890 329c 	ldrb.w	r3, [r0, #668]	; 0x29c
 80043f2:	2b03      	cmp	r3, #3
 80043f4:	d0c2      	beq.n	800437c <USBD_StdDevReq+0xd4>
    dev_addr = (uint8_t)(req->wValue) & 0x7FU;
 80043f6:	b2f1      	uxtb	r1, r6
      pdev->dev_address = dev_addr;
 80043f8:	f880 129e 	strb.w	r1, [r0, #670]	; 0x29e
      (void)USBD_LL_SetUSBAddress(pdev, dev_addr);
 80043fc:	f7fc fc61 	bl	8000cc2 <USBD_LL_SetUSBAddress>
      (void)USBD_CtlSendStatus(pdev);
 8004400:	4620      	mov	r0, r4
 8004402:	f000 f9cc 	bl	800479e <USBD_CtlSendStatus>
      if (dev_addr != 0U)
 8004406:	b11e      	cbz	r6, 8004410 <USBD_StdDevReq+0x168>
        pdev->dev_state = USBD_STATE_ADDRESSED;
 8004408:	2302      	movs	r3, #2
          pdev->dev_state = USBD_STATE_CONFIGURED;
 800440a:	f884 329c 	strb.w	r3, [r4, #668]	; 0x29c
 800440e:	e7b8      	b.n	8004382 <USBD_StdDevReq+0xda>
        pdev->dev_state = USBD_STATE_DEFAULT;
 8004410:	2301      	movs	r3, #1
 8004412:	e7fa      	b.n	800440a <USBD_StdDevReq+0x162>
  cfgidx = (uint8_t)(req->wValue);
 8004414:	788e      	ldrb	r6, [r1, #2]
 8004416:	4f4d      	ldr	r7, [pc, #308]	; (800454c <USBD_StdDevReq+0x2a4>)
  if (cfgidx > USBD_MAX_NUM_CONFIGURATION)
 8004418:	2e01      	cmp	r6, #1
  cfgidx = (uint8_t)(req->wValue);
 800441a:	703e      	strb	r6, [r7, #0]
  if (cfgidx > USBD_MAX_NUM_CONFIGURATION)
 800441c:	d903      	bls.n	8004426 <USBD_StdDevReq+0x17e>
    USBD_CtlError(pdev, req);
 800441e:	f7ff ff38 	bl	8004292 <USBD_CtlError.constprop.0>
      ret = USBD_FAIL;
 8004422:	2503      	movs	r5, #3
      break;
 8004424:	e7ad      	b.n	8004382 <USBD_StdDevReq+0xda>
  switch (pdev->dev_state)
 8004426:	f890 329c 	ldrb.w	r3, [r0, #668]	; 0x29c
 800442a:	2b02      	cmp	r3, #2
 800442c:	fa5f f883 	uxtb.w	r8, r3
 8004430:	d009      	beq.n	8004446 <USBD_StdDevReq+0x19e>
 8004432:	f1b8 0f03 	cmp.w	r8, #3
 8004436:	d018      	beq.n	800446a <USBD_StdDevReq+0x1c2>
      USBD_CtlError(pdev, req);
 8004438:	f7ff ff2b 	bl	8004292 <USBD_CtlError.constprop.0>
      (void)USBD_ClrClassConfig(pdev, cfgidx);
 800443c:	7839      	ldrb	r1, [r7, #0]
 800443e:	4620      	mov	r0, r4
 8004440:	f7ff fdbe 	bl	8003fc0 <USBD_ClrClassConfig>
 8004444:	e7ed      	b.n	8004422 <USBD_StdDevReq+0x17a>
      if (cfgidx != 0U)
 8004446:	2e00      	cmp	r6, #0
 8004448:	d070      	beq.n	800452c <USBD_StdDevReq+0x284>
        pdev->dev_config = cfgidx;
 800444a:	2101      	movs	r1, #1
 800444c:	6041      	str	r1, [r0, #4]
        ret = USBD_SetClassConfig(pdev, cfgidx);
 800444e:	f7ff fdb0 	bl	8003fb2 <USBD_SetClassConfig>
        if (ret != USBD_OK)
 8004452:	4605      	mov	r5, r0
          USBD_CtlError(pdev, req);
 8004454:	4620      	mov	r0, r4
        if (ret != USBD_OK)
 8004456:	b125      	cbz	r5, 8004462 <USBD_StdDevReq+0x1ba>
          USBD_CtlError(pdev, req);
 8004458:	f7ff ff1b 	bl	8004292 <USBD_CtlError.constprop.0>
          pdev->dev_state = USBD_STATE_ADDRESSED;
 800445c:	f884 829c 	strb.w	r8, [r4, #668]	; 0x29c
 8004460:	e78f      	b.n	8004382 <USBD_StdDevReq+0xda>
          (void)USBD_CtlSendStatus(pdev);
 8004462:	f000 f99c 	bl	800479e <USBD_CtlSendStatus>
          pdev->dev_state = USBD_STATE_CONFIGURED;
 8004466:	2303      	movs	r3, #3
 8004468:	e7cf      	b.n	800440a <USBD_StdDevReq+0x162>
      if (cfgidx == 0U)
 800446a:	b95e      	cbnz	r6, 8004484 <USBD_StdDevReq+0x1dc>
        pdev->dev_state = USBD_STATE_ADDRESSED;
 800446c:	2302      	movs	r3, #2
 800446e:	f880 329c 	strb.w	r3, [r0, #668]	; 0x29c
        pdev->dev_config = cfgidx;
 8004472:	6046      	str	r6, [r0, #4]
        (void)USBD_ClrClassConfig(pdev, cfgidx);
 8004474:	4631      	mov	r1, r6
 8004476:	f7ff fda3 	bl	8003fc0 <USBD_ClrClassConfig>
        (void)USBD_CtlSendStatus(pdev);
 800447a:	4620      	mov	r0, r4
 800447c:	f000 f98f 	bl	800479e <USBD_CtlSendStatus>
 8004480:	4635      	mov	r5, r6
 8004482:	e77e      	b.n	8004382 <USBD_StdDevReq+0xda>
      else if (cfgidx != pdev->dev_config)
 8004484:	6841      	ldr	r1, [r0, #4]
 8004486:	2901      	cmp	r1, #1
 8004488:	d050      	beq.n	800452c <USBD_StdDevReq+0x284>
        (void)USBD_ClrClassConfig(pdev, (uint8_t)pdev->dev_config);
 800448a:	b2c9      	uxtb	r1, r1
 800448c:	f7ff fd98 	bl	8003fc0 <USBD_ClrClassConfig>
        pdev->dev_config = cfgidx;
 8004490:	7839      	ldrb	r1, [r7, #0]
 8004492:	6061      	str	r1, [r4, #4]
        ret = USBD_SetClassConfig(pdev, cfgidx);
 8004494:	4620      	mov	r0, r4
 8004496:	f7ff fd8c 	bl	8003fb2 <USBD_SetClassConfig>
        if (ret != USBD_OK)
 800449a:	4606      	mov	r6, r0
 800449c:	2800      	cmp	r0, #0
 800449e:	d045      	beq.n	800452c <USBD_StdDevReq+0x284>
          USBD_CtlError(pdev, req);
 80044a0:	4620      	mov	r0, r4
 80044a2:	f7ff fef6 	bl	8004292 <USBD_CtlError.constprop.0>
          (void)USBD_ClrClassConfig(pdev, (uint8_t)pdev->dev_config);
 80044a6:	7921      	ldrb	r1, [r4, #4]
 80044a8:	4620      	mov	r0, r4
 80044aa:	f7ff fd89 	bl	8003fc0 <USBD_ClrClassConfig>
          pdev->dev_state = USBD_STATE_ADDRESSED;
 80044ae:	2302      	movs	r3, #2
 80044b0:	f884 329c 	strb.w	r3, [r4, #668]	; 0x29c
 80044b4:	e7e4      	b.n	8004480 <USBD_StdDevReq+0x1d8>
  if (req->wLength != 1U)
 80044b6:	88ca      	ldrh	r2, [r1, #6]
 80044b8:	2a01      	cmp	r2, #1
 80044ba:	f47f af5f 	bne.w	800437c <USBD_StdDevReq+0xd4>
    switch (pdev->dev_state)
 80044be:	f890 129c 	ldrb.w	r1, [r0, #668]	; 0x29c
 80044c2:	2902      	cmp	r1, #2
 80044c4:	b2cb      	uxtb	r3, r1
 80044c6:	d805      	bhi.n	80044d4 <USBD_StdDevReq+0x22c>
 80044c8:	b133      	cbz	r3, 80044d8 <USBD_StdDevReq+0x230>
        pdev->dev_default_config = 0U;
 80044ca:	4601      	mov	r1, r0
 80044cc:	2300      	movs	r3, #0
 80044ce:	f841 3f08 	str.w	r3, [r1, #8]!
        (void)USBD_CtlSendData(pdev, (uint8_t *)&pdev->dev_default_config, 1U);
 80044d2:	e735      	b.n	8004340 <USBD_StdDevReq+0x98>
    switch (pdev->dev_state)
 80044d4:	2b03      	cmp	r3, #3
 80044d6:	d004      	beq.n	80044e2 <USBD_StdDevReq+0x23a>
        USBD_CtlError(pdev, req);
 80044d8:	4620      	mov	r0, r4
 80044da:	f7ff feda 	bl	8004292 <USBD_CtlError.constprop.0>
  USBD_StatusTypeDef ret = USBD_OK;
 80044de:	2500      	movs	r5, #0
        break;
 80044e0:	e74f      	b.n	8004382 <USBD_StdDevReq+0xda>
        (void)USBD_CtlSendData(pdev, (uint8_t *)&pdev->dev_config, 1U);
 80044e2:	1d01      	adds	r1, r0, #4
 80044e4:	e72c      	b.n	8004340 <USBD_StdDevReq+0x98>
  switch (pdev->dev_state)
 80044e6:	f890 329c 	ldrb.w	r3, [r0, #668]	; 0x29c
 80044ea:	3b01      	subs	r3, #1
 80044ec:	2b02      	cmp	r3, #2
 80044ee:	d8f3      	bhi.n	80044d8 <USBD_StdDevReq+0x230>
      if (req->wLength != 0x2U)
 80044f0:	88ca      	ldrh	r2, [r1, #6]
 80044f2:	2a02      	cmp	r2, #2
 80044f4:	f47f af42 	bne.w	800437c <USBD_StdDevReq+0xd4>
      if (pdev->dev_remote_wakeup != 0U)
 80044f8:	f8d0 32a4 	ldr.w	r3, [r0, #676]	; 0x2a4
 80044fc:	4601      	mov	r1, r0
        pdev->dev_config_status |= USB_CONFIG_REMOTE_WAKEUP;
 80044fe:	2b00      	cmp	r3, #0
 8004500:	bf14      	ite	ne
 8004502:	2303      	movne	r3, #3
 8004504:	2301      	moveq	r3, #1
 8004506:	f841 3f0c 	str.w	r3, [r1, #12]!
      (void)USBD_CtlSendData(pdev, (uint8_t *)&pdev->dev_config_status, 2U);
 800450a:	f000 f91e 	bl	800474a <USBD_CtlSendData>
  USBD_StatusTypeDef ret = USBD_OK;
 800450e:	463d      	mov	r5, r7
      break;
 8004510:	e737      	b.n	8004382 <USBD_StdDevReq+0xda>
  if (req->wValue == USB_FEATURE_REMOTE_WAKEUP)
 8004512:	884b      	ldrh	r3, [r1, #2]
 8004514:	2b01      	cmp	r3, #1
 8004516:	d102      	bne.n	800451e <USBD_StdDevReq+0x276>
        pdev->dev_remote_wakeup = 0U;
 8004518:	f8c4 32a4 	str.w	r3, [r4, #676]	; 0x2a4
 800451c:	e006      	b.n	800452c <USBD_StdDevReq+0x284>
  else if (req->wValue == USB_FEATURE_TEST_MODE)
 800451e:	2b02      	cmp	r3, #2
 8004520:	f47f af2c 	bne.w	800437c <USBD_StdDevReq+0xd4>
    pdev->dev_test_mode = req->wIndex >> 8;
 8004524:	888b      	ldrh	r3, [r1, #4]
 8004526:	0a1b      	lsrs	r3, r3, #8
 8004528:	f880 32a0 	strb.w	r3, [r0, #672]	; 0x2a0
        (void)USBD_CtlSendStatus(pdev);
 800452c:	4620      	mov	r0, r4
 800452e:	f000 f936 	bl	800479e <USBD_CtlSendStatus>
 8004532:	e726      	b.n	8004382 <USBD_StdDevReq+0xda>
  switch (pdev->dev_state)
 8004534:	f890 329c 	ldrb.w	r3, [r0, #668]	; 0x29c
 8004538:	3b01      	subs	r3, #1
 800453a:	2b02      	cmp	r3, #2
 800453c:	d8cc      	bhi.n	80044d8 <USBD_StdDevReq+0x230>
      if (req->wValue == USB_FEATURE_REMOTE_WAKEUP)
 800453e:	884b      	ldrh	r3, [r1, #2]
 8004540:	2b01      	cmp	r3, #1
 8004542:	f47f af1e 	bne.w	8004382 <USBD_StdDevReq+0xda>
        pdev->dev_remote_wakeup = 0U;
 8004546:	2300      	movs	r3, #0
 8004548:	e7e6      	b.n	8004518 <USBD_StdDevReq+0x270>
 800454a:	bf00      	nop
 800454c:	20001b50 	.word	0x20001b50

08004550 <USBD_StdItfReq>:
{
 8004550:	b570      	push	{r4, r5, r6, lr}
  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 8004552:	780b      	ldrb	r3, [r1, #0]
 8004554:	f003 0260 	and.w	r2, r3, #96	; 0x60
 8004558:	2a40      	cmp	r2, #64	; 0x40
{
 800455a:	4604      	mov	r4, r0
 800455c:	460e      	mov	r6, r1
  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 800455e:	d001      	beq.n	8004564 <USBD_StdItfReq+0x14>
 8004560:	065b      	lsls	r3, r3, #25
 8004562:	d41f      	bmi.n	80045a4 <USBD_StdItfReq+0x54>
      switch (pdev->dev_state)
 8004564:	f894 329c 	ldrb.w	r3, [r4, #668]	; 0x29c
 8004568:	3b01      	subs	r3, #1
 800456a:	2b02      	cmp	r3, #2
 800456c:	d81a      	bhi.n	80045a4 <USBD_StdItfReq+0x54>
          if (LOBYTE(req->wIndex) <= USBD_MAX_NUM_INTERFACES)
 800456e:	7931      	ldrb	r1, [r6, #4]
 8004570:	2901      	cmp	r1, #1
            idx = USBD_CoreFindIF(pdev, LOBYTE(req->wIndex));
 8004572:	4620      	mov	r0, r4
          if (LOBYTE(req->wIndex) <= USBD_MAX_NUM_INTERFACES)
 8004574:	d817      	bhi.n	80045a6 <USBD_StdItfReq+0x56>
            idx = USBD_CoreFindIF(pdev, LOBYTE(req->wIndex));
 8004576:	f7ff fe76 	bl	8004266 <USBD_CoreFindIF>
            if (((uint8_t)idx != 0xFFU) && (idx < USBD_MAX_SUPPORTED_CLASS))
 800457a:	b988      	cbnz	r0, 80045a0 <USBD_StdItfReq+0x50>
              if (pdev->pClass[idx]->Setup != NULL)
 800457c:	f8d4 32b8 	ldr.w	r3, [r4, #696]	; 0x2b8
 8004580:	689b      	ldr	r3, [r3, #8]
 8004582:	b16b      	cbz	r3, 80045a0 <USBD_StdItfReq+0x50>
                pdev->classId = idx;
 8004584:	f8c4 02d4 	str.w	r0, [r4, #724]	; 0x2d4
                ret = (USBD_StatusTypeDef)(pdev->pClass[idx]->Setup(pdev, req));
 8004588:	4631      	mov	r1, r6
 800458a:	4620      	mov	r0, r4
 800458c:	4798      	blx	r3
 800458e:	4605      	mov	r5, r0
            if ((req->wLength == 0U) && (ret == USBD_OK))
 8004590:	88f3      	ldrh	r3, [r6, #6]
 8004592:	b91b      	cbnz	r3, 800459c <USBD_StdItfReq+0x4c>
 8004594:	b915      	cbnz	r5, 800459c <USBD_StdItfReq+0x4c>
              (void)USBD_CtlSendStatus(pdev);
 8004596:	4620      	mov	r0, r4
 8004598:	f000 f901 	bl	800479e <USBD_CtlSendStatus>
}
 800459c:	4628      	mov	r0, r5
 800459e:	bd70      	pop	{r4, r5, r6, pc}
              ret = USBD_FAIL;
 80045a0:	2503      	movs	r5, #3
 80045a2:	e7f5      	b.n	8004590 <USBD_StdItfReq+0x40>
          USBD_CtlError(pdev, req);
 80045a4:	4620      	mov	r0, r4
 80045a6:	f7ff fe74 	bl	8004292 <USBD_CtlError.constprop.0>
  USBD_StatusTypeDef ret = USBD_OK;
 80045aa:	2500      	movs	r5, #0
          break;
 80045ac:	e7f6      	b.n	800459c <USBD_StdItfReq+0x4c>

080045ae <USBD_StdEPReq>:
{
 80045ae:	b570      	push	{r4, r5, r6, lr}
 80045b0:	780b      	ldrb	r3, [r1, #0]
  ep_addr = LOBYTE(req->wIndex);
 80045b2:	888a      	ldrh	r2, [r1, #4]
 80045b4:	790d      	ldrb	r5, [r1, #4]
 80045b6:	f003 0360 	and.w	r3, r3, #96	; 0x60
  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 80045ba:	2b20      	cmp	r3, #32
{
 80045bc:	4604      	mov	r4, r0
 80045be:	460e      	mov	r6, r1
  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 80045c0:	d05a      	beq.n	8004678 <USBD_StdEPReq+0xca>
 80045c2:	2b40      	cmp	r3, #64	; 0x40
 80045c4:	d058      	beq.n	8004678 <USBD_StdEPReq+0xca>
 80045c6:	bb9b      	cbnz	r3, 8004630 <USBD_StdEPReq+0x82>
      switch (req->bRequest)
 80045c8:	784b      	ldrb	r3, [r1, #1]
 80045ca:	2b01      	cmp	r3, #1
 80045cc:	d042      	beq.n	8004654 <USBD_StdEPReq+0xa6>
 80045ce:	2b03      	cmp	r3, #3
 80045d0:	d027      	beq.n	8004622 <USBD_StdEPReq+0x74>
 80045d2:	bb6b      	cbnz	r3, 8004630 <USBD_StdEPReq+0x82>
          switch (pdev->dev_state)
 80045d4:	f890 329c 	ldrb.w	r3, [r0, #668]	; 0x29c
 80045d8:	2b02      	cmp	r3, #2
 80045da:	b2d9      	uxtb	r1, r3
 80045dc:	d068      	beq.n	80046b0 <USBD_StdEPReq+0x102>
 80045de:	2903      	cmp	r1, #3
 80045e0:	d126      	bne.n	8004630 <USBD_StdEPReq+0x82>
                if (pdev->ep_in[ep_addr & 0xFU].is_used == 0U)
 80045e2:	f005 030f 	and.w	r3, r5, #15
              if ((ep_addr & 0x80U) == 0x80U)
 80045e6:	f012 0f80 	tst.w	r2, #128	; 0x80
 80045ea:	f04f 0214 	mov.w	r2, #20
                if (pdev->ep_in[ep_addr & 0xFU].is_used == 0U)
 80045ee:	fb02 0303 	mla	r3, r2, r3, r0
              if ((ep_addr & 0x80U) == 0x80U)
 80045f2:	d06c      	beq.n	80046ce <USBD_StdEPReq+0x120>
                if (pdev->ep_in[ep_addr & 0xFU].is_used == 0U)
 80045f4:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
 80045f6:	b1db      	cbz	r3, 8004630 <USBD_StdEPReq+0x82>
              pep = ((ep_addr & 0x80U) == 0x80U) ? &pdev->ep_in[ep_addr & 0x7FU] : \
 80045f8:	f005 067f 	and.w	r6, r5, #127	; 0x7f
 80045fc:	3601      	adds	r6, #1
 80045fe:	eb06 0686 	add.w	r6, r6, r6, lsl #2
 8004602:	eb00 0686 	add.w	r6, r0, r6, lsl #2
              if ((ep_addr == 0x00U) || (ep_addr == 0x80U))
 8004606:	f015 007f 	ands.w	r0, r5, #127	; 0x7f
 800460a:	d006      	beq.n	800461a <USBD_StdEPReq+0x6c>
              else if (USBD_LL_IsStallEP(pdev, ep_addr) != 0U)
 800460c:	4629      	mov	r1, r5
 800460e:	4620      	mov	r0, r4
 8004610:	f7fc fb44 	bl	8000c9c <USBD_LL_IsStallEP>
 8004614:	3800      	subs	r0, #0
 8004616:	bf18      	it	ne
 8004618:	2001      	movne	r0, #1
                pep->status = 0x0000U;
 800461a:	6030      	str	r0, [r6, #0]
              (void)USBD_CtlSendData(pdev, (uint8_t *)&pep->status, 2U);
 800461c:	2202      	movs	r2, #2
 800461e:	4631      	mov	r1, r6
 8004620:	e051      	b.n	80046c6 <USBD_StdEPReq+0x118>
          switch (pdev->dev_state)
 8004622:	f890 329c 	ldrb.w	r3, [r0, #668]	; 0x29c
 8004626:	2b02      	cmp	r3, #2
 8004628:	b2da      	uxtb	r2, r3
 800462a:	d037      	beq.n	800469c <USBD_StdEPReq+0xee>
 800462c:	2a03      	cmp	r2, #3
 800462e:	d003      	beq.n	8004638 <USBD_StdEPReq+0x8a>
              USBD_CtlError(pdev, req);
 8004630:	4620      	mov	r0, r4
 8004632:	f7ff fe2e 	bl	8004292 <USBD_CtlError.constprop.0>
              break;
 8004636:	e00b      	b.n	8004650 <USBD_StdEPReq+0xa2>
              if (req->wValue == USB_FEATURE_EP_HALT)
 8004638:	884b      	ldrh	r3, [r1, #2]
 800463a:	b933      	cbnz	r3, 800464a <USBD_StdEPReq+0x9c>
                if ((ep_addr != 0x00U) && (ep_addr != 0x80U) && (req->wLength == 0x00U))
 800463c:	0669      	lsls	r1, r5, #25
 800463e:	d004      	beq.n	800464a <USBD_StdEPReq+0x9c>
 8004640:	88f3      	ldrh	r3, [r6, #6]
 8004642:	b913      	cbnz	r3, 800464a <USBD_StdEPReq+0x9c>
                  (void)USBD_LL_StallEP(pdev, ep_addr);
 8004644:	4629      	mov	r1, r5
 8004646:	f7fc fb1b 	bl	8000c80 <USBD_LL_StallEP>
              (void)USBD_CtlSendStatus(pdev);
 800464a:	4620      	mov	r0, r4
 800464c:	f000 f8a7 	bl	800479e <USBD_CtlSendStatus>
}
 8004650:	2000      	movs	r0, #0
 8004652:	bd70      	pop	{r4, r5, r6, pc}
          switch (pdev->dev_state)
 8004654:	f890 329c 	ldrb.w	r3, [r0, #668]	; 0x29c
 8004658:	2b02      	cmp	r3, #2
 800465a:	b2da      	uxtb	r2, r3
 800465c:	d01e      	beq.n	800469c <USBD_StdEPReq+0xee>
 800465e:	2a03      	cmp	r2, #3
 8004660:	d1e6      	bne.n	8004630 <USBD_StdEPReq+0x82>
              if (req->wValue == USB_FEATURE_EP_HALT)
 8004662:	884b      	ldrh	r3, [r1, #2]
 8004664:	2b00      	cmp	r3, #0
 8004666:	d1f3      	bne.n	8004650 <USBD_StdEPReq+0xa2>
                if ((ep_addr & 0x7FU) != 0x00U)
 8004668:	066b      	lsls	r3, r5, #25
 800466a:	d002      	beq.n	8004672 <USBD_StdEPReq+0xc4>
                  (void)USBD_LL_ClearStallEP(pdev, ep_addr);
 800466c:	4629      	mov	r1, r5
 800466e:	f7fc fb0e 	bl	8000c8e <USBD_LL_ClearStallEP>
                (void)USBD_CtlSendStatus(pdev);
 8004672:	4620      	mov	r0, r4
 8004674:	f000 f893 	bl	800479e <USBD_CtlSendStatus>
                idx = USBD_CoreFindEP(pdev, ep_addr);
 8004678:	4629      	mov	r1, r5
 800467a:	4620      	mov	r0, r4
 800467c:	f7ff fdf5 	bl	800426a <USBD_CoreFindEP>
                if (((uint8_t)idx != 0xFFU) && (idx < USBD_MAX_SUPPORTED_CLASS))
 8004680:	2800      	cmp	r0, #0
 8004682:	d1e5      	bne.n	8004650 <USBD_StdEPReq+0xa2>
                  if (pdev->pClass[idx]->Setup != NULL)
 8004684:	f8d4 32b8 	ldr.w	r3, [r4, #696]	; 0x2b8
                  pdev->classId = idx;
 8004688:	f8c4 02d4 	str.w	r0, [r4, #724]	; 0x2d4
                  if (pdev->pClass[idx]->Setup != NULL)
 800468c:	689b      	ldr	r3, [r3, #8]
 800468e:	2b00      	cmp	r3, #0
 8004690:	d0de      	beq.n	8004650 <USBD_StdEPReq+0xa2>
                    ret = (USBD_StatusTypeDef)(pdev->pClass[idx]->Setup(pdev, req));
 8004692:	4631      	mov	r1, r6
 8004694:	4620      	mov	r0, r4
}
 8004696:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
                    ret = (USBD_StatusTypeDef)(pdev->pClass[idx]->Setup(pdev, req));
 800469a:	4718      	bx	r3
              if ((ep_addr != 0x00U) && (ep_addr != 0x80U))
 800469c:	066a      	lsls	r2, r5, #25
 800469e:	d0c7      	beq.n	8004630 <USBD_StdEPReq+0x82>
                (void)USBD_LL_StallEP(pdev, ep_addr);
 80046a0:	4629      	mov	r1, r5
 80046a2:	f7fc faed 	bl	8000c80 <USBD_LL_StallEP>
                (void)USBD_LL_StallEP(pdev, 0x80U);
 80046a6:	2180      	movs	r1, #128	; 0x80
 80046a8:	4620      	mov	r0, r4
 80046aa:	f7fc fae9 	bl	8000c80 <USBD_LL_StallEP>
 80046ae:	e7cf      	b.n	8004650 <USBD_StdEPReq+0xa2>
              if ((ep_addr != 0x00U) && (ep_addr != 0x80U))
 80046b0:	0669      	lsls	r1, r5, #25
 80046b2:	d1bd      	bne.n	8004630 <USBD_StdEPReq+0x82>
              pep = ((ep_addr & 0x80U) == 0x80U) ? &pdev->ep_in[ep_addr & 0x7FU] : \
 80046b4:	0613      	lsls	r3, r2, #24
 80046b6:	bf4c      	ite	mi
 80046b8:	f100 0114 	addmi.w	r1, r0, #20
 80046bc:	f500 71aa 	addpl.w	r1, r0, #340	; 0x154
              pep->status = 0x0000U;
 80046c0:	2300      	movs	r3, #0
 80046c2:	600b      	str	r3, [r1, #0]
              (void)USBD_CtlSendData(pdev, (uint8_t *)&pep->status, 2U);
 80046c4:	2202      	movs	r2, #2
              (void)USBD_CtlSendData(pdev, (uint8_t *)&pep->status, 2U);
 80046c6:	4620      	mov	r0, r4
 80046c8:	f000 f83f 	bl	800474a <USBD_CtlSendData>
              break;
 80046cc:	e7c0      	b.n	8004650 <USBD_StdEPReq+0xa2>
                if (pdev->ep_out[ep_addr & 0xFU].is_used == 0U)
 80046ce:	f8b3 3164 	ldrh.w	r3, [r3, #356]	; 0x164
 80046d2:	2b00      	cmp	r3, #0
 80046d4:	d0ac      	beq.n	8004630 <USBD_StdEPReq+0x82>
              pep = ((ep_addr & 0x80U) == 0x80U) ? &pdev->ep_in[ep_addr & 0x7FU] : \
 80046d6:	f005 067f 	and.w	r6, r5, #127	; 0x7f
 80046da:	2314      	movs	r3, #20
 80046dc:	fb03 0606 	mla	r6, r3, r6, r0
 80046e0:	f506 76aa 	add.w	r6, r6, #340	; 0x154
 80046e4:	e78f      	b.n	8004606 <USBD_StdEPReq+0x58>

080046e6 <USBD_ParseSetupRequest>:
  req->bmRequest = *(uint8_t *)(pbuff);
 80046e6:	780b      	ldrb	r3, [r1, #0]
 80046e8:	7003      	strb	r3, [r0, #0]
  req->bRequest = *(uint8_t *)(pbuff);
 80046ea:	784b      	ldrb	r3, [r1, #1]
 80046ec:	7043      	strb	r3, [r0, #1]
  req->wValue = SWAPBYTE(pbuff);
 80046ee:	884b      	ldrh	r3, [r1, #2]
 80046f0:	8043      	strh	r3, [r0, #2]
  req->wIndex = SWAPBYTE(pbuff);
 80046f2:	888b      	ldrh	r3, [r1, #4]
 80046f4:	8083      	strh	r3, [r0, #4]
  req->wLength = SWAPBYTE(pbuff);
 80046f6:	88cb      	ldrh	r3, [r1, #6]
 80046f8:	80c3      	strh	r3, [r0, #6]
}
 80046fa:	4770      	bx	lr

080046fc <USBD_CtlError>:
{
 80046fc:	b510      	push	{r4, lr}
  (void)USBD_LL_StallEP(pdev, 0x80U);
 80046fe:	2180      	movs	r1, #128	; 0x80
{
 8004700:	4604      	mov	r4, r0
  (void)USBD_LL_StallEP(pdev, 0x80U);
 8004702:	f7fc fabd 	bl	8000c80 <USBD_LL_StallEP>
  (void)USBD_LL_StallEP(pdev, 0U);
 8004706:	4620      	mov	r0, r4
 8004708:	2100      	movs	r1, #0
}
 800470a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  (void)USBD_LL_StallEP(pdev, 0U);
 800470e:	f7fc bab7 	b.w	8000c80 <USBD_LL_StallEP>

08004712 <USBD_GetString>:
  * @param  unicode : Formatted string buffer (unicode)
  * @param  len : descriptor length
  * @retval None
  */
void USBD_GetString(uint8_t *desc, uint8_t *unicode, uint16_t *len)
{
 8004712:	b530      	push	{r4, r5, lr}
  uint8_t idx = 0U;
  uint8_t *pdesc;

  if (desc == NULL)
 8004714:	b188      	cbz	r0, 800473a <USBD_GetString+0x28>
 8004716:	2400      	movs	r4, #0
 8004718:	3801      	subs	r0, #1
static uint8_t USBD_GetLen(uint8_t *buf)
{
  uint8_t  len = 0U;
  uint8_t *pbuff = buf;

  while (*pbuff != (uint8_t)'\0')
 800471a:	4623      	mov	r3, r4
 800471c:	3401      	adds	r4, #1
 800471e:	5d05      	ldrb	r5, [r0, r4]
 8004720:	2d00      	cmp	r5, #0
 8004722:	d1fa      	bne.n	800471a <USBD_GetString+0x8>
  *len = ((uint16_t)USBD_GetLen(pdesc) * 2U) + 2U;
 8004724:	b2db      	uxtb	r3, r3
 8004726:	3301      	adds	r3, #1
 8004728:	005b      	lsls	r3, r3, #1
 800472a:	8013      	strh	r3, [r2, #0]
  unicode[idx] = *(uint8_t *)len;
 800472c:	700b      	strb	r3, [r1, #0]
  unicode[idx] = USB_DESC_TYPE_STRING;
 800472e:	2303      	movs	r3, #3
 8004730:	704b      	strb	r3, [r1, #1]
  idx++;
 8004732:	2302      	movs	r3, #2
  while (*pdesc != (uint8_t)'\0')
 8004734:	f810 2f01 	ldrb.w	r2, [r0, #1]!
 8004738:	b902      	cbnz	r2, 800473c <USBD_GetString+0x2a>
}
 800473a:	bd30      	pop	{r4, r5, pc}
    unicode[idx] = *pdesc;
 800473c:	54ca      	strb	r2, [r1, r3]
    idx++;
 800473e:	1c5a      	adds	r2, r3, #1
    unicode[idx] = 0U;
 8004740:	b2d2      	uxtb	r2, r2
    idx++;
 8004742:	3302      	adds	r3, #2
    unicode[idx] = 0U;
 8004744:	548d      	strb	r5, [r1, r2]
    idx++;
 8004746:	b2db      	uxtb	r3, r3
 8004748:	e7f4      	b.n	8004734 <USBD_GetString+0x22>

0800474a <USBD_CtlSendData>:
  * @param  len: length of data to be sent
  * @retval status
  */
USBD_StatusTypeDef USBD_CtlSendData(USBD_HandleTypeDef *pdev,
                                    uint8_t *pbuf, uint32_t len)
{
 800474a:	b510      	push	{r4, lr}
 800474c:	4613      	mov	r3, r2
  /* Set EP0 State */
  pdev->ep0_state = USBD_EP0_DATA_IN;
 800474e:	2202      	movs	r2, #2
  pdev->ep_in[0].total_length = len;

#ifdef USBD_AVOID_PACKET_SPLIT_MPS
  pdev->ep_in[0].rem_length = 0U;
#else
  pdev->ep_in[0].rem_length = len;
 8004750:	e9c0 3306 	strd	r3, r3, [r0, #24]
  pdev->ep0_state = USBD_EP0_DATA_IN;
 8004754:	f8c0 2294 	str.w	r2, [r0, #660]	; 0x294
#endif /* USBD_AVOID_PACKET_SPLIT_MPS */

  /* Start the transfer */
  (void)USBD_LL_Transmit(pdev, 0x00U, pbuf, len);
 8004758:	460a      	mov	r2, r1
 800475a:	2100      	movs	r1, #0
 800475c:	f7fc fab8 	bl	8000cd0 <USBD_LL_Transmit>

  return USBD_OK;
}
 8004760:	2000      	movs	r0, #0
 8004762:	bd10      	pop	{r4, pc}

08004764 <USBD_CtlContinueSendData>:
  * @param  len: length of data to be sent
  * @retval status
  */
USBD_StatusTypeDef USBD_CtlContinueSendData(USBD_HandleTypeDef *pdev,
                                            uint8_t *pbuf, uint32_t len)
{
 8004764:	b508      	push	{r3, lr}
 8004766:	4613      	mov	r3, r2
  /* Start the next transfer */
  (void)USBD_LL_Transmit(pdev, 0x00U, pbuf, len);
 8004768:	460a      	mov	r2, r1
 800476a:	2100      	movs	r1, #0
 800476c:	f7fc fab0 	bl	8000cd0 <USBD_LL_Transmit>

  return USBD_OK;
}
 8004770:	2000      	movs	r0, #0
 8004772:	bd08      	pop	{r3, pc}

08004774 <USBD_CtlPrepareRx>:
  * @param  len: length of data to be received
  * @retval status
  */
USBD_StatusTypeDef USBD_CtlPrepareRx(USBD_HandleTypeDef *pdev,
                                     uint8_t *pbuf, uint32_t len)
{
 8004774:	b510      	push	{r4, lr}
 8004776:	4613      	mov	r3, r2
  /* Set EP0 State */
  pdev->ep0_state = USBD_EP0_DATA_OUT;
 8004778:	2203      	movs	r2, #3
  pdev->ep_out[0].total_length = len;

#ifdef USBD_AVOID_PACKET_SPLIT_MPS
  pdev->ep_out[0].rem_length = 0U;
#else
  pdev->ep_out[0].rem_length = len;
 800477a:	e9c0 3356 	strd	r3, r3, [r0, #344]	; 0x158
  pdev->ep0_state = USBD_EP0_DATA_OUT;
 800477e:	f8c0 2294 	str.w	r2, [r0, #660]	; 0x294
#endif /* USBD_AVOID_PACKET_SPLIT_MPS */

  /* Start the transfer */
  (void)USBD_LL_PrepareReceive(pdev, 0U, pbuf, len);
 8004782:	460a      	mov	r2, r1
 8004784:	2100      	movs	r1, #0
 8004786:	f7fc faaa 	bl	8000cde <USBD_LL_PrepareReceive>

  return USBD_OK;
}
 800478a:	2000      	movs	r0, #0
 800478c:	bd10      	pop	{r4, pc}

0800478e <USBD_CtlContinueRx>:
  * @param  len: length of data to be received
  * @retval status
  */
USBD_StatusTypeDef USBD_CtlContinueRx(USBD_HandleTypeDef *pdev,
                                      uint8_t *pbuf, uint32_t len)
{
 800478e:	b508      	push	{r3, lr}
 8004790:	4613      	mov	r3, r2
  (void)USBD_LL_PrepareReceive(pdev, 0U, pbuf, len);
 8004792:	460a      	mov	r2, r1
 8004794:	2100      	movs	r1, #0
 8004796:	f7fc faa2 	bl	8000cde <USBD_LL_PrepareReceive>

  return USBD_OK;
}
 800479a:	2000      	movs	r0, #0
 800479c:	bd08      	pop	{r3, pc}

0800479e <USBD_CtlSendStatus>:
  *         send zero lzngth packet on the ctl pipe
  * @param  pdev: device instance
  * @retval status
  */
USBD_StatusTypeDef USBD_CtlSendStatus(USBD_HandleTypeDef *pdev)
{
 800479e:	b508      	push	{r3, lr}
  /* Set EP0 State */
  pdev->ep0_state = USBD_EP0_STATUS_IN;
 80047a0:	2204      	movs	r2, #4

  /* Start the transfer */
  (void)USBD_LL_Transmit(pdev, 0x00U, NULL, 0U);
 80047a2:	2300      	movs	r3, #0
  pdev->ep0_state = USBD_EP0_STATUS_IN;
 80047a4:	f8c0 2294 	str.w	r2, [r0, #660]	; 0x294
  (void)USBD_LL_Transmit(pdev, 0x00U, NULL, 0U);
 80047a8:	4619      	mov	r1, r3
 80047aa:	461a      	mov	r2, r3
 80047ac:	f7fc fa90 	bl	8000cd0 <USBD_LL_Transmit>

  return USBD_OK;
}
 80047b0:	2000      	movs	r0, #0
 80047b2:	bd08      	pop	{r3, pc}

080047b4 <USBD_CtlReceiveStatus>:
  *         receive zero lzngth packet on the ctl pipe
  * @param  pdev: device instance
  * @retval status
  */
USBD_StatusTypeDef USBD_CtlReceiveStatus(USBD_HandleTypeDef *pdev)
{
 80047b4:	b508      	push	{r3, lr}
  /* Set EP0 State */
  pdev->ep0_state = USBD_EP0_STATUS_OUT;
 80047b6:	2205      	movs	r2, #5

  /* Start the transfer */
  (void)USBD_LL_PrepareReceive(pdev, 0U, NULL, 0U);
 80047b8:	2300      	movs	r3, #0
  pdev->ep0_state = USBD_EP0_STATUS_OUT;
 80047ba:	f8c0 2294 	str.w	r2, [r0, #660]	; 0x294
  (void)USBD_LL_PrepareReceive(pdev, 0U, NULL, 0U);
 80047be:	4619      	mov	r1, r3
 80047c0:	461a      	mov	r2, r3
 80047c2:	f7fc fa8c 	bl	8000cde <USBD_LL_PrepareReceive>

  return USBD_OK;
}
 80047c6:	2000      	movs	r0, #0
 80047c8:	bd08      	pop	{r3, pc}
	...

080047cc <malloc>:
 80047cc:	4b02      	ldr	r3, [pc, #8]	; (80047d8 <malloc+0xc>)
 80047ce:	4601      	mov	r1, r0
 80047d0:	6818      	ldr	r0, [r3, #0]
 80047d2:	f000 b82b 	b.w	800482c <_malloc_r>
 80047d6:	bf00      	nop
 80047d8:	2000014c 	.word	0x2000014c

080047dc <free>:
 80047dc:	4b02      	ldr	r3, [pc, #8]	; (80047e8 <free+0xc>)
 80047de:	4601      	mov	r1, r0
 80047e0:	6818      	ldr	r0, [r3, #0]
 80047e2:	f000 b8ed 	b.w	80049c0 <_free_r>
 80047e6:	bf00      	nop
 80047e8:	2000014c 	.word	0x2000014c

080047ec <sbrk_aligned>:
 80047ec:	b570      	push	{r4, r5, r6, lr}
 80047ee:	4e0e      	ldr	r6, [pc, #56]	; (8004828 <sbrk_aligned+0x3c>)
 80047f0:	460c      	mov	r4, r1
 80047f2:	6831      	ldr	r1, [r6, #0]
 80047f4:	4605      	mov	r5, r0
 80047f6:	b911      	cbnz	r1, 80047fe <sbrk_aligned+0x12>
 80047f8:	f000 f8ac 	bl	8004954 <_sbrk_r>
 80047fc:	6030      	str	r0, [r6, #0]
 80047fe:	4621      	mov	r1, r4
 8004800:	4628      	mov	r0, r5
 8004802:	f000 f8a7 	bl	8004954 <_sbrk_r>
 8004806:	1c43      	adds	r3, r0, #1
 8004808:	d00a      	beq.n	8004820 <sbrk_aligned+0x34>
 800480a:	1cc4      	adds	r4, r0, #3
 800480c:	f024 0403 	bic.w	r4, r4, #3
 8004810:	42a0      	cmp	r0, r4
 8004812:	d007      	beq.n	8004824 <sbrk_aligned+0x38>
 8004814:	1a21      	subs	r1, r4, r0
 8004816:	4628      	mov	r0, r5
 8004818:	f000 f89c 	bl	8004954 <_sbrk_r>
 800481c:	3001      	adds	r0, #1
 800481e:	d101      	bne.n	8004824 <sbrk_aligned+0x38>
 8004820:	f04f 34ff 	mov.w	r4, #4294967295
 8004824:	4620      	mov	r0, r4
 8004826:	bd70      	pop	{r4, r5, r6, pc}
 8004828:	20001b58 	.word	0x20001b58

0800482c <_malloc_r>:
 800482c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8004830:	1ccd      	adds	r5, r1, #3
 8004832:	f025 0503 	bic.w	r5, r5, #3
 8004836:	3508      	adds	r5, #8
 8004838:	2d0c      	cmp	r5, #12
 800483a:	bf38      	it	cc
 800483c:	250c      	movcc	r5, #12
 800483e:	2d00      	cmp	r5, #0
 8004840:	4607      	mov	r7, r0
 8004842:	db01      	blt.n	8004848 <_malloc_r+0x1c>
 8004844:	42a9      	cmp	r1, r5
 8004846:	d905      	bls.n	8004854 <_malloc_r+0x28>
 8004848:	230c      	movs	r3, #12
 800484a:	603b      	str	r3, [r7, #0]
 800484c:	2600      	movs	r6, #0
 800484e:	4630      	mov	r0, r6
 8004850:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8004854:	f8df 80d0 	ldr.w	r8, [pc, #208]	; 8004928 <_malloc_r+0xfc>
 8004858:	f000 f868 	bl	800492c <__malloc_lock>
 800485c:	f8d8 3000 	ldr.w	r3, [r8]
 8004860:	461c      	mov	r4, r3
 8004862:	bb5c      	cbnz	r4, 80048bc <_malloc_r+0x90>
 8004864:	4629      	mov	r1, r5
 8004866:	4638      	mov	r0, r7
 8004868:	f7ff ffc0 	bl	80047ec <sbrk_aligned>
 800486c:	1c43      	adds	r3, r0, #1
 800486e:	4604      	mov	r4, r0
 8004870:	d155      	bne.n	800491e <_malloc_r+0xf2>
 8004872:	f8d8 4000 	ldr.w	r4, [r8]
 8004876:	4626      	mov	r6, r4
 8004878:	2e00      	cmp	r6, #0
 800487a:	d145      	bne.n	8004908 <_malloc_r+0xdc>
 800487c:	2c00      	cmp	r4, #0
 800487e:	d048      	beq.n	8004912 <_malloc_r+0xe6>
 8004880:	6823      	ldr	r3, [r4, #0]
 8004882:	4631      	mov	r1, r6
 8004884:	4638      	mov	r0, r7
 8004886:	eb04 0903 	add.w	r9, r4, r3
 800488a:	f000 f863 	bl	8004954 <_sbrk_r>
 800488e:	4581      	cmp	r9, r0
 8004890:	d13f      	bne.n	8004912 <_malloc_r+0xe6>
 8004892:	6821      	ldr	r1, [r4, #0]
 8004894:	1a6d      	subs	r5, r5, r1
 8004896:	4629      	mov	r1, r5
 8004898:	4638      	mov	r0, r7
 800489a:	f7ff ffa7 	bl	80047ec <sbrk_aligned>
 800489e:	3001      	adds	r0, #1
 80048a0:	d037      	beq.n	8004912 <_malloc_r+0xe6>
 80048a2:	6823      	ldr	r3, [r4, #0]
 80048a4:	442b      	add	r3, r5
 80048a6:	6023      	str	r3, [r4, #0]
 80048a8:	f8d8 3000 	ldr.w	r3, [r8]
 80048ac:	2b00      	cmp	r3, #0
 80048ae:	d038      	beq.n	8004922 <_malloc_r+0xf6>
 80048b0:	685a      	ldr	r2, [r3, #4]
 80048b2:	42a2      	cmp	r2, r4
 80048b4:	d12b      	bne.n	800490e <_malloc_r+0xe2>
 80048b6:	2200      	movs	r2, #0
 80048b8:	605a      	str	r2, [r3, #4]
 80048ba:	e00f      	b.n	80048dc <_malloc_r+0xb0>
 80048bc:	6822      	ldr	r2, [r4, #0]
 80048be:	1b52      	subs	r2, r2, r5
 80048c0:	d41f      	bmi.n	8004902 <_malloc_r+0xd6>
 80048c2:	2a0b      	cmp	r2, #11
 80048c4:	d917      	bls.n	80048f6 <_malloc_r+0xca>
 80048c6:	1961      	adds	r1, r4, r5
 80048c8:	42a3      	cmp	r3, r4
 80048ca:	6025      	str	r5, [r4, #0]
 80048cc:	bf18      	it	ne
 80048ce:	6059      	strne	r1, [r3, #4]
 80048d0:	6863      	ldr	r3, [r4, #4]
 80048d2:	bf08      	it	eq
 80048d4:	f8c8 1000 	streq.w	r1, [r8]
 80048d8:	5162      	str	r2, [r4, r5]
 80048da:	604b      	str	r3, [r1, #4]
 80048dc:	4638      	mov	r0, r7
 80048de:	f104 060b 	add.w	r6, r4, #11
 80048e2:	f000 f829 	bl	8004938 <__malloc_unlock>
 80048e6:	f026 0607 	bic.w	r6, r6, #7
 80048ea:	1d23      	adds	r3, r4, #4
 80048ec:	1af2      	subs	r2, r6, r3
 80048ee:	d0ae      	beq.n	800484e <_malloc_r+0x22>
 80048f0:	1b9b      	subs	r3, r3, r6
 80048f2:	50a3      	str	r3, [r4, r2]
 80048f4:	e7ab      	b.n	800484e <_malloc_r+0x22>
 80048f6:	42a3      	cmp	r3, r4
 80048f8:	6862      	ldr	r2, [r4, #4]
 80048fa:	d1dd      	bne.n	80048b8 <_malloc_r+0x8c>
 80048fc:	f8c8 2000 	str.w	r2, [r8]
 8004900:	e7ec      	b.n	80048dc <_malloc_r+0xb0>
 8004902:	4623      	mov	r3, r4
 8004904:	6864      	ldr	r4, [r4, #4]
 8004906:	e7ac      	b.n	8004862 <_malloc_r+0x36>
 8004908:	4634      	mov	r4, r6
 800490a:	6876      	ldr	r6, [r6, #4]
 800490c:	e7b4      	b.n	8004878 <_malloc_r+0x4c>
 800490e:	4613      	mov	r3, r2
 8004910:	e7cc      	b.n	80048ac <_malloc_r+0x80>
 8004912:	230c      	movs	r3, #12
 8004914:	603b      	str	r3, [r7, #0]
 8004916:	4638      	mov	r0, r7
 8004918:	f000 f80e 	bl	8004938 <__malloc_unlock>
 800491c:	e797      	b.n	800484e <_malloc_r+0x22>
 800491e:	6025      	str	r5, [r4, #0]
 8004920:	e7dc      	b.n	80048dc <_malloc_r+0xb0>
 8004922:	605b      	str	r3, [r3, #4]
 8004924:	deff      	udf	#255	; 0xff
 8004926:	bf00      	nop
 8004928:	20001b54 	.word	0x20001b54

0800492c <__malloc_lock>:
 800492c:	4801      	ldr	r0, [pc, #4]	; (8004934 <__malloc_lock+0x8>)
 800492e:	f000 b845 	b.w	80049bc <__retarget_lock_acquire_recursive>
 8004932:	bf00      	nop
 8004934:	20001c98 	.word	0x20001c98

08004938 <__malloc_unlock>:
 8004938:	4801      	ldr	r0, [pc, #4]	; (8004940 <__malloc_unlock+0x8>)
 800493a:	f000 b840 	b.w	80049be <__retarget_lock_release_recursive>
 800493e:	bf00      	nop
 8004940:	20001c98 	.word	0x20001c98

08004944 <memset>:
 8004944:	4402      	add	r2, r0
 8004946:	4603      	mov	r3, r0
 8004948:	4293      	cmp	r3, r2
 800494a:	d100      	bne.n	800494e <memset+0xa>
 800494c:	4770      	bx	lr
 800494e:	f803 1b01 	strb.w	r1, [r3], #1
 8004952:	e7f9      	b.n	8004948 <memset+0x4>

08004954 <_sbrk_r>:
 8004954:	b538      	push	{r3, r4, r5, lr}
 8004956:	4d06      	ldr	r5, [pc, #24]	; (8004970 <_sbrk_r+0x1c>)
 8004958:	2300      	movs	r3, #0
 800495a:	4604      	mov	r4, r0
 800495c:	4608      	mov	r0, r1
 800495e:	602b      	str	r3, [r5, #0]
 8004960:	f000 f87a 	bl	8004a58 <_sbrk>
 8004964:	1c43      	adds	r3, r0, #1
 8004966:	d102      	bne.n	800496e <_sbrk_r+0x1a>
 8004968:	682b      	ldr	r3, [r5, #0]
 800496a:	b103      	cbz	r3, 800496e <_sbrk_r+0x1a>
 800496c:	6023      	str	r3, [r4, #0]
 800496e:	bd38      	pop	{r3, r4, r5, pc}
 8004970:	20001c94 	.word	0x20001c94

08004974 <__libc_init_array>:
 8004974:	b570      	push	{r4, r5, r6, lr}
 8004976:	4d0d      	ldr	r5, [pc, #52]	; (80049ac <__libc_init_array+0x38>)
 8004978:	4c0d      	ldr	r4, [pc, #52]	; (80049b0 <__libc_init_array+0x3c>)
 800497a:	1b64      	subs	r4, r4, r5
 800497c:	10a4      	asrs	r4, r4, #2
 800497e:	2600      	movs	r6, #0
 8004980:	42a6      	cmp	r6, r4
 8004982:	d109      	bne.n	8004998 <__libc_init_array+0x24>
 8004984:	4d0b      	ldr	r5, [pc, #44]	; (80049b4 <__libc_init_array+0x40>)
 8004986:	4c0c      	ldr	r4, [pc, #48]	; (80049b8 <__libc_init_array+0x44>)
 8004988:	f000 f874 	bl	8004a74 <_init>
 800498c:	1b64      	subs	r4, r4, r5
 800498e:	10a4      	asrs	r4, r4, #2
 8004990:	2600      	movs	r6, #0
 8004992:	42a6      	cmp	r6, r4
 8004994:	d105      	bne.n	80049a2 <__libc_init_array+0x2e>
 8004996:	bd70      	pop	{r4, r5, r6, pc}
 8004998:	f855 3b04 	ldr.w	r3, [r5], #4
 800499c:	4798      	blx	r3
 800499e:	3601      	adds	r6, #1
 80049a0:	e7ee      	b.n	8004980 <__libc_init_array+0xc>
 80049a2:	f855 3b04 	ldr.w	r3, [r5], #4
 80049a6:	4798      	blx	r3
 80049a8:	3601      	adds	r6, #1
 80049aa:	e7f2      	b.n	8004992 <__libc_init_array+0x1e>
 80049ac:	08004b24 	.word	0x08004b24
 80049b0:	08004b24 	.word	0x08004b24
 80049b4:	08004b24 	.word	0x08004b24
 80049b8:	08004b28 	.word	0x08004b28

080049bc <__retarget_lock_acquire_recursive>:
 80049bc:	4770      	bx	lr

080049be <__retarget_lock_release_recursive>:
 80049be:	4770      	bx	lr

080049c0 <_free_r>:
 80049c0:	b537      	push	{r0, r1, r2, r4, r5, lr}
 80049c2:	2900      	cmp	r1, #0
 80049c4:	d044      	beq.n	8004a50 <_free_r+0x90>
 80049c6:	f851 3c04 	ldr.w	r3, [r1, #-4]
 80049ca:	9001      	str	r0, [sp, #4]
 80049cc:	2b00      	cmp	r3, #0
 80049ce:	f1a1 0404 	sub.w	r4, r1, #4
 80049d2:	bfb8      	it	lt
 80049d4:	18e4      	addlt	r4, r4, r3
 80049d6:	f7ff ffa9 	bl	800492c <__malloc_lock>
 80049da:	4a1e      	ldr	r2, [pc, #120]	; (8004a54 <_free_r+0x94>)
 80049dc:	9801      	ldr	r0, [sp, #4]
 80049de:	6813      	ldr	r3, [r2, #0]
 80049e0:	b933      	cbnz	r3, 80049f0 <_free_r+0x30>
 80049e2:	6063      	str	r3, [r4, #4]
 80049e4:	6014      	str	r4, [r2, #0]
 80049e6:	b003      	add	sp, #12
 80049e8:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
 80049ec:	f7ff bfa4 	b.w	8004938 <__malloc_unlock>
 80049f0:	42a3      	cmp	r3, r4
 80049f2:	d908      	bls.n	8004a06 <_free_r+0x46>
 80049f4:	6825      	ldr	r5, [r4, #0]
 80049f6:	1961      	adds	r1, r4, r5
 80049f8:	428b      	cmp	r3, r1
 80049fa:	bf01      	itttt	eq
 80049fc:	6819      	ldreq	r1, [r3, #0]
 80049fe:	685b      	ldreq	r3, [r3, #4]
 8004a00:	1949      	addeq	r1, r1, r5
 8004a02:	6021      	streq	r1, [r4, #0]
 8004a04:	e7ed      	b.n	80049e2 <_free_r+0x22>
 8004a06:	461a      	mov	r2, r3
 8004a08:	685b      	ldr	r3, [r3, #4]
 8004a0a:	b10b      	cbz	r3, 8004a10 <_free_r+0x50>
 8004a0c:	42a3      	cmp	r3, r4
 8004a0e:	d9fa      	bls.n	8004a06 <_free_r+0x46>
 8004a10:	6811      	ldr	r1, [r2, #0]
 8004a12:	1855      	adds	r5, r2, r1
 8004a14:	42a5      	cmp	r5, r4
 8004a16:	d10b      	bne.n	8004a30 <_free_r+0x70>
 8004a18:	6824      	ldr	r4, [r4, #0]
 8004a1a:	4421      	add	r1, r4
 8004a1c:	1854      	adds	r4, r2, r1
 8004a1e:	42a3      	cmp	r3, r4
 8004a20:	6011      	str	r1, [r2, #0]
 8004a22:	d1e0      	bne.n	80049e6 <_free_r+0x26>
 8004a24:	681c      	ldr	r4, [r3, #0]
 8004a26:	685b      	ldr	r3, [r3, #4]
 8004a28:	6053      	str	r3, [r2, #4]
 8004a2a:	440c      	add	r4, r1
 8004a2c:	6014      	str	r4, [r2, #0]
 8004a2e:	e7da      	b.n	80049e6 <_free_r+0x26>
 8004a30:	d902      	bls.n	8004a38 <_free_r+0x78>
 8004a32:	230c      	movs	r3, #12
 8004a34:	6003      	str	r3, [r0, #0]
 8004a36:	e7d6      	b.n	80049e6 <_free_r+0x26>
 8004a38:	6825      	ldr	r5, [r4, #0]
 8004a3a:	1961      	adds	r1, r4, r5
 8004a3c:	428b      	cmp	r3, r1
 8004a3e:	bf04      	itt	eq
 8004a40:	6819      	ldreq	r1, [r3, #0]
 8004a42:	685b      	ldreq	r3, [r3, #4]
 8004a44:	6063      	str	r3, [r4, #4]
 8004a46:	bf04      	itt	eq
 8004a48:	1949      	addeq	r1, r1, r5
 8004a4a:	6021      	streq	r1, [r4, #0]
 8004a4c:	6054      	str	r4, [r2, #4]
 8004a4e:	e7ca      	b.n	80049e6 <_free_r+0x26>
 8004a50:	b003      	add	sp, #12
 8004a52:	bd30      	pop	{r4, r5, pc}
 8004a54:	20001b54 	.word	0x20001b54

08004a58 <_sbrk>:
 8004a58:	4a04      	ldr	r2, [pc, #16]	; (8004a6c <_sbrk+0x14>)
 8004a5a:	6811      	ldr	r1, [r2, #0]
 8004a5c:	4603      	mov	r3, r0
 8004a5e:	b909      	cbnz	r1, 8004a64 <_sbrk+0xc>
 8004a60:	4903      	ldr	r1, [pc, #12]	; (8004a70 <_sbrk+0x18>)
 8004a62:	6011      	str	r1, [r2, #0]
 8004a64:	6810      	ldr	r0, [r2, #0]
 8004a66:	4403      	add	r3, r0
 8004a68:	6013      	str	r3, [r2, #0]
 8004a6a:	4770      	bx	lr
 8004a6c:	20001c9c 	.word	0x20001c9c
 8004a70:	20001ca0 	.word	0x20001ca0

08004a74 <_init>:
 8004a74:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8004a76:	bf00      	nop
 8004a78:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8004a7a:	bc08      	pop	{r3}
 8004a7c:	469e      	mov	lr, r3
 8004a7e:	4770      	bx	lr

08004a80 <_fini>:
 8004a80:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8004a82:	bf00      	nop
 8004a84:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8004a86:	bc08      	pop	{r3}
 8004a88:	469e      	mov	lr, r3
 8004a8a:	4770      	bx	lr
